(() => {
    var __webpack_modules__ = {
        882: function(__unused_webpack_module, exports) {
            !function(a, t) {
                true ? t(exports) : 0;
            }(0, (function(a) {
                "use strict";
                var o = {
                    ar: {
                        touch: "استخدم إصبعين لتحريك الخريطة",
                        scroll: "‏استخدم ctrl + scroll لتصغير/تكبير الخريطة",
                        scrollMac: "يمكنك استخدام ⌘ + التمرير لتكبير/تصغير الخريطة"
                    },
                    bg: {
                        touch: "Използвайте два пръста, за да преместите картата",
                        scroll: "Задръжте бутона Ctrl натиснат, докато превъртате, за да промените мащаба на картата",
                        scrollMac: "Задръжте бутона ⌘ натиснат, докато превъртате, за да промените мащаба на картата"
                    },
                    bn: {
                        touch: "মানচিত্রটিকে সরাতে দুটি আঙ্গুল ব্যবহার করুন",
                        scroll: "ম্যাপ জুম করতে ctrl + scroll ব্যবহার করুন",
                        scrollMac: "ম্যাপে জুম করতে ⌘ বোতাম টিপে স্ক্রল করুন"
                    },
                    ca: {
                        touch: "Fes servir dos dits per moure el mapa",
                        scroll: "Prem la tecla Control mentre et desplaces per apropar i allunyar el mapa",
                        scrollMac: "Prem la tecla ⌘ mentre et desplaces per apropar i allunyar el mapa"
                    },
                    cs: {
                        touch: "K posunutí mapy použijte dva prsty",
                        scroll: "Velikost zobrazení mapy změňte podržením klávesy Ctrl a posouváním kolečka myši",
                        scrollMac: "Velikost zobrazení mapy změníte podržením klávesy ⌘ a posunutím kolečka myši / touchpadu"
                    },
                    da: {
                        touch: "Brug to fingre til at flytte kortet",
                        scroll: "Brug ctrl + rullefunktionen til at zoome ind og ud på kortet",
                        scrollMac: "Brug ⌘ + rullefunktionen til at zoome ind og ud på kortet"
                    },
                    de: {
                        touch: "Verschieben der Karte mit zwei Fingern",
                        scroll: "Verwende Strg+Scrollen zum Zoomen der Karte",
                        scrollMac: "⌘"
                    },
                    el: {
                        touch: "Χρησιμοποιήστε δύο δάχτυλα για μετακίνηση στον χάρτη",
                        scroll: "Χρησιμοποιήστε το πλήκτρο Ctrl και κύλιση, για να μεγεθύνετε τον χάρτη",
                        scrollMac: "Χρησιμοποιήστε το πλήκτρο ⌘ + κύλιση για εστίαση στον χάρτη"
                    },
                    en: {
                        touch: "Use two fingers to move the map",
                        scroll: "Use ctrl + scroll to zoom the map",
                        scrollMac: "Use ⌘ + scroll to zoom the map"
                    },
                    "en-AU": {
                        touch: "Use two fingers to move the map",
                        scroll: "Use ctrl + scroll to zoom the map",
                        scrollMac: "Use ⌘ + scroll to zoom the map"
                    },
                    "en-GB": {
                        touch: "Use two fingers to move the map",
                        scroll: "Use ctrl + scroll to zoom the map",
                        scrollMac: "Use ⌘ + scroll to zoom the map"
                    },
                    es: {
                        touch: "Para mover el mapa, utiliza dos dedos",
                        scroll: "Mantén pulsada la tecla Ctrl mientras te desplazas para acercar o alejar el mapa",
                        scrollMac: "Mantén pulsada la tecla ⌘ mientras te desplazas para acercar o alejar el mapa"
                    },
                    eu: {
                        touch: "Erabili bi hatz mapa mugitzeko",
                        scroll: "Mapan zooma aplikatzeko, sakatu Ktrl eta egin gora edo behera",
                        scrollMac: "Eduki sakatuta ⌘ eta egin gora eta behera mapa handitu eta txikitzeko"
                    },
                    fa: {
                        touch: "برای حرکت دادن نقشه از دو انگشت استفاده کنید.",
                        scroll: "‏برای بزرگ‌نمایی نقشه از ctrl + scroll استفاده کنید",
                        scrollMac: "برای بزرگ‌نمایی نقشه، از ⌘ + پیمایش استفاده کنید."
                    },
                    fi: {
                        touch: "Siirrä karttaa kahdella sormella.",
                        scroll: "Zoomaa karttaa painamalla Ctrl-painiketta ja vierittämällä.",
                        scrollMac: "Zoomaa karttaa pitämällä painike ⌘ painettuna ja vierittämällä."
                    },
                    fil: {
                        touch: "Gumamit ng dalawang daliri upang iusog ang mapa",
                        scroll: "Gamitin ang ctrl + scroll upang i-zoom ang mapa",
                        scrollMac: "Gamitin ang ⌘ + scroll upang i-zoom ang mapa"
                    },
                    fr: {
                        touch: "Utilisez deux doigts pour déplacer la carte",
                        scroll: "Vous pouvez zoomer sur la carte à l'aide de CTRL+Molette de défilement",
                        scrollMac: "Vous pouvez zoomer sur la carte à l'aide de ⌘+Molette de défilement"
                    },
                    gl: {
                        touch: "Utiliza dous dedos para mover o mapa",
                        scroll: "Preme Ctrl mentres te desprazas para ampliar o mapa",
                        scrollMac: "Preme ⌘ e desprázate para ampliar o mapa"
                    },
                    gu: {
                        touch: "નકશો ખસેડવા બે આંગળીઓનો ઉપયોગ કરો",
                        scroll: "નકશાને ઝૂમ કરવા માટે ctrl + સ્ક્રોલનો ઉપયોગ કરો",
                        scrollMac: "નકશાને ઝૂમ કરવા ⌘ + સ્ક્રોલનો ઉપયોગ કરો"
                    },
                    hi: {
                        touch: "मैप एक जगह से दूसरी जगह ले जाने के लिए दो उंगलियों का इस्तेमाल करें",
                        scroll: "मैप को ज़ूम करने के लिए ctrl + स्क्रोल का उपयोग करें",
                        scrollMac: "मैप को ज़ूम करने के लिए ⌘ + स्क्रोल का उपयोग करें"
                    },
                    hr: {
                        touch: "Pomičite kartu pomoću dva prsta",
                        scroll: "Upotrijebite Ctrl i klizač miša da biste zumirali kartu",
                        scrollMac: "Upotrijebite gumb ⌘ dok se pomičete za zumiranje karte"
                    },
                    hu: {
                        touch: "Két ujjal mozgassa a térképet",
                        scroll: "A térkép a ctrl + görgetés használatával nagyítható",
                        scrollMac: "A térkép a ⌘ + görgetés használatával nagyítható"
                    },
                    id: {
                        touch: "Gunakan dua jari untuk menggerakkan peta",
                        scroll: "Gunakan ctrl + scroll untuk memperbesar atau memperkecil peta",
                        scrollMac: "Gunakan ⌘ + scroll untuk memperbesar atau memperkecil peta"
                    },
                    it: {
                        touch: "Utilizza due dita per spostare la mappa",
                        scroll: "Utilizza CTRL + scorrimento per eseguire lo zoom della mappa",
                        scrollMac: "Utilizza ⌘ + scorrimento per eseguire lo zoom della mappa"
                    },
                    iw: {
                        touch: "הזז את המפה באמצעות שתי אצבעות",
                        scroll: "‏אפשר לשנות את מרחק התצוגה במפה באמצעות מקש ctrl וגלילה",
                        scrollMac: "אפשר לשנות את מרחק התצוגה במפה באמצעות מקש ⌘ וגלילה"
                    },
                    ja: {
                        touch: "地図を移動させるには指 2 本で操作します",
                        scroll: "地図をズームするには、Ctrl キーを押しながらスクロールしてください",
                        scrollMac: "地図をズームするには、⌘ キーを押しながらスクロールしてください"
                    },
                    kn: {
                        touch: "Use two fingers to move the map",
                        scroll: "Use Ctrl + scroll to zoom the map",
                        scrollMac: "Use ⌘ + scroll to zoom the map"
                    },
                    ko: {
                        touch: "지도를 움직이려면 두 손가락을 사용하세요.",
                        scroll: "지도를 확대/축소하려면 Ctrl을 누른 채 스크롤하세요.",
                        scrollMac: "지도를 확대하려면 ⌘ + 스크롤 사용"
                    },
                    lt: {
                        touch: "Perkelkite žemėlapį dviem pirštais",
                        scroll: "Slinkite nuspaudę klavišą „Ctrl“, kad pakeistumėte žemėlapio mastelį",
                        scrollMac: "Paspauskite klavišą ⌘ ir slinkite, kad priartintumėte žemėlapį"
                    },
                    lv: {
                        touch: "Lai pārvietotu karti, bīdiet to ar diviem pirkstiem",
                        scroll: "Kartes tālummaiņai izmantojiet ctrl + ritināšanu",
                        scrollMac: "Lai veiktu kartes tālummaiņu, izmantojiet ⌘ + ritināšanu"
                    },
                    ml: {
                        touch: "മാപ്പ് നീക്കാൻ രണ്ട് വിരലുകൾ ഉപയോഗിക്കുക",
                        scroll: "കൺട്രോൾ + സ്‌ക്രോൾ ഉപയോഗിച്ച് ‌മാപ്പ് ‌സൂം ചെയ്യുക",
                        scrollMac: "⌘ + സ്‌ക്രോൾ ഉപയോഗിച്ച് ‌മാപ്പ് ‌സൂം ചെയ്യുക"
                    },
                    mr: {
                        touch: "नकाशा हलविण्यासाठी दोन बोटे वापरा",
                        scroll: "नकाशा झूम करण्यासाठी ctrl + scroll वापरा",
                        scrollMac: "नकाशावर झूम करण्यासाठी ⌘ + स्क्रोल वापरा"
                    },
                    nl: {
                        touch: "Gebruik twee vingers om de kaart te verplaatsen",
                        scroll: "Gebruik Ctrl + scrollen om in- en uit te zoomen op de kaart",
                        scrollMac: "Gebruik ⌘ + scrollen om in en uit te zoomen op de kaart"
                    },
                    no: {
                        touch: "Bruk to fingre for å flytte kartet",
                        scroll: "Hold ctrl-tasten inne og rull for å zoome på kartet",
                        scrollMac: "Hold inne ⌘-tasten og rull for å zoome på kartet"
                    },
                    pl: {
                        touch: "Przesuń mapę dwoma palcami",
                        scroll: "Naciśnij CTRL i przewiń, by przybliżyć mapę",
                        scrollMac: "Naciśnij ⌘ i przewiń, by przybliżyć mapę"
                    },
                    pt: {
                        touch: "Use dois dedos para mover o mapa",
                        scroll: "Pressione Ctrl e role a tela simultaneamente para aplicar zoom no mapa",
                        scrollMac: "Use ⌘ e role a tela simultaneamente para aplicar zoom no mapa"
                    },
                    "pt-BR": {
                        touch: "Use dois dedos para mover o mapa",
                        scroll: "Pressione Ctrl e role a tela simultaneamente para aplicar zoom no mapa",
                        scrollMac: "Use ⌘ e role a tela simultaneamente para aplicar zoom no mapa"
                    },
                    "pt-PT": {
                        touch: "Utilize dois dedos para mover o mapa",
                        scroll: "Utilizar ctrl + deslocar para aumentar/diminuir zoom do mapa",
                        scrollMac: "Utilize ⌘ + deslocar para aumentar/diminuir o zoom do mapa"
                    },
                    ro: {
                        touch: "Folosiți două degete pentru a deplasa harta",
                        scroll: "Apăsați tasta ctrl și derulați simultan pentru a mări harta",
                        scrollMac: "Folosiți ⌘ și derulați pentru a mări/micșora harta"
                    },
                    ru: {
                        touch: "Чтобы переместить карту, проведите по ней двумя пальцами",
                        scroll: "Чтобы изменить масштаб, прокручивайте карту, удерживая клавишу Ctrl.",
                        scrollMac: "Чтобы изменить масштаб, нажмите ⌘ + прокрутка"
                    },
                    sk: {
                        touch: "Mapu môžete posunúť dvoma prstami",
                        scroll: "Ak chcete priblížiť mapu, stlačte kláves ctrl a posúvajte",
                        scrollMac: "Ak chcete priblížiť mapu, stlačte kláves ⌘ a posúvajte kolieskom myši"
                    },
                    sl: {
                        touch: "Premaknite zemljevid z dvema prstoma",
                        scroll: "Zemljevid povečate tako, da držite tipko Ctrl in vrtite kolesce na miški",
                        scrollMac: "Uporabite ⌘ + funkcijo pomika, da povečate ali pomanjšate zemljevid"
                    },
                    sr: {
                        touch: "Мапу померајте помоћу два прста",
                        scroll: "Притисните ctrl тастер док померате да бисте зумирали мапу",
                        scrollMac: "Притисните тастер ⌘ док померате да бисте зумирали мапу"
                    },
                    sv: {
                        touch: "Använd två fingrar för att flytta kartan",
                        scroll: "Använd ctrl + rulla för att zooma kartan",
                        scrollMac: "Använd ⌘ + rulla för att zooma på kartan"
                    },
                    ta: {
                        touch: "மேப்பை நகர்த்த இரண்டு விரல்களைப் பயன்படுத்தவும்",
                        scroll: "மேப்பை பெரிதாக்கி/சிறிதாக்கிப் பார்க்க, ctrl பட்டனைப் பிடித்தபடி, மேலே/கீழே ஸ்க்ரால் செய்யவும்",
                        scrollMac: "மேப்பை பெரிதாக்கி/சிறிதாக்கிப் பார்க்க, ⌘ பட்டனைப் பிடித்தபடி, மேலே/கீழே ஸ்க்ரால் செய்யவும்"
                    },
                    te: {
                        touch: "మ్యాప్‌ని తరలించడం కోసం రెండు వేళ్లను ఉపయోగించండి",
                        scroll: "మ్యాప్‌ని జూమ్ చేయడానికి ctrl బటన్‌ను నొక్కి ఉంచి, స్క్రోల్ చేయండి",
                        scrollMac: "మ్యాప్ జూమ్ చేయాలంటే ⌘ + స్క్రోల్ ఉపయోగించండి"
                    },
                    th: {
                        touch: "ใช้ 2 นิ้วเพื่อเลื่อนแผนที่",
                        scroll: "กด Ctrl ค้างไว้ แล้วเลื่อนหน้าจอเพื่อซูมแผนที่",
                        scrollMac: "กด ⌘ แล้วเลื่อนหน้าจอเพื่อซูมแผนที่"
                    },
                    tl: {
                        touch: "Gumamit ng dalawang daliri upang iusog ang mapa",
                        scroll: "Gamitin ang ctrl + scroll upang i-zoom ang mapa",
                        scrollMac: "Gamitin ang ⌘ + scroll upang i-zoom ang mapa"
                    },
                    tr: {
                        touch: "Haritada gezinmek için iki parmağınızı kullanın",
                        scroll: "Haritayı yakınlaştırmak için ctrl + kaydırma kombinasyonunu kullanın",
                        scrollMac: "Haritayı yakınlaştırmak için ⌘ tuşuna basıp ekranı kaydırın"
                    },
                    uk: {
                        touch: "Переміщуйте карту двома пальцями",
                        scroll: "Щоб змінювати масштаб карти, прокручуйте коліщатко миші, утримуючи клавішу Ctrl",
                        scrollMac: "Щоб змінити масштаб карти, використовуйте ⌘ + прокручування"
                    },
                    vi: {
                        touch: "Sử dụng hai ngón tay để di chuyển bản đồ",
                        scroll: "Sử dụng ctrl + cuộn để thu phóng bản đồ",
                        scrollMac: "Sử dụng ⌘ + cuộn để thu phóng bản đồ"
                    },
                    "zh-CN": {
                        touch: "使用双指移动地图",
                        scroll: "按住 Ctrl 并滚动鼠标滚轮才可缩放地图",
                        scrollMac: "按住 ⌘ 并滚动鼠标滚轮才可缩放地图"
                    },
                    "zh-TW": {
                        touch: "同時以兩指移動地圖",
                        scroll: "按住 ctrl 鍵加上捲動滑鼠可以縮放地圖",
                        scrollMac: "按 ⌘ 加上滾動捲軸可以縮放地圖"
                    }
                };
                L.Map.mergeOptions({
                    gestureHandlingOptions: {
                        text: {},
                        duration: 1e3
                    }
                });
                var t = !1, e = L.Handler.extend({
                    addHooks: function() {
                        this._handleTouch = this._handleTouch.bind(this), this._setupPluginOptions(), this._setLanguageContent(), 
                        this._disableInteractions(), this._map._container.addEventListener("touchstart", this._handleTouch), 
                        this._map._container.addEventListener("touchmove", this._handleTouch), this._map._container.addEventListener("touchend", this._handleTouch), 
                        this._map._container.addEventListener("touchcancel", this._handleTouch), this._map._container.addEventListener("click", this._handleTouch), 
                        L.DomEvent.on(this._map._container, "wheel", this._handleScroll, this), L.DomEvent.on(this._map, "mouseover", this._handleMouseOver, this), 
                        L.DomEvent.on(this._map, "mouseout", this._handleMouseOut, this), L.DomEvent.on(this._map, "movestart", this._handleDragging, this), 
                        L.DomEvent.on(this._map, "move", this._handleDragging, this), L.DomEvent.on(this._map, "moveend", this._handleDragging, this);
                    },
                    removeHooks: function() {
                        this._enableInteractions(), this._map._container.removeEventListener("touchstart", this._handleTouch), 
                        this._map._container.removeEventListener("touchmove", this._handleTouch), this._map._container.removeEventListener("touchend", this._handleTouch), 
                        this._map._container.removeEventListener("touchcancel", this._handleTouch), this._map._container.removeEventListener("click", this._handleTouch), 
                        L.DomEvent.off(this._map._container, "wheel", this._handleScroll, this), L.DomEvent.off(this._map, "mouseover", this._handleMouseOver, this), 
                        L.DomEvent.off(this._map, "mouseout", this._handleMouseOut, this), L.DomEvent.off(this._map, "movestart", this._handleDragging, this), 
                        L.DomEvent.off(this._map, "move", this._handleDragging, this), L.DomEvent.off(this._map, "moveend", this._handleDragging, this);
                    },
                    _handleDragging: function(a) {
                        "movestart" == a.type || "move" == a.type ? t = !0 : "moveend" == a.type && (t = !1);
                    },
                    _disableInteractions: function() {
                        this._map.dragging.disable(), this._map.scrollWheelZoom.disable(), this._map.tap && this._map.tap.disable();
                    },
                    _enableInteractions: function() {
                        this._map.dragging.enable(), this._map.scrollWheelZoom.enable(), this._map.tap && this._map.tap.enable();
                    },
                    _setupPluginOptions: function() {
                        this._map.options.gestureHandlingText && (this._map.options.gestureHandlingOptions.text = this._map.options.gestureHandlingText);
                    },
                    _setLanguageContent: function() {
                        var a;
                        if (this._map.options.gestureHandlingOptions && this._map.options.gestureHandlingOptions.text && this._map.options.gestureHandlingOptions.text.touch && this._map.options.gestureHandlingOptions.text.scroll && this._map.options.gestureHandlingOptions.text.scrollMac) a = this._map.options.gestureHandlingOptions.text; else {
                            var t = this._getUserLanguage();
                            t || (t = "en"), o[t] && (a = o[t]), a || -1 === t.indexOf("-") || (t = t.split("-")[0], 
                            a = o[t]), a || (a = o[t = "en"]);
                        }
                        var e = !1;
                        0 <= navigator.platform.toUpperCase().indexOf("MAC") && (e = !0);
                        var l = a.scroll;
                        e && (l = a.scrollMac), this._map._container.setAttribute("data-gesture-handling-touch-content", a.touch), 
                        this._map._container.setAttribute("data-gesture-handling-scroll-content", l);
                    },
                    _getUserLanguage: function() {
                        return navigator.languages ? navigator.languages[0] : navigator.language || navigator.userLanguage;
                    },
                    _handleTouch: function(a) {
                        for (var t = [ "leaflet-control-minimap", "leaflet-interactive", "leaflet-popup-content", "leaflet-popup-content-wrapper", "leaflet-popup-close-button", "leaflet-control-zoom-in", "leaflet-control-zoom-out" ], e = !1, l = 0; l < t.length; l++) L.DomUtil.hasClass(a.target, t[l]) && (e = !0);
                        e ? L.DomUtil.hasClass(a.target, "leaflet-interactive") && "touchmove" === a.type && 1 === a.touches.length ? (L.DomUtil.addClass(this._map._container, "leaflet-gesture-handling-touch-warning"), 
                        this._disableInteractions()) : L.DomUtil.removeClass(this._map._container, "leaflet-gesture-handling-touch-warning") : "touchmove" === a.type || "touchstart" === a.type ? 1 === a.touches.length ? (L.DomUtil.addClass(this._map._container, "leaflet-gesture-handling-touch-warning"), 
                        this._disableInteractions()) : (a.preventDefault(), this._enableInteractions(), 
                        L.DomUtil.removeClass(this._map._container, "leaflet-gesture-handling-touch-warning")) : L.DomUtil.removeClass(this._map._container, "leaflet-gesture-handling-touch-warning");
                    },
                    _isScrolling: !1,
                    _handleScroll: function(a) {
                        a.metaKey || a.ctrlKey ? (a.preventDefault(), L.DomUtil.removeClass(this._map._container, "leaflet-gesture-handling-scroll-warning"), 
                        this._map.scrollWheelZoom.enable()) : (L.DomUtil.addClass(this._map._container, "leaflet-gesture-handling-scroll-warning"), 
                        this._map.scrollWheelZoom.disable(), clearTimeout(this._isScrolling), this._isScrolling = setTimeout((function() {
                            for (var a = document.getElementsByClassName("leaflet-gesture-handling-scroll-warning"), t = 0; t < a.length; t++) L.DomUtil.removeClass(a[t], "leaflet-gesture-handling-scroll-warning");
                        }), this._map.options.gestureHandlingOptions.duration));
                    },
                    _handleMouseOver: function(a) {
                        this._enableInteractions();
                    },
                    _handleMouseOut: function(a) {
                        t || this._disableInteractions();
                    }
                });
                L.Map.addInitHook("addHandler", "gestureHandling", e), a.GestureHandling = e, a.default = e, 
                Object.defineProperty(a, "__esModule", {
                    value: !0
                });
            }));
        },
        769: () => {
            (function() {
                "use strict";
                var NEWER = Symbol("newer");
                var OLDER = Symbol("older");
                var LRUMap = function LRUMap(limit, entries) {
                    if (typeof limit !== "number") {
                        entries = limit;
                        limit = 0;
                    }
                    this.size = 0;
                    this.limit = limit;
                    this.oldest = this.newest = void 0;
                    this._keymap = new Map;
                    if (entries) {
                        this.assign(entries);
                        if (limit < 1) this.limit = this.size;
                    }
                };
                LRUMap.prototype._markEntryAsUsed = function _markEntryAsUsed(entry) {
                    if (entry === this.newest) return;
                    if (entry[NEWER]) {
                        if (entry === this.oldest) this.oldest = entry[NEWER];
                        entry[NEWER][OLDER] = entry[OLDER];
                    }
                    if (entry[OLDER]) entry[OLDER][NEWER] = entry[NEWER];
                    entry[NEWER] = void 0;
                    entry[OLDER] = this.newest;
                    if (this.newest) this.newest[NEWER] = entry;
                    this.newest = entry;
                };
                LRUMap.prototype.assign = function assign(entries) {
                    var entry, limit = this.limit || Number.MAX_VALUE;
                    this._keymap.clear();
                    var it = entries[Symbol.iterator]();
                    for (var itv = it.next(); !itv.done; itv = it.next()) {
                        var e = new Entry(itv.value[0], itv.value[1]);
                        this._keymap.set(e.key, e);
                        if (!entry) this.oldest = e; else {
                            entry[NEWER] = e;
                            e[OLDER] = entry;
                        }
                        entry = e;
                        if (limit-- == 0) throw new Error("overflow");
                    }
                    this.newest = entry;
                    this.size = this._keymap.size;
                };
                LRUMap.prototype.get = function get(key) {
                    var entry = this._keymap.get(key);
                    if (!entry) return;
                    this._markEntryAsUsed(entry);
                    return entry.value;
                };
                LRUMap.prototype.set = function set(key, value) {
                    var entry = this._keymap.get(key);
                    if (entry) {
                        entry.value = value;
                        this._markEntryAsUsed(entry);
                        return this;
                    }
                    this._keymap.set(key, entry = new Entry(key, value));
                    if (this.newest) {
                        this.newest[NEWER] = entry;
                        entry[OLDER] = this.newest;
                    } else this.oldest = entry;
                    this.newest = entry;
                    ++this.size;
                    if (this.size > this.limit) this.shift();
                    return this;
                };
                LRUMap.prototype.shift = function shift() {
                    var entry = this.oldest;
                    if (entry) {
                        if (this.oldest[NEWER]) {
                            this.oldest = this.oldest[NEWER];
                            this.oldest[OLDER] = void 0;
                        } else {
                            this.oldest = void 0;
                            this.newest = void 0;
                        }
                        entry[NEWER] = entry[OLDER] = void 0;
                        this._keymap.delete(entry.key);
                        --this.size;
                        return [ entry.key, entry.value ];
                    }
                };
                LRUMap.prototype.find = function find(key) {
                    var e = this._keymap.get(key);
                    return e ? e.value : void 0;
                };
                LRUMap.prototype.has = function has(key) {
                    return this._keymap.has(key);
                };
                LRUMap.prototype.delete = function delete$1(key) {
                    var entry = this._keymap.get(key);
                    if (!entry) return;
                    this._keymap.delete(entry.key);
                    if (entry[NEWER] && entry[OLDER]) {
                        entry[OLDER][NEWER] = entry[NEWER];
                        entry[NEWER][OLDER] = entry[OLDER];
                    } else if (entry[NEWER]) {
                        entry[NEWER][OLDER] = void 0;
                        this.oldest = entry[NEWER];
                    } else if (entry[OLDER]) {
                        entry[OLDER][NEWER] = void 0;
                        this.newest = entry[OLDER];
                    } else this.oldest = this.newest = void 0;
                    this.size--;
                    return entry.value;
                };
                LRUMap.prototype.clear = function clear() {
                    this.oldest = this.newest = void 0;
                    this.size = 0;
                    this._keymap.clear();
                };
                LRUMap.prototype.keys = function keys() {
                    return new KeyIterator(this.oldest);
                };
                LRUMap.prototype.values = function values() {
                    return new ValueIterator(this.oldest);
                };
                LRUMap.prototype.entries = function entries() {
                    return this;
                };
                LRUMap.prototype[Symbol.iterator] = function() {
                    return new EntryIterator(this.oldest);
                };
                LRUMap.prototype.forEach = function forEach(fun, thisObj) {
                    if (typeof thisObj !== "object") thisObj = this;
                    var entry = this.oldest;
                    while (entry) {
                        fun.call(thisObj, entry.value, entry.key, this);
                        entry = entry[NEWER];
                    }
                };
                LRUMap.prototype.toJSON = function toJSON() {
                    var s = new Array(this.size), i = 0, entry = this.oldest;
                    while (entry) {
                        s[i++] = {
                            key: entry.key,
                            value: entry.value
                        };
                        entry = entry[NEWER];
                    }
                    return s;
                };
                LRUMap.prototype.toString = function toString() {
                    var s = "", entry = this.oldest;
                    while (entry) {
                        s += String(entry.key) + ":" + entry.value;
                        entry = entry[NEWER];
                        if (entry) s += " < ";
                    }
                    return s;
                };
                function Entry(key, value) {
                    this.key = key;
                    this.value = value;
                    this[NEWER] = void 0;
                    this[OLDER] = void 0;
                }
                function EntryIterator(oldestEntry) {
                    this.entry = oldestEntry;
                }
                EntryIterator.prototype[Symbol.iterator] = function() {
                    return this;
                };
                EntryIterator.prototype.next = function() {
                    var ent = this.entry;
                    if (ent) {
                        this.entry = ent[NEWER];
                        return {
                            done: false,
                            value: [ ent.key, ent.value ]
                        };
                    } else return {
                        done: true,
                        value: void 0
                    };
                };
                function KeyIterator(oldestEntry) {
                    this.entry = oldestEntry;
                }
                KeyIterator.prototype[Symbol.iterator] = function() {
                    return this;
                };
                KeyIterator.prototype.next = function() {
                    var ent = this.entry;
                    if (ent) {
                        this.entry = ent[NEWER];
                        return {
                            done: false,
                            value: ent.key
                        };
                    } else return {
                        done: true,
                        value: void 0
                    };
                };
                function ValueIterator(oldestEntry) {
                    this.entry = oldestEntry;
                }
                ValueIterator.prototype[Symbol.iterator] = function() {
                    return this;
                };
                ValueIterator.prototype.next = function() {
                    var ent = this.entry;
                    if (ent) {
                        this.entry = ent[NEWER];
                        return {
                            done: false,
                            value: ent.value
                        };
                    } else return {
                        done: true,
                        value: void 0
                    };
                };
                function waitForAPI(callback, context) {
                    var checkCounter = 0, intervalId = null;
                    intervalId = setInterval((function() {
                        if (checkCounter >= 20) {
                            clearInterval(intervalId);
                            throw new Error("window.google not found after 10 seconds");
                        }
                        if (!!window.google && !!window.google.maps && !!window.google.maps.Map) {
                            clearInterval(intervalId);
                            callback.call(context);
                        }
                        ++checkCounter;
                    }), 500);
                }
                L.GridLayer.GoogleMutant = L.GridLayer.extend({
                    options: {
                        maxZoom: 21,
                        type: "roadmap",
                        maxNativeZoom: 21
                    },
                    initialize: function(options) {
                        L.GridLayer.prototype.initialize.call(this, options);
                        this._tileCallbacks = {};
                        this._lru = new LRUMap(100);
                        this._imagesPerTile = this.options.type === "hybrid" ? 2 : 1;
                        this._boundOnMutatedImage = this._onMutatedImage.bind(this);
                    },
                    onAdd: function(map) {
                        var this$1 = this;
                        L.GridLayer.prototype.onAdd.call(this, map);
                        this._initMutantContainer();
                        if (this._logoContainer) map._controlCorners.bottomleft.appendChild(this._logoContainer);
                        if (this._attributionContainer) map._controlCorners.bottomright.appendChild(this._attributionContainer);
                        waitForAPI((function() {
                            if (!this$1._map) return;
                            this$1._initMutant();
                            google.maps.event.addListenerOnce(this$1._mutant, "idle", (function() {
                                if (!this$1._map) return;
                                this$1._checkZoomLevels();
                                this$1._mutantIsReady = true;
                            }));
                        }));
                    },
                    onRemove: function(map) {
                        L.GridLayer.prototype.onRemove.call(this, map);
                        this._observer.disconnect();
                        map._container.removeChild(this._mutantContainer);
                        if (this._logoContainer) L.DomUtil.remove(this._logoContainer);
                        if (this._attributionContainer) L.DomUtil.remove(this._attributionContainer);
                        if (this._mutant) google.maps.event.clearListeners(this._mutant, "idle");
                    },
                    addGoogleLayer: function(googleLayerName, options) {
                        var this$1 = this;
                        if (!this._subLayers) this._subLayers = {};
                        this.whenReady((function() {
                            var Constructor = google.maps[googleLayerName];
                            var googleLayer = new Constructor(options);
                            googleLayer.setMap(this$1._mutant);
                            this$1._subLayers[googleLayerName] = googleLayer;
                        }));
                        return this;
                    },
                    removeGoogleLayer: function(googleLayerName) {
                        var this$1 = this;
                        this.whenReady((function() {
                            var googleLayer = this$1._subLayers && this$1._subLayers[googleLayerName];
                            if (googleLayer) {
                                googleLayer.setMap(null);
                                delete this$1._subLayers[googleLayerName];
                            }
                        }));
                        return this;
                    },
                    _initMutantContainer: function() {
                        if (!this._mutantContainer) {
                            this._mutantContainer = L.DomUtil.create("div", "leaflet-google-mutant leaflet-top leaflet-left");
                            this._mutantContainer.id = "_MutantContainer_" + L.Util.stamp(this._mutantContainer);
                            this._mutantContainer.style.pointerEvents = "none";
                            this._mutantContainer.style.visibility = "hidden";
                            L.DomEvent.off(this._mutantContainer);
                        }
                        this._map.getContainer().appendChild(this._mutantContainer);
                        this.setOpacity(this.options.opacity);
                        var style = this._mutantContainer.style;
                        if (this._map.options.zoomSnap < 1) {
                            style.width = "180%";
                            style.height = "180%";
                        } else {
                            style.width = "100%";
                            style.height = "100%";
                        }
                        style.zIndex = -1;
                        this._attachObserver(this._mutantContainer);
                    },
                    _initMutant: function() {
                        if (this._mutant) return;
                        var map = new google.maps.Map(this._mutantContainer, {
                            center: {
                                lat: 0,
                                lng: 0
                            },
                            zoom: 0,
                            tilt: 0,
                            mapTypeId: this.options.type,
                            disableDefaultUI: true,
                            keyboardShortcuts: false,
                            draggable: false,
                            disableDoubleClickZoom: true,
                            scrollwheel: false,
                            styles: this.options.styles || [],
                            backgroundColor: "transparent"
                        });
                        this._mutant = map;
                        this._update();
                        this.fire("spawned", {
                            mapObject: map
                        });
                        this._waitControls();
                        this.once("controls_ready", this._setupAttribution);
                    },
                    _attachObserver: function _attachObserver(node) {
                        if (!this._observer) this._observer = new MutationObserver(this._onMutations.bind(this));
                        this._observer.observe(node, {
                            childList: true,
                            subtree: true
                        });
                        Array.prototype.forEach.call(node.querySelectorAll("img"), this._boundOnMutatedImage);
                    },
                    _waitControls: function() {
                        var this$1 = this;
                        var id = setInterval((function() {
                            var layoutManager = this$1._mutant.__gm.layoutManager;
                            if (!layoutManager) return;
                            clearInterval(id);
                            var positions;
                            Object.keys(layoutManager).forEach((function(key) {
                                var el = layoutManager[key];
                                if (el.get) if (el.get(1) instanceof Node) positions = el;
                            }));
                            this$1.fire("controls_ready", {
                                positions
                            });
                        }), 50);
                    },
                    _setupAttribution: function(ev) {
                        if (!this._map) return;
                        var pos = google.maps.ControlPosition;
                        var ctr = this._attributionContainer = ev.positions.get(pos.BOTTOM_RIGHT);
                        L.DomUtil.addClass(ctr, "leaflet-control leaflet-control-attribution");
                        L.DomEvent.disableClickPropagation(ctr);
                        ctr.style.height = "14px";
                        this._map._controlCorners.bottomright.appendChild(ctr);
                        this._logoContainer = ev.positions.get(pos.BOTTOM_LEFT);
                        this._logoContainer.style.pointerEvents = "auto";
                        this._map._controlCorners.bottomleft.appendChild(this._logoContainer);
                    },
                    _onMutations: function _onMutations(mutations) {
                        for (var i = 0; i < mutations.length; ++i) {
                            var mutation = mutations[i];
                            for (var j = 0; j < mutation.addedNodes.length; ++j) {
                                var node = mutation.addedNodes[j];
                                if (node instanceof HTMLImageElement) this._onMutatedImage(node); else if (node instanceof HTMLElement) Array.prototype.forEach.call(node.querySelectorAll("img"), this._boundOnMutatedImage);
                            }
                        }
                    },
                    _roadRegexp: /!1i(\d+)!2i(\d+)!3i(\d+|VinaFnapurmBegrtn)!/,
                    _satRegexp: /x=(\d+)&y=(\d+)&z=(\d+|VinaFnapurmBegrtn)/,
                    _onMutatedImage: function _onMutatedImage(imgNode) {
                        var coords;
                        var match = imgNode.src.match(this._roadRegexp);
                        var sublayer = 0;
                        if (match) {
                            coords = {
                                z: match[1],
                                x: match[2],
                                y: match[3]
                            };
                            if (this._imagesPerTile > 1) {
                                imgNode.style.zIndex = 1;
                                sublayer = 1;
                            }
                        } else {
                            match = imgNode.src.match(this._satRegexp);
                            if (match) coords = {
                                x: match[1],
                                y: match[2],
                                z: match[3]
                            };
                            sublayer = 0;
                        }
                        if (coords) {
                            var tileKey = this._tileCoordsToKey(coords);
                            imgNode.style.position = "absolute";
                            var key = tileKey + "/" + sublayer;
                            this._lru.set(key, imgNode);
                            if (key in this._tileCallbacks && this._tileCallbacks[key]) {
                                this._tileCallbacks[key].forEach((function(callback) {
                                    return callback(imgNode);
                                }));
                                delete this._tileCallbacks[key];
                            }
                        }
                    },
                    createTile: function(coords, done) {
                        var key = this._tileCoordsToKey(coords), tileContainer = L.DomUtil.create("div");
                        tileContainer.style.textAlign = "left";
                        tileContainer.dataset.pending = this._imagesPerTile;
                        done = done.bind(this, null, tileContainer);
                        for (var i = 0; i < this._imagesPerTile; ++i) {
                            var key2 = key + "/" + i, imgNode = this._lru.get(key2);
                            if (imgNode) {
                                tileContainer.appendChild(this._clone(imgNode));
                                --tileContainer.dataset.pending;
                            } else {
                                this._tileCallbacks[key2] = this._tileCallbacks[key2] || [];
                                this._tileCallbacks[key2].push(function(c) {
                                    return function(imgNode) {
                                        c.appendChild(this._clone(imgNode));
                                        --c.dataset.pending;
                                        if (!parseInt(c.dataset.pending)) done();
                                    }.bind(this);
                                }.bind(this)(tileContainer));
                            }
                        }
                        if (!parseInt(tileContainer.dataset.pending)) L.Util.requestAnimFrame(done);
                        return tileContainer;
                    },
                    _clone: function(imgNode) {
                        var clonedImgNode = imgNode.cloneNode(true);
                        clonedImgNode.style.visibility = "visible";
                        return clonedImgNode;
                    },
                    _checkZoomLevels: function() {
                        var zoomLevel = this._map.getZoom(), gMapZoomLevel = this._mutant.getZoom();
                        if (!zoomLevel || !gMapZoomLevel) return;
                        if (gMapZoomLevel !== zoomLevel || gMapZoomLevel > this.options.maxNativeZoom) this._setMaxNativeZoom(gMapZoomLevel);
                    },
                    _setMaxNativeZoom: function(zoomLevel) {
                        if (zoomLevel !== this.options.maxNativeZoom) {
                            this.options.maxNativeZoom = zoomLevel;
                            this._resetView();
                        }
                    },
                    _update: function(center) {
                        if (this._mutant) {
                            center = center || this._map.getCenter();
                            var _center = new google.maps.LatLng(center.lat, center.lng), zoom = Math.round(this._map.getZoom()), mutantZoom = this._mutant.getZoom();
                            this._mutant.setCenter(_center);
                            if (zoom !== mutantZoom) {
                                this._mutant.setZoom(zoom);
                                if (this._mutantIsReady) this._checkZoomLevels();
                            }
                        }
                        L.GridLayer.prototype._update.call(this, center);
                    },
                    whenReady: function(callback, context) {
                        if (this._mutant) callback.call(context || this, {
                            target: this
                        }); else this.on("spawned", callback, context);
                        return this;
                    }
                });
                L.gridLayer.googleMutant = function(options) {
                    return new L.GridLayer.GoogleMutant(options);
                };
            })();
        },
        481: function(__unused_webpack_module, exports) {
            /* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
            (function(global, factory) {
                true ? factory(exports) : 0;
            })(0, (function(exports) {
                "use strict";
                var version = "1.9.4";
                function extend(dest) {
                    var i, j, len, src;
                    for (j = 1, len = arguments.length; j < len; j++) {
                        src = arguments[j];
                        for (i in src) dest[i] = src[i];
                    }
                    return dest;
                }
                var create$2 = Object.create || function() {
                    function F() {}
                    return function(proto) {
                        F.prototype = proto;
                        return new F;
                    };
                }();
                function bind(fn, obj) {
                    var slice = Array.prototype.slice;
                    if (fn.bind) return fn.bind.apply(fn, slice.call(arguments, 1));
                    var args = slice.call(arguments, 2);
                    return function() {
                        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
                    };
                }
                var lastId = 0;
                function stamp(obj) {
                    if (!("_leaflet_id" in obj)) obj["_leaflet_id"] = ++lastId;
                    return obj._leaflet_id;
                }
                function throttle(fn, time, context) {
                    var lock, args, wrapperFn, later;
                    later = function() {
                        lock = false;
                        if (args) {
                            wrapperFn.apply(context, args);
                            args = false;
                        }
                    };
                    wrapperFn = function() {
                        if (lock) args = arguments; else {
                            fn.apply(context, arguments);
                            setTimeout(later, time);
                            lock = true;
                        }
                    };
                    return wrapperFn;
                }
                function wrapNum(x, range, includeMax) {
                    var max = range[1], min = range[0], d = max - min;
                    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
                }
                function falseFn() {
                    return false;
                }
                function formatNum(num, precision) {
                    if (precision === false) return num;
                    var pow = Math.pow(10, precision === void 0 ? 6 : precision);
                    return Math.round(num * pow) / pow;
                }
                function trim(str) {
                    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
                }
                function splitWords(str) {
                    return trim(str).split(/\s+/);
                }
                function setOptions(obj, options) {
                    if (!Object.prototype.hasOwnProperty.call(obj, "options")) obj.options = obj.options ? create$2(obj.options) : {};
                    for (var i in options) obj.options[i] = options[i];
                    return obj.options;
                }
                function getParamString(obj, existingUrl, uppercase) {
                    var params = [];
                    for (var i in obj) params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
                    return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
                }
                var templateRe = /\{ *([\w_ -]+) *\}/g;
                function template(str, data) {
                    return str.replace(templateRe, (function(str, key) {
                        var value = data[key];
                        if (value === void 0) throw new Error("No value provided for variable " + str); else if (typeof value === "function") value = value(data);
                        return value;
                    }));
                }
                var isArray = Array.isArray || function(obj) {
                    return Object.prototype.toString.call(obj) === "[object Array]";
                };
                function indexOf(array, el) {
                    for (var i = 0; i < array.length; i++) if (array[i] === el) return i;
                    return -1;
                }
                var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
                function getPrefixed(name) {
                    return window["webkit" + name] || window["moz" + name] || window["ms" + name];
                }
                var lastTime = 0;
                function timeoutDefer(fn) {
                    var time = +new Date, timeToCall = Math.max(0, 16 - (time - lastTime));
                    lastTime = time + timeToCall;
                    return window.setTimeout(fn, timeToCall);
                }
                var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
                var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
                    window.clearTimeout(id);
                };
                function requestAnimFrame(fn, context, immediate) {
                    if (immediate && requestFn === timeoutDefer) fn.call(context); else return requestFn.call(window, bind(fn, context));
                }
                function cancelAnimFrame(id) {
                    if (id) cancelFn.call(window, id);
                }
                var Util = {
                    __proto__: null,
                    extend,
                    create: create$2,
                    bind,
                    get lastId() {
                        return lastId;
                    },
                    stamp,
                    throttle,
                    wrapNum,
                    falseFn,
                    formatNum,
                    trim,
                    splitWords,
                    setOptions,
                    getParamString,
                    template,
                    isArray,
                    indexOf,
                    emptyImageUrl,
                    requestFn,
                    cancelFn,
                    requestAnimFrame,
                    cancelAnimFrame
                };
                function Class() {}
                Class.extend = function(props) {
                    var NewClass = function() {
                        setOptions(this);
                        if (this.initialize) this.initialize.apply(this, arguments);
                        this.callInitHooks();
                    };
                    var parentProto = NewClass.__super__ = this.prototype;
                    var proto = create$2(parentProto);
                    proto.constructor = NewClass;
                    NewClass.prototype = proto;
                    for (var i in this) if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") NewClass[i] = this[i];
                    if (props.statics) extend(NewClass, props.statics);
                    if (props.includes) {
                        checkDeprecatedMixinEvents(props.includes);
                        extend.apply(null, [ proto ].concat(props.includes));
                    }
                    extend(proto, props);
                    delete proto.statics;
                    delete proto.includes;
                    if (proto.options) {
                        proto.options = parentProto.options ? create$2(parentProto.options) : {};
                        extend(proto.options, props.options);
                    }
                    proto._initHooks = [];
                    proto.callInitHooks = function() {
                        if (this._initHooksCalled) return;
                        if (parentProto.callInitHooks) parentProto.callInitHooks.call(this);
                        this._initHooksCalled = true;
                        for (var i = 0, len = proto._initHooks.length; i < len; i++) proto._initHooks[i].call(this);
                    };
                    return NewClass;
                };
                Class.include = function(props) {
                    var parentOptions = this.prototype.options;
                    extend(this.prototype, props);
                    if (props.options) {
                        this.prototype.options = parentOptions;
                        this.mergeOptions(props.options);
                    }
                    return this;
                };
                Class.mergeOptions = function(options) {
                    extend(this.prototype.options, options);
                    return this;
                };
                Class.addInitHook = function(fn) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var init = typeof fn === "function" ? fn : function() {
                        this[fn].apply(this, args);
                    };
                    this.prototype._initHooks = this.prototype._initHooks || [];
                    this.prototype._initHooks.push(init);
                    return this;
                };
                function checkDeprecatedMixinEvents(includes) {
                    if (typeof L === "undefined" || !L || !L.Mixin) return;
                    includes = isArray(includes) ? includes : [ includes ];
                    for (var i = 0; i < includes.length; i++) if (includes[i] === L.Mixin.Events) console.warn("Deprecated include of L.Mixin.Events: " + "this property will be removed in future releases, " + "please inherit from L.Evented instead.", (new Error).stack);
                }
                var Events = {
                    on: function(types, fn, context) {
                        if (typeof types === "object") for (var type in types) this._on(type, types[type], fn); else {
                            types = splitWords(types);
                            for (var i = 0, len = types.length; i < len; i++) this._on(types[i], fn, context);
                        }
                        return this;
                    },
                    off: function(types, fn, context) {
                        if (!arguments.length) delete this._events; else if (typeof types === "object") for (var type in types) this._off(type, types[type], fn); else {
                            types = splitWords(types);
                            var removeAll = arguments.length === 1;
                            for (var i = 0, len = types.length; i < len; i++) if (removeAll) this._off(types[i]); else this._off(types[i], fn, context);
                        }
                        return this;
                    },
                    _on: function(type, fn, context, _once) {
                        if (typeof fn !== "function") {
                            console.warn("wrong listener type: " + typeof fn);
                            return;
                        }
                        if (this._listens(type, fn, context) !== false) return;
                        if (context === this) context = void 0;
                        var newListener = {
                            fn,
                            ctx: context
                        };
                        if (_once) newListener.once = true;
                        this._events = this._events || {};
                        this._events[type] = this._events[type] || [];
                        this._events[type].push(newListener);
                    },
                    _off: function(type, fn, context) {
                        var listeners, i, len;
                        if (!this._events) return;
                        listeners = this._events[type];
                        if (!listeners) return;
                        if (arguments.length === 1) {
                            if (this._firingCount) for (i = 0, len = listeners.length; i < len; i++) listeners[i].fn = falseFn;
                            delete this._events[type];
                            return;
                        }
                        if (typeof fn !== "function") {
                            console.warn("wrong listener type: " + typeof fn);
                            return;
                        }
                        var index = this._listens(type, fn, context);
                        if (index !== false) {
                            var listener = listeners[index];
                            if (this._firingCount) {
                                listener.fn = falseFn;
                                this._events[type] = listeners = listeners.slice();
                            }
                            listeners.splice(index, 1);
                        }
                    },
                    fire: function(type, data, propagate) {
                        if (!this.listens(type, propagate)) return this;
                        var event = extend({}, data, {
                            type,
                            target: this,
                            sourceTarget: data && data.sourceTarget || this
                        });
                        if (this._events) {
                            var listeners = this._events[type];
                            if (listeners) {
                                this._firingCount = this._firingCount + 1 || 1;
                                for (var i = 0, len = listeners.length; i < len; i++) {
                                    var l = listeners[i];
                                    var fn = l.fn;
                                    if (l.once) this.off(type, fn, l.ctx);
                                    fn.call(l.ctx || this, event);
                                }
                                this._firingCount--;
                            }
                        }
                        if (propagate) this._propagateEvent(event);
                        return this;
                    },
                    listens: function(type, fn, context, propagate) {
                        if (typeof type !== "string") console.warn('"string" type argument expected');
                        var _fn = fn;
                        if (typeof fn !== "function") {
                            propagate = !!fn;
                            _fn = void 0;
                            context = void 0;
                        }
                        var listeners = this._events && this._events[type];
                        if (listeners && listeners.length) if (this._listens(type, _fn, context) !== false) return true;
                        if (propagate) for (var id in this._eventParents) if (this._eventParents[id].listens(type, fn, context, propagate)) return true;
                        return false;
                    },
                    _listens: function(type, fn, context) {
                        if (!this._events) return false;
                        var listeners = this._events[type] || [];
                        if (!fn) return !!listeners.length;
                        if (context === this) context = void 0;
                        for (var i = 0, len = listeners.length; i < len; i++) if (listeners[i].fn === fn && listeners[i].ctx === context) return i;
                        return false;
                    },
                    once: function(types, fn, context) {
                        if (typeof types === "object") for (var type in types) this._on(type, types[type], fn, true); else {
                            types = splitWords(types);
                            for (var i = 0, len = types.length; i < len; i++) this._on(types[i], fn, context, true);
                        }
                        return this;
                    },
                    addEventParent: function(obj) {
                        this._eventParents = this._eventParents || {};
                        this._eventParents[stamp(obj)] = obj;
                        return this;
                    },
                    removeEventParent: function(obj) {
                        if (this._eventParents) delete this._eventParents[stamp(obj)];
                        return this;
                    },
                    _propagateEvent: function(e) {
                        for (var id in this._eventParents) this._eventParents[id].fire(e.type, extend({
                            layer: e.target,
                            propagatedFrom: e.target
                        }, e), true);
                    }
                };
                Events.addEventListener = Events.on;
                Events.removeEventListener = Events.clearAllEventListeners = Events.off;
                Events.addOneTimeEventListener = Events.once;
                Events.fireEvent = Events.fire;
                Events.hasEventListeners = Events.listens;
                var Evented = Class.extend(Events);
                function Point(x, y, round) {
                    this.x = round ? Math.round(x) : x;
                    this.y = round ? Math.round(y) : y;
                }
                var trunc = Math.trunc || function(v) {
                    return v > 0 ? Math.floor(v) : Math.ceil(v);
                };
                Point.prototype = {
                    clone: function() {
                        return new Point(this.x, this.y);
                    },
                    add: function(point) {
                        return this.clone()._add(toPoint(point));
                    },
                    _add: function(point) {
                        this.x += point.x;
                        this.y += point.y;
                        return this;
                    },
                    subtract: function(point) {
                        return this.clone()._subtract(toPoint(point));
                    },
                    _subtract: function(point) {
                        this.x -= point.x;
                        this.y -= point.y;
                        return this;
                    },
                    divideBy: function(num) {
                        return this.clone()._divideBy(num);
                    },
                    _divideBy: function(num) {
                        this.x /= num;
                        this.y /= num;
                        return this;
                    },
                    multiplyBy: function(num) {
                        return this.clone()._multiplyBy(num);
                    },
                    _multiplyBy: function(num) {
                        this.x *= num;
                        this.y *= num;
                        return this;
                    },
                    scaleBy: function(point) {
                        return new Point(this.x * point.x, this.y * point.y);
                    },
                    unscaleBy: function(point) {
                        return new Point(this.x / point.x, this.y / point.y);
                    },
                    round: function() {
                        return this.clone()._round();
                    },
                    _round: function() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        return this;
                    },
                    floor: function() {
                        return this.clone()._floor();
                    },
                    _floor: function() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        return this;
                    },
                    ceil: function() {
                        return this.clone()._ceil();
                    },
                    _ceil: function() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        return this;
                    },
                    trunc: function() {
                        return this.clone()._trunc();
                    },
                    _trunc: function() {
                        this.x = trunc(this.x);
                        this.y = trunc(this.y);
                        return this;
                    },
                    distanceTo: function(point) {
                        point = toPoint(point);
                        var x = point.x - this.x, y = point.y - this.y;
                        return Math.sqrt(x * x + y * y);
                    },
                    equals: function(point) {
                        point = toPoint(point);
                        return point.x === this.x && point.y === this.y;
                    },
                    contains: function(point) {
                        point = toPoint(point);
                        return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
                    },
                    toString: function() {
                        return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
                    }
                };
                function toPoint(x, y, round) {
                    if (x instanceof Point) return x;
                    if (isArray(x)) return new Point(x[0], x[1]);
                    if (x === void 0 || x === null) return x;
                    if (typeof x === "object" && "x" in x && "y" in x) return new Point(x.x, x.y);
                    return new Point(x, y, round);
                }
                function Bounds(a, b) {
                    if (!a) return;
                    var points = b ? [ a, b ] : a;
                    for (var i = 0, len = points.length; i < len; i++) this.extend(points[i]);
                }
                Bounds.prototype = {
                    extend: function(obj) {
                        var min2, max2;
                        if (!obj) return this;
                        if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) min2 = max2 = toPoint(obj); else {
                            obj = toBounds(obj);
                            min2 = obj.min;
                            max2 = obj.max;
                            if (!min2 || !max2) return this;
                        }
                        if (!this.min && !this.max) {
                            this.min = min2.clone();
                            this.max = max2.clone();
                        } else {
                            this.min.x = Math.min(min2.x, this.min.x);
                            this.max.x = Math.max(max2.x, this.max.x);
                            this.min.y = Math.min(min2.y, this.min.y);
                            this.max.y = Math.max(max2.y, this.max.y);
                        }
                        return this;
                    },
                    getCenter: function(round) {
                        return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
                    },
                    getBottomLeft: function() {
                        return toPoint(this.min.x, this.max.y);
                    },
                    getTopRight: function() {
                        return toPoint(this.max.x, this.min.y);
                    },
                    getTopLeft: function() {
                        return this.min;
                    },
                    getBottomRight: function() {
                        return this.max;
                    },
                    getSize: function() {
                        return this.max.subtract(this.min);
                    },
                    contains: function(obj) {
                        var min, max;
                        if (typeof obj[0] === "number" || obj instanceof Point) obj = toPoint(obj); else obj = toBounds(obj);
                        if (obj instanceof Bounds) {
                            min = obj.min;
                            max = obj.max;
                        } else min = max = obj;
                        return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
                    },
                    intersects: function(bounds) {
                        bounds = toBounds(bounds);
                        var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
                        return xIntersects && yIntersects;
                    },
                    overlaps: function(bounds) {
                        bounds = toBounds(bounds);
                        var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
                        return xOverlaps && yOverlaps;
                    },
                    isValid: function() {
                        return !!(this.min && this.max);
                    },
                    pad: function(bufferRatio) {
                        var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
                        return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));
                    },
                    equals: function(bounds) {
                        if (!bounds) return false;
                        bounds = toBounds(bounds);
                        return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
                    }
                };
                function toBounds(a, b) {
                    if (!a || a instanceof Bounds) return a;
                    return new Bounds(a, b);
                }
                function LatLngBounds(corner1, corner2) {
                    if (!corner1) return;
                    var latlngs = corner2 ? [ corner1, corner2 ] : corner1;
                    for (var i = 0, len = latlngs.length; i < len; i++) this.extend(latlngs[i]);
                }
                LatLngBounds.prototype = {
                    extend: function(obj) {
                        var sw2, ne2, sw = this._southWest, ne = this._northEast;
                        if (obj instanceof LatLng) {
                            sw2 = obj;
                            ne2 = obj;
                        } else if (obj instanceof LatLngBounds) {
                            sw2 = obj._southWest;
                            ne2 = obj._northEast;
                            if (!sw2 || !ne2) return this;
                        } else return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
                        if (!sw && !ne) {
                            this._southWest = new LatLng(sw2.lat, sw2.lng);
                            this._northEast = new LatLng(ne2.lat, ne2.lng);
                        } else {
                            sw.lat = Math.min(sw2.lat, sw.lat);
                            sw.lng = Math.min(sw2.lng, sw.lng);
                            ne.lat = Math.max(ne2.lat, ne.lat);
                            ne.lng = Math.max(ne2.lng, ne.lng);
                        }
                        return this;
                    },
                    pad: function(bufferRatio) {
                        var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
                        return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
                    },
                    getCenter: function() {
                        return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
                    },
                    getSouthWest: function() {
                        return this._southWest;
                    },
                    getNorthEast: function() {
                        return this._northEast;
                    },
                    getNorthWest: function() {
                        return new LatLng(this.getNorth(), this.getWest());
                    },
                    getSouthEast: function() {
                        return new LatLng(this.getSouth(), this.getEast());
                    },
                    getWest: function() {
                        return this._southWest.lng;
                    },
                    getSouth: function() {
                        return this._southWest.lat;
                    },
                    getEast: function() {
                        return this._northEast.lng;
                    },
                    getNorth: function() {
                        return this._northEast.lat;
                    },
                    contains: function(obj) {
                        if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) obj = toLatLng(obj); else obj = toLatLngBounds(obj);
                        var sw2, ne2, sw = this._southWest, ne = this._northEast;
                        if (obj instanceof LatLngBounds) {
                            sw2 = obj.getSouthWest();
                            ne2 = obj.getNorthEast();
                        } else sw2 = ne2 = obj;
                        return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
                    },
                    intersects: function(bounds) {
                        bounds = toLatLngBounds(bounds);
                        var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
                        return latIntersects && lngIntersects;
                    },
                    overlaps: function(bounds) {
                        bounds = toLatLngBounds(bounds);
                        var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
                        return latOverlaps && lngOverlaps;
                    },
                    toBBoxString: function() {
                        return [ this.getWest(), this.getSouth(), this.getEast(), this.getNorth() ].join(",");
                    },
                    equals: function(bounds, maxMargin) {
                        if (!bounds) return false;
                        bounds = toLatLngBounds(bounds);
                        return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
                    },
                    isValid: function() {
                        return !!(this._southWest && this._northEast);
                    }
                };
                function toLatLngBounds(a, b) {
                    if (a instanceof LatLngBounds) return a;
                    return new LatLngBounds(a, b);
                }
                function LatLng(lat, lng, alt) {
                    if (isNaN(lat) || isNaN(lng)) throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
                    this.lat = +lat;
                    this.lng = +lng;
                    if (alt !== void 0) this.alt = +alt;
                }
                LatLng.prototype = {
                    equals: function(obj, maxMargin) {
                        if (!obj) return false;
                        obj = toLatLng(obj);
                        var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
                        return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
                    },
                    toString: function(precision) {
                        return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
                    },
                    distanceTo: function(other) {
                        return Earth.distance(this, toLatLng(other));
                    },
                    wrap: function() {
                        return Earth.wrapLatLng(this);
                    },
                    toBounds: function(sizeInMeters) {
                        var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
                        return toLatLngBounds([ this.lat - latAccuracy, this.lng - lngAccuracy ], [ this.lat + latAccuracy, this.lng + lngAccuracy ]);
                    },
                    clone: function() {
                        return new LatLng(this.lat, this.lng, this.alt);
                    }
                };
                function toLatLng(a, b, c) {
                    if (a instanceof LatLng) return a;
                    if (isArray(a) && typeof a[0] !== "object") {
                        if (a.length === 3) return new LatLng(a[0], a[1], a[2]);
                        if (a.length === 2) return new LatLng(a[0], a[1]);
                        return null;
                    }
                    if (a === void 0 || a === null) return a;
                    if (typeof a === "object" && "lat" in a) return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
                    if (b === void 0) return null;
                    return new LatLng(a, b, c);
                }
                var CRS = {
                    latLngToPoint: function(latlng, zoom) {
                        var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);
                        return this.transformation._transform(projectedPoint, scale);
                    },
                    pointToLatLng: function(point, zoom) {
                        var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);
                        return this.projection.unproject(untransformedPoint);
                    },
                    project: function(latlng) {
                        return this.projection.project(latlng);
                    },
                    unproject: function(point) {
                        return this.projection.unproject(point);
                    },
                    scale: function(zoom) {
                        return 256 * Math.pow(2, zoom);
                    },
                    zoom: function(scale) {
                        return Math.log(scale / 256) / Math.LN2;
                    },
                    getProjectedBounds: function(zoom) {
                        if (this.infinite) return null;
                        var b = this.projection.bounds, s = this.scale(zoom), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
                        return new Bounds(min, max);
                    },
                    infinite: false,
                    wrapLatLng: function(latlng) {
                        var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
                        return new LatLng(lat, lng, alt);
                    },
                    wrapLatLngBounds: function(bounds) {
                        var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
                        if (latShift === 0 && lngShift === 0) return bounds;
                        var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
                        return new LatLngBounds(newSw, newNe);
                    }
                };
                var Earth = extend({}, CRS, {
                    wrapLng: [ -180, 180 ],
                    R: 6371e3,
                    distance: function(latlng1, latlng2) {
                        var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                        return this.R * c;
                    }
                });
                var earthRadius = 6378137;
                var SphericalMercator = {
                    R: earthRadius,
                    MAX_LATITUDE: 85.0511287798,
                    project: function(latlng) {
                        var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
                        return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
                    },
                    unproject: function(point) {
                        var d = 180 / Math.PI;
                        return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
                    },
                    bounds: function() {
                        var d = earthRadius * Math.PI;
                        return new Bounds([ -d, -d ], [ d, d ]);
                    }()
                };
                function Transformation(a, b, c, d) {
                    if (isArray(a)) {
                        this._a = a[0];
                        this._b = a[1];
                        this._c = a[2];
                        this._d = a[3];
                        return;
                    }
                    this._a = a;
                    this._b = b;
                    this._c = c;
                    this._d = d;
                }
                Transformation.prototype = {
                    transform: function(point, scale) {
                        return this._transform(point.clone(), scale);
                    },
                    _transform: function(point, scale) {
                        scale = scale || 1;
                        point.x = scale * (this._a * point.x + this._b);
                        point.y = scale * (this._c * point.y + this._d);
                        return point;
                    },
                    untransform: function(point, scale) {
                        scale = scale || 1;
                        return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
                    }
                };
                function toTransformation(a, b, c, d) {
                    return new Transformation(a, b, c, d);
                }
                var EPSG3857 = extend({}, Earth, {
                    code: "EPSG:3857",
                    projection: SphericalMercator,
                    transformation: function() {
                        var scale = .5 / (Math.PI * SphericalMercator.R);
                        return toTransformation(scale, .5, -scale, .5);
                    }()
                });
                var EPSG900913 = extend({}, EPSG3857, {
                    code: "EPSG:900913"
                });
                function svgCreate(name) {
                    return document.createElementNS("http://www.w3.org/2000/svg", name);
                }
                function pointsToPath(rings, closed) {
                    var i, j, len, len2, points, p, str = "";
                    for (i = 0, len = rings.length; i < len; i++) {
                        points = rings[i];
                        for (j = 0, len2 = points.length; j < len2; j++) {
                            p = points[j];
                            str += (j ? "L" : "M") + p.x + " " + p.y;
                        }
                        str += closed ? Browser.svg ? "z" : "x" : "";
                    }
                    return str || "M0 0";
                }
                var style = document.documentElement.style;
                var ie = "ActiveXObject" in window;
                var ielt9 = ie && !document.addEventListener;
                var edge = "msLaunchUri" in navigator && !("documentMode" in document);
                var webkit = userAgentContains("webkit");
                var android = userAgentContains("android");
                var android23 = userAgentContains("android 2") || userAgentContains("android 3");
                var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
                var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
                var opera = !!window.opera;
                var chrome = !edge && userAgentContains("chrome");
                var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
                var safari = !chrome && userAgentContains("safari");
                var phantom = userAgentContains("phantom");
                var opera12 = "OTransition" in style;
                var win = navigator.platform.indexOf("Win") === 0;
                var ie3d = ie && "transition" in style;
                var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !android23;
                var gecko3d = "MozPerspective" in style;
                var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
                var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
                var mobileWebkit = mobile && webkit;
                var mobileWebkit3d = mobile && webkit3d;
                var msPointer = !window.PointerEvent && window.MSPointerEvent;
                var pointer = !!(window.PointerEvent || msPointer);
                var touchNative = "ontouchstart" in window || !!window.TouchEvent;
                var touch = !window.L_NO_TOUCH && (touchNative || pointer);
                var mobileOpera = mobile && opera;
                var mobileGecko = mobile && gecko;
                var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
                var passiveEvents = function() {
                    var supportsPassiveOption = false;
                    try {
                        var opts = Object.defineProperty({}, "passive", {
                            get: function() {
                                supportsPassiveOption = true;
                            }
                        });
                        window.addEventListener("testPassiveEventSupport", falseFn, opts);
                        window.removeEventListener("testPassiveEventSupport", falseFn, opts);
                    } catch (e) {}
                    return supportsPassiveOption;
                }();
                var canvas$1 = function() {
                    return !!document.createElement("canvas").getContext;
                }();
                var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
                var inlineSvg = !!svg$1 && function() {
                    var div = document.createElement("div");
                    div.innerHTML = "<svg/>";
                    return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
                }();
                var vml = !svg$1 && function() {
                    try {
                        var div = document.createElement("div");
                        div.innerHTML = '<v:shape adj="1"/>';
                        var shape = div.firstChild;
                        shape.style.behavior = "url(#default#VML)";
                        return shape && typeof shape.adj === "object";
                    } catch (e) {
                        return false;
                    }
                }();
                var mac = navigator.platform.indexOf("Mac") === 0;
                var linux = navigator.platform.indexOf("Linux") === 0;
                function userAgentContains(str) {
                    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
                }
                var Browser = {
                    ie,
                    ielt9,
                    edge,
                    webkit,
                    android,
                    android23,
                    androidStock,
                    opera,
                    chrome,
                    gecko,
                    safari,
                    phantom,
                    opera12,
                    win,
                    ie3d,
                    webkit3d,
                    gecko3d,
                    any3d,
                    mobile,
                    mobileWebkit,
                    mobileWebkit3d,
                    msPointer,
                    pointer,
                    touch,
                    touchNative,
                    mobileOpera,
                    mobileGecko,
                    retina,
                    passiveEvents,
                    canvas: canvas$1,
                    svg: svg$1,
                    vml,
                    inlineSvg,
                    mac,
                    linux
                };
                var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
                var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
                var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
                var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
                var pEvent = {
                    touchstart: POINTER_DOWN,
                    touchmove: POINTER_MOVE,
                    touchend: POINTER_UP,
                    touchcancel: POINTER_CANCEL
                };
                var handle = {
                    touchstart: _onPointerStart,
                    touchmove: _handlePointer,
                    touchend: _handlePointer,
                    touchcancel: _handlePointer
                };
                var _pointers = {};
                var _pointerDocListener = false;
                function addPointerListener(obj, type, handler) {
                    if (type === "touchstart") _addPointerDocListener();
                    if (!handle[type]) {
                        console.warn("wrong event specified:", type);
                        return falseFn;
                    }
                    handler = handle[type].bind(this, handler);
                    obj.addEventListener(pEvent[type], handler, false);
                    return handler;
                }
                function removePointerListener(obj, type, handler) {
                    if (!pEvent[type]) {
                        console.warn("wrong event specified:", type);
                        return;
                    }
                    obj.removeEventListener(pEvent[type], handler, false);
                }
                function _globalPointerDown(e) {
                    _pointers[e.pointerId] = e;
                }
                function _globalPointerMove(e) {
                    if (_pointers[e.pointerId]) _pointers[e.pointerId] = e;
                }
                function _globalPointerUp(e) {
                    delete _pointers[e.pointerId];
                }
                function _addPointerDocListener() {
                    if (!_pointerDocListener) {
                        document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
                        document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
                        document.addEventListener(POINTER_UP, _globalPointerUp, true);
                        document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
                        _pointerDocListener = true;
                    }
                }
                function _handlePointer(handler, e) {
                    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) return;
                    e.touches = [];
                    for (var i in _pointers) e.touches.push(_pointers[i]);
                    e.changedTouches = [ e ];
                    handler(e);
                }
                function _onPointerStart(handler, e) {
                    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) preventDefault(e);
                    _handlePointer(handler, e);
                }
                function makeDblclick(event) {
                    var prop, i, newEvent = {};
                    for (i in event) {
                        prop = event[i];
                        newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
                    }
                    event = newEvent;
                    newEvent.type = "dblclick";
                    newEvent.detail = 2;
                    newEvent.isTrusted = false;
                    newEvent._simulated = true;
                    return newEvent;
                }
                var delay = 200;
                function addDoubleTapListener(obj, handler) {
                    obj.addEventListener("dblclick", handler);
                    var detail, last = 0;
                    function simDblclick(e) {
                        if (e.detail !== 1) {
                            detail = e.detail;
                            return;
                        }
                        if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) return;
                        var path = getPropagationPath(e);
                        if (path.some((function(el) {
                            return el instanceof HTMLLabelElement && el.attributes.for;
                        })) && !path.some((function(el) {
                            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
                        }))) return;
                        var now = Date.now();
                        if (now - last <= delay) {
                            detail++;
                            if (detail === 2) handler(makeDblclick(e));
                        } else detail = 1;
                        last = now;
                    }
                    obj.addEventListener("click", simDblclick);
                    return {
                        dblclick: handler,
                        simDblclick
                    };
                }
                function removeDoubleTapListener(obj, handlers) {
                    obj.removeEventListener("dblclick", handlers.dblclick);
                    obj.removeEventListener("click", handlers.simDblclick);
                }
                var TRANSFORM = testProp([ "transform", "webkitTransform", "OTransform", "MozTransform", "msTransform" ]);
                var TRANSITION = testProp([ "webkitTransition", "transition", "OTransition", "MozTransition", "msTransition" ]);
                var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
                function get(id) {
                    return typeof id === "string" ? document.getElementById(id) : id;
                }
                function getStyle(el, style) {
                    var value = el.style[style] || el.currentStyle && el.currentStyle[style];
                    if ((!value || value === "auto") && document.defaultView) {
                        var css = document.defaultView.getComputedStyle(el, null);
                        value = css ? css[style] : null;
                    }
                    return value === "auto" ? null : value;
                }
                function create$1(tagName, className, container) {
                    var el = document.createElement(tagName);
                    el.className = className || "";
                    if (container) container.appendChild(el);
                    return el;
                }
                function remove(el) {
                    var parent = el.parentNode;
                    if (parent) parent.removeChild(el);
                }
                function empty(el) {
                    while (el.firstChild) el.removeChild(el.firstChild);
                }
                function toFront(el) {
                    var parent = el.parentNode;
                    if (parent && parent.lastChild !== el) parent.appendChild(el);
                }
                function toBack(el) {
                    var parent = el.parentNode;
                    if (parent && parent.firstChild !== el) parent.insertBefore(el, parent.firstChild);
                }
                function hasClass(el, name) {
                    if (el.classList !== void 0) return el.classList.contains(name);
                    var className = getClass(el);
                    return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
                }
                function addClass(el, name) {
                    if (el.classList !== void 0) {
                        var classes = splitWords(name);
                        for (var i = 0, len = classes.length; i < len; i++) el.classList.add(classes[i]);
                    } else if (!hasClass(el, name)) {
                        var className = getClass(el);
                        setClass(el, (className ? className + " " : "") + name);
                    }
                }
                function removeClass(el, name) {
                    if (el.classList !== void 0) el.classList.remove(name); else setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
                }
                function setClass(el, name) {
                    if (el.className.baseVal === void 0) el.className = name; else el.className.baseVal = name;
                }
                function getClass(el) {
                    if (el.correspondingElement) el = el.correspondingElement;
                    return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
                }
                function setOpacity(el, value) {
                    if ("opacity" in el.style) el.style.opacity = value; else if ("filter" in el.style) _setOpacityIE(el, value);
                }
                function _setOpacityIE(el, value) {
                    var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
                    try {
                        filter = el.filters.item(filterName);
                    } catch (e) {
                        if (value === 1) return;
                    }
                    value = Math.round(value * 100);
                    if (filter) {
                        filter.Enabled = value !== 100;
                        filter.Opacity = value;
                    } else el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
                }
                function testProp(props) {
                    var style = document.documentElement.style;
                    for (var i = 0; i < props.length; i++) if (props[i] in style) return props[i];
                    return false;
                }
                function setTransform(el, offset, scale) {
                    var pos = offset || new Point(0, 0);
                    el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");
                }
                function setPosition(el, point) {
                    el._leaflet_pos = point;
                    if (Browser.any3d) setTransform(el, point); else {
                        el.style.left = point.x + "px";
                        el.style.top = point.y + "px";
                    }
                }
                function getPosition(el) {
                    return el._leaflet_pos || new Point(0, 0);
                }
                var disableTextSelection;
                var enableTextSelection;
                var _userSelect;
                if ("onselectstart" in document) {
                    disableTextSelection = function() {
                        on(window, "selectstart", preventDefault);
                    };
                    enableTextSelection = function() {
                        off(window, "selectstart", preventDefault);
                    };
                } else {
                    var userSelectProperty = testProp([ "userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect" ]);
                    disableTextSelection = function() {
                        if (userSelectProperty) {
                            var style = document.documentElement.style;
                            _userSelect = style[userSelectProperty];
                            style[userSelectProperty] = "none";
                        }
                    };
                    enableTextSelection = function() {
                        if (userSelectProperty) {
                            document.documentElement.style[userSelectProperty] = _userSelect;
                            _userSelect = void 0;
                        }
                    };
                }
                function disableImageDrag() {
                    on(window, "dragstart", preventDefault);
                }
                function enableImageDrag() {
                    off(window, "dragstart", preventDefault);
                }
                var _outlineElement, _outlineStyle;
                function preventOutline(element) {
                    while (element.tabIndex === -1) element = element.parentNode;
                    if (!element.style) return;
                    restoreOutline();
                    _outlineElement = element;
                    _outlineStyle = element.style.outlineStyle;
                    element.style.outlineStyle = "none";
                    on(window, "keydown", restoreOutline);
                }
                function restoreOutline() {
                    if (!_outlineElement) return;
                    _outlineElement.style.outlineStyle = _outlineStyle;
                    _outlineElement = void 0;
                    _outlineStyle = void 0;
                    off(window, "keydown", restoreOutline);
                }
                function getSizedParentNode(element) {
                    do {
                        element = element.parentNode;
                    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
                    return element;
                }
                function getScale(element) {
                    var rect = element.getBoundingClientRect();
                    return {
                        x: rect.width / element.offsetWidth || 1,
                        y: rect.height / element.offsetHeight || 1,
                        boundingClientRect: rect
                    };
                }
                var DomUtil = {
                    __proto__: null,
                    TRANSFORM,
                    TRANSITION,
                    TRANSITION_END,
                    get,
                    getStyle,
                    create: create$1,
                    remove,
                    empty,
                    toFront,
                    toBack,
                    hasClass,
                    addClass,
                    removeClass,
                    setClass,
                    getClass,
                    setOpacity,
                    testProp,
                    setTransform,
                    setPosition,
                    getPosition,
                    get disableTextSelection() {
                        return disableTextSelection;
                    },
                    get enableTextSelection() {
                        return enableTextSelection;
                    },
                    disableImageDrag,
                    enableImageDrag,
                    preventOutline,
                    restoreOutline,
                    getSizedParentNode,
                    getScale
                };
                function on(obj, types, fn, context) {
                    if (types && typeof types === "object") for (var type in types) addOne(obj, type, types[type], fn); else {
                        types = splitWords(types);
                        for (var i = 0, len = types.length; i < len; i++) addOne(obj, types[i], fn, context);
                    }
                    return this;
                }
                var eventsKey = "_leaflet_events";
                function off(obj, types, fn, context) {
                    if (arguments.length === 1) {
                        batchRemove(obj);
                        delete obj[eventsKey];
                    } else if (types && typeof types === "object") for (var type in types) removeOne(obj, type, types[type], fn); else {
                        types = splitWords(types);
                        if (arguments.length === 2) batchRemove(obj, (function(type) {
                            return indexOf(types, type) !== -1;
                        })); else for (var i = 0, len = types.length; i < len; i++) removeOne(obj, types[i], fn, context);
                    }
                    return this;
                }
                function batchRemove(obj, filterFn) {
                    for (var id in obj[eventsKey]) {
                        var type = id.split(/\d/)[0];
                        if (!filterFn || filterFn(type)) removeOne(obj, type, null, null, id);
                    }
                }
                var mouseSubst = {
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    wheel: !("onwheel" in window) && "mousewheel"
                };
                function addOne(obj, type, fn, context) {
                    var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
                    if (obj[eventsKey] && obj[eventsKey][id]) return this;
                    var handler = function(e) {
                        return fn.call(context || obj, e || window.event);
                    };
                    var originalHandler = handler;
                    if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) handler = addPointerListener(obj, type, handler); else if (Browser.touch && type === "dblclick") handler = addDoubleTapListener(obj, handler); else if ("addEventListener" in obj) if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {
                        passive: false
                    } : false); else if (type === "mouseenter" || type === "mouseleave") {
                        handler = function(e) {
                            e = e || window.event;
                            if (isExternalTarget(obj, e)) originalHandler(e);
                        };
                        obj.addEventListener(mouseSubst[type], handler, false);
                    } else obj.addEventListener(type, originalHandler, false); else obj.attachEvent("on" + type, handler);
                    obj[eventsKey] = obj[eventsKey] || {};
                    obj[eventsKey][id] = handler;
                }
                function removeOne(obj, type, fn, context, id) {
                    id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
                    var handler = obj[eventsKey] && obj[eventsKey][id];
                    if (!handler) return this;
                    if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) removePointerListener(obj, type, handler); else if (Browser.touch && type === "dblclick") removeDoubleTapListener(obj, handler); else if ("removeEventListener" in obj) obj.removeEventListener(mouseSubst[type] || type, handler, false); else obj.detachEvent("on" + type, handler);
                    obj[eventsKey][id] = null;
                }
                function stopPropagation(e) {
                    if (e.stopPropagation) e.stopPropagation(); else if (e.originalEvent) e.originalEvent._stopped = true; else e.cancelBubble = true;
                    return this;
                }
                function disableScrollPropagation(el) {
                    addOne(el, "wheel", stopPropagation);
                    return this;
                }
                function disableClickPropagation(el) {
                    on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
                    el["_leaflet_disable_click"] = true;
                    return this;
                }
                function preventDefault(e) {
                    if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
                    return this;
                }
                function stop(e) {
                    preventDefault(e);
                    stopPropagation(e);
                    return this;
                }
                function getPropagationPath(ev) {
                    if (ev.composedPath) return ev.composedPath();
                    var path = [];
                    var el = ev.target;
                    while (el) {
                        path.push(el);
                        el = el.parentNode;
                    }
                    return path;
                }
                function getMousePosition(e, container) {
                    if (!container) return new Point(e.clientX, e.clientY);
                    var scale = getScale(container), offset = scale.boundingClientRect;
                    return new Point((e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
                }
                var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
                function getWheelDelta(e) {
                    return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
                }
                function isExternalTarget(el, e) {
                    var related = e.relatedTarget;
                    if (!related) return true;
                    try {
                        while (related && related !== el) related = related.parentNode;
                    } catch (err) {
                        return false;
                    }
                    return related !== el;
                }
                var DomEvent = {
                    __proto__: null,
                    on,
                    off,
                    stopPropagation,
                    disableScrollPropagation,
                    disableClickPropagation,
                    preventDefault,
                    stop,
                    getPropagationPath,
                    getMousePosition,
                    getWheelDelta,
                    isExternalTarget,
                    addListener: on,
                    removeListener: off
                };
                var PosAnimation = Evented.extend({
                    run: function(el, newPos, duration, easeLinearity) {
                        this.stop();
                        this._el = el;
                        this._inProgress = true;
                        this._duration = duration || .25;
                        this._easeOutPower = 1 / Math.max(easeLinearity || .5, .2);
                        this._startPos = getPosition(el);
                        this._offset = newPos.subtract(this._startPos);
                        this._startTime = +new Date;
                        this.fire("start");
                        this._animate();
                    },
                    stop: function() {
                        if (!this._inProgress) return;
                        this._step(true);
                        this._complete();
                    },
                    _animate: function() {
                        this._animId = requestAnimFrame(this._animate, this);
                        this._step();
                    },
                    _step: function(round) {
                        var elapsed = +new Date - this._startTime, duration = this._duration * 1e3;
                        if (elapsed < duration) this._runFrame(this._easeOut(elapsed / duration), round); else {
                            this._runFrame(1);
                            this._complete();
                        }
                    },
                    _runFrame: function(progress, round) {
                        var pos = this._startPos.add(this._offset.multiplyBy(progress));
                        if (round) pos._round();
                        setPosition(this._el, pos);
                        this.fire("step");
                    },
                    _complete: function() {
                        cancelAnimFrame(this._animId);
                        this._inProgress = false;
                        this.fire("end");
                    },
                    _easeOut: function(t) {
                        return 1 - Math.pow(1 - t, this._easeOutPower);
                    }
                });
                var Map = Evented.extend({
                    options: {
                        crs: EPSG3857,
                        center: void 0,
                        zoom: void 0,
                        minZoom: void 0,
                        maxZoom: void 0,
                        layers: [],
                        maxBounds: void 0,
                        renderer: void 0,
                        zoomAnimation: true,
                        zoomAnimationThreshold: 4,
                        fadeAnimation: true,
                        markerZoomAnimation: true,
                        transform3DLimit: 8388608,
                        zoomSnap: 1,
                        zoomDelta: 1,
                        trackResize: true
                    },
                    initialize: function(id, options) {
                        options = setOptions(this, options);
                        this._handlers = [];
                        this._layers = {};
                        this._zoomBoundLayers = {};
                        this._sizeChanged = true;
                        this._initContainer(id);
                        this._initLayout();
                        this._onResize = bind(this._onResize, this);
                        this._initEvents();
                        if (options.maxBounds) this.setMaxBounds(options.maxBounds);
                        if (options.zoom !== void 0) this._zoom = this._limitZoom(options.zoom);
                        if (options.center && options.zoom !== void 0) this.setView(toLatLng(options.center), options.zoom, {
                            reset: true
                        });
                        this.callInitHooks();
                        this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
                        if (this._zoomAnimated) {
                            this._createAnimProxy();
                            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
                        }
                        this._addLayers(this.options.layers);
                    },
                    setView: function(center, zoom, options) {
                        zoom = zoom === void 0 ? this._zoom : this._limitZoom(zoom);
                        center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
                        options = options || {};
                        this._stop();
                        if (this._loaded && !options.reset && options !== true) {
                            if (options.animate !== void 0) {
                                options.zoom = extend({
                                    animate: options.animate
                                }, options.zoom);
                                options.pan = extend({
                                    animate: options.animate,
                                    duration: options.duration
                                }, options.pan);
                            }
                            var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
                            if (moved) {
                                clearTimeout(this._sizeTimer);
                                return this;
                            }
                        }
                        this._resetView(center, zoom, options.pan && options.pan.noMoveStart);
                        return this;
                    },
                    setZoom: function(zoom, options) {
                        if (!this._loaded) {
                            this._zoom = zoom;
                            return this;
                        }
                        return this.setView(this.getCenter(), zoom, {
                            zoom: options
                        });
                    },
                    zoomIn: function(delta, options) {
                        delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
                        return this.setZoom(this._zoom + delta, options);
                    },
                    zoomOut: function(delta, options) {
                        delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
                        return this.setZoom(this._zoom - delta, options);
                    },
                    setZoomAround: function(latlng, zoom, options) {
                        var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
                        return this.setView(newCenter, zoom, {
                            zoom: options
                        });
                    },
                    _getBoundsCenterZoom: function(bounds, options) {
                        options = options || {};
                        bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
                        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [ 0, 0 ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [ 0, 0 ]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
                        zoom = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom) : zoom;
                        if (zoom === 1 / 0) return {
                            center: bounds.getCenter(),
                            zoom
                        };
                        var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
                        return {
                            center,
                            zoom
                        };
                    },
                    fitBounds: function(bounds, options) {
                        bounds = toLatLngBounds(bounds);
                        if (!bounds.isValid()) throw new Error("Bounds are not valid.");
                        var target = this._getBoundsCenterZoom(bounds, options);
                        return this.setView(target.center, target.zoom, options);
                    },
                    fitWorld: function(options) {
                        return this.fitBounds([ [ -90, -180 ], [ 90, 180 ] ], options);
                    },
                    panTo: function(center, options) {
                        return this.setView(center, this._zoom, {
                            pan: options
                        });
                    },
                    panBy: function(offset, options) {
                        offset = toPoint(offset).round();
                        options = options || {};
                        if (!offset.x && !offset.y) return this.fire("moveend");
                        if (options.animate !== true && !this.getSize().contains(offset)) {
                            this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
                            return this;
                        }
                        if (!this._panAnim) {
                            this._panAnim = new PosAnimation;
                            this._panAnim.on({
                                step: this._onPanTransitionStep,
                                end: this._onPanTransitionEnd
                            }, this);
                        }
                        if (!options.noMoveStart) this.fire("movestart");
                        if (options.animate !== false) {
                            addClass(this._mapPane, "leaflet-pan-anim");
                            var newPos = this._getMapPanePos().subtract(offset).round();
                            this._panAnim.run(this._mapPane, newPos, options.duration || .25, options.easeLinearity);
                        } else {
                            this._rawPanBy(offset);
                            this.fire("move").fire("moveend");
                        }
                        return this;
                    },
                    flyTo: function(targetCenter, targetZoom, options) {
                        options = options || {};
                        if (options.animate === false || !Browser.any3d) return this.setView(targetCenter, targetZoom, options);
                        this._stop();
                        var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
                        targetCenter = toLatLng(targetCenter);
                        targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
                        var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
                        function r(i) {
                            var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
                            var log = sq < 1e-9 ? -18 : Math.log(sq);
                            return log;
                        }
                        function sinh(n) {
                            return (Math.exp(n) - Math.exp(-n)) / 2;
                        }
                        function cosh(n) {
                            return (Math.exp(n) + Math.exp(-n)) / 2;
                        }
                        function tanh(n) {
                            return sinh(n) / cosh(n);
                        }
                        var r0 = r(0);
                        function w(s) {
                            return w0 * (cosh(r0) / cosh(r0 + rho * s));
                        }
                        function u(s) {
                            return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
                        }
                        function easeOut(t) {
                            return 1 - Math.pow(1 - t, 1.5);
                        }
                        var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * .8;
                        function frame() {
                            var t = (Date.now() - start) / duration, s = easeOut(t) * S;
                            if (t <= 1) {
                                this._flyToFrame = requestAnimFrame(frame, this);
                                this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
                                    flyTo: true
                                });
                            } else this._move(targetCenter, targetZoom)._moveEnd(true);
                        }
                        this._moveStart(true, options.noMoveStart);
                        frame.call(this);
                        return this;
                    },
                    flyToBounds: function(bounds, options) {
                        var target = this._getBoundsCenterZoom(bounds, options);
                        return this.flyTo(target.center, target.zoom, options);
                    },
                    setMaxBounds: function(bounds) {
                        bounds = toLatLngBounds(bounds);
                        if (this.listens("moveend", this._panInsideMaxBounds)) this.off("moveend", this._panInsideMaxBounds);
                        if (!bounds.isValid()) {
                            this.options.maxBounds = null;
                            return this;
                        }
                        this.options.maxBounds = bounds;
                        if (this._loaded) this._panInsideMaxBounds();
                        return this.on("moveend", this._panInsideMaxBounds);
                    },
                    setMinZoom: function(zoom) {
                        var oldZoom = this.options.minZoom;
                        this.options.minZoom = zoom;
                        if (this._loaded && oldZoom !== zoom) {
                            this.fire("zoomlevelschange");
                            if (this.getZoom() < this.options.minZoom) return this.setZoom(zoom);
                        }
                        return this;
                    },
                    setMaxZoom: function(zoom) {
                        var oldZoom = this.options.maxZoom;
                        this.options.maxZoom = zoom;
                        if (this._loaded && oldZoom !== zoom) {
                            this.fire("zoomlevelschange");
                            if (this.getZoom() > this.options.maxZoom) return this.setZoom(zoom);
                        }
                        return this;
                    },
                    panInsideBounds: function(bounds, options) {
                        this._enforcingBounds = true;
                        var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
                        if (!center.equals(newCenter)) this.panTo(newCenter, options);
                        this._enforcingBounds = false;
                        return this;
                    },
                    panInside: function(latlng, options) {
                        options = options || {};
                        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [ 0, 0 ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [ 0, 0 ]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([ pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR) ]), paddedSize = paddedBounds.getSize();
                        if (!paddedBounds.contains(pixelPoint)) {
                            this._enforcingBounds = true;
                            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
                            var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
                            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
                            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
                            this.panTo(this.unproject(pixelCenter), options);
                            this._enforcingBounds = false;
                        }
                        return this;
                    },
                    invalidateSize: function(options) {
                        if (!this._loaded) return this;
                        options = extend({
                            animate: false,
                            pan: true
                        }, options === true ? {
                            animate: true
                        } : options);
                        var oldSize = this.getSize();
                        this._sizeChanged = true;
                        this._lastCenter = null;
                        var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
                        if (!offset.x && !offset.y) return this;
                        if (options.animate && options.pan) this.panBy(offset); else {
                            if (options.pan) this._rawPanBy(offset);
                            this.fire("move");
                            if (options.debounceMoveend) {
                                clearTimeout(this._sizeTimer);
                                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
                            } else this.fire("moveend");
                        }
                        return this.fire("resize", {
                            oldSize,
                            newSize
                        });
                    },
                    stop: function() {
                        this.setZoom(this._limitZoom(this._zoom));
                        if (!this.options.zoomSnap) this.fire("viewreset");
                        return this._stop();
                    },
                    locate: function(options) {
                        options = this._locateOptions = extend({
                            timeout: 1e4,
                            watch: false
                        }, options);
                        if (!("geolocation" in navigator)) {
                            this._handleGeolocationError({
                                code: 0,
                                message: "Geolocation not supported."
                            });
                            return this;
                        }
                        var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
                        if (options.watch) this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options); else navigator.geolocation.getCurrentPosition(onResponse, onError, options);
                        return this;
                    },
                    stopLocate: function() {
                        if (navigator.geolocation && navigator.geolocation.clearWatch) navigator.geolocation.clearWatch(this._locationWatchId);
                        if (this._locateOptions) this._locateOptions.setView = false;
                        return this;
                    },
                    _handleGeolocationError: function(error) {
                        if (!this._container._leaflet_id) return;
                        var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
                        if (this._locateOptions.setView && !this._loaded) this.fitWorld();
                        this.fire("locationerror", {
                            code: c,
                            message: "Geolocation error: " + message + "."
                        });
                    },
                    _handleGeolocationResponse: function(pos) {
                        if (!this._container._leaflet_id) return;
                        var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
                        if (options.setView) {
                            var zoom = this.getBoundsZoom(bounds);
                            this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
                        }
                        var data = {
                            latlng,
                            bounds,
                            timestamp: pos.timestamp
                        };
                        for (var i in pos.coords) if (typeof pos.coords[i] === "number") data[i] = pos.coords[i];
                        this.fire("locationfound", data);
                    },
                    addHandler: function(name, HandlerClass) {
                        if (!HandlerClass) return this;
                        var handler = this[name] = new HandlerClass(this);
                        this._handlers.push(handler);
                        if (this.options[name]) handler.enable();
                        return this;
                    },
                    remove: function() {
                        this._initEvents(true);
                        if (this.options.maxBounds) this.off("moveend", this._panInsideMaxBounds);
                        if (this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance");
                        try {
                            delete this._container._leaflet_id;
                            delete this._containerId;
                        } catch (e) {
                            this._container._leaflet_id = void 0;
                            this._containerId = void 0;
                        }
                        if (this._locationWatchId !== void 0) this.stopLocate();
                        this._stop();
                        remove(this._mapPane);
                        if (this._clearControlPos) this._clearControlPos();
                        if (this._resizeRequest) {
                            cancelAnimFrame(this._resizeRequest);
                            this._resizeRequest = null;
                        }
                        this._clearHandlers();
                        if (this._loaded) this.fire("unload");
                        var i;
                        for (i in this._layers) this._layers[i].remove();
                        for (i in this._panes) remove(this._panes[i]);
                        this._layers = [];
                        this._panes = [];
                        delete this._mapPane;
                        delete this._renderer;
                        return this;
                    },
                    createPane: function(name, container) {
                        var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
                        if (name) this._panes[name] = pane;
                        return pane;
                    },
                    getCenter: function() {
                        this._checkIfLoaded();
                        if (this._lastCenter && !this._moved()) return this._lastCenter.clone();
                        return this.layerPointToLatLng(this._getCenterLayerPoint());
                    },
                    getZoom: function() {
                        return this._zoom;
                    },
                    getBounds: function() {
                        var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
                        return new LatLngBounds(sw, ne);
                    },
                    getMinZoom: function() {
                        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
                    },
                    getMaxZoom: function() {
                        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
                    },
                    getBoundsZoom: function(bounds, inside, padding) {
                        bounds = toLatLngBounds(bounds);
                        padding = toPoint(padding || [ 0, 0 ]);
                        var zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
                        zoom = this.getScaleZoom(scale, zoom);
                        if (snap) {
                            zoom = Math.round(zoom / (snap / 100)) * (snap / 100);
                            zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
                        }
                        return Math.max(min, Math.min(max, zoom));
                    },
                    getSize: function() {
                        if (!this._size || this._sizeChanged) {
                            this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
                            this._sizeChanged = false;
                        }
                        return this._size.clone();
                    },
                    getPixelBounds: function(center, zoom) {
                        var topLeftPoint = this._getTopLeftPoint(center, zoom);
                        return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
                    },
                    getPixelOrigin: function() {
                        this._checkIfLoaded();
                        return this._pixelOrigin;
                    },
                    getPixelWorldBounds: function(zoom) {
                        return this.options.crs.getProjectedBounds(zoom === void 0 ? this.getZoom() : zoom);
                    },
                    getPane: function(pane) {
                        return typeof pane === "string" ? this._panes[pane] : pane;
                    },
                    getPanes: function() {
                        return this._panes;
                    },
                    getContainer: function() {
                        return this._container;
                    },
                    getZoomScale: function(toZoom, fromZoom) {
                        var crs = this.options.crs;
                        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
                        return crs.scale(toZoom) / crs.scale(fromZoom);
                    },
                    getScaleZoom: function(scale, fromZoom) {
                        var crs = this.options.crs;
                        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
                        var zoom = crs.zoom(scale * crs.scale(fromZoom));
                        return isNaN(zoom) ? 1 / 0 : zoom;
                    },
                    project: function(latlng, zoom) {
                        zoom = zoom === void 0 ? this._zoom : zoom;
                        return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
                    },
                    unproject: function(point, zoom) {
                        zoom = zoom === void 0 ? this._zoom : zoom;
                        return this.options.crs.pointToLatLng(toPoint(point), zoom);
                    },
                    layerPointToLatLng: function(point) {
                        var projectedPoint = toPoint(point).add(this.getPixelOrigin());
                        return this.unproject(projectedPoint);
                    },
                    latLngToLayerPoint: function(latlng) {
                        var projectedPoint = this.project(toLatLng(latlng))._round();
                        return projectedPoint._subtract(this.getPixelOrigin());
                    },
                    wrapLatLng: function(latlng) {
                        return this.options.crs.wrapLatLng(toLatLng(latlng));
                    },
                    wrapLatLngBounds: function(latlng) {
                        return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
                    },
                    distance: function(latlng1, latlng2) {
                        return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
                    },
                    containerPointToLayerPoint: function(point) {
                        return toPoint(point).subtract(this._getMapPanePos());
                    },
                    layerPointToContainerPoint: function(point) {
                        return toPoint(point).add(this._getMapPanePos());
                    },
                    containerPointToLatLng: function(point) {
                        var layerPoint = this.containerPointToLayerPoint(toPoint(point));
                        return this.layerPointToLatLng(layerPoint);
                    },
                    latLngToContainerPoint: function(latlng) {
                        return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
                    },
                    mouseEventToContainerPoint: function(e) {
                        return getMousePosition(e, this._container);
                    },
                    mouseEventToLayerPoint: function(e) {
                        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
                    },
                    mouseEventToLatLng: function(e) {
                        return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
                    },
                    _initContainer: function(id) {
                        var container = this._container = get(id);
                        if (!container) throw new Error("Map container not found."); else if (container._leaflet_id) throw new Error("Map container is already initialized.");
                        on(container, "scroll", this._onScroll, this);
                        this._containerId = stamp(container);
                    },
                    _initLayout: function() {
                        var container = this._container;
                        this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
                        addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
                        var position = getStyle(container, "position");
                        if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") container.style.position = "relative";
                        this._initPanes();
                        if (this._initControlPos) this._initControlPos();
                    },
                    _initPanes: function() {
                        var panes = this._panes = {};
                        this._paneRenderers = {};
                        this._mapPane = this.createPane("mapPane", this._container);
                        setPosition(this._mapPane, new Point(0, 0));
                        this.createPane("tilePane");
                        this.createPane("overlayPane");
                        this.createPane("shadowPane");
                        this.createPane("markerPane");
                        this.createPane("tooltipPane");
                        this.createPane("popupPane");
                        if (!this.options.markerZoomAnimation) {
                            addClass(panes.markerPane, "leaflet-zoom-hide");
                            addClass(panes.shadowPane, "leaflet-zoom-hide");
                        }
                    },
                    _resetView: function(center, zoom, noMoveStart) {
                        setPosition(this._mapPane, new Point(0, 0));
                        var loading = !this._loaded;
                        this._loaded = true;
                        zoom = this._limitZoom(zoom);
                        this.fire("viewprereset");
                        var zoomChanged = this._zoom !== zoom;
                        this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);
                        this.fire("viewreset");
                        if (loading) this.fire("load");
                    },
                    _moveStart: function(zoomChanged, noMoveStart) {
                        if (zoomChanged) this.fire("zoomstart");
                        if (!noMoveStart) this.fire("movestart");
                        return this;
                    },
                    _move: function(center, zoom, data, supressEvent) {
                        if (zoom === void 0) zoom = this._zoom;
                        var zoomChanged = this._zoom !== zoom;
                        this._zoom = zoom;
                        this._lastCenter = center;
                        this._pixelOrigin = this._getNewPixelOrigin(center);
                        if (!supressEvent) {
                            if (zoomChanged || data && data.pinch) this.fire("zoom", data);
                            this.fire("move", data);
                        } else if (data && data.pinch) this.fire("zoom", data);
                        return this;
                    },
                    _moveEnd: function(zoomChanged) {
                        if (zoomChanged) this.fire("zoomend");
                        return this.fire("moveend");
                    },
                    _stop: function() {
                        cancelAnimFrame(this._flyToFrame);
                        if (this._panAnim) this._panAnim.stop();
                        return this;
                    },
                    _rawPanBy: function(offset) {
                        setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
                    },
                    _getZoomSpan: function() {
                        return this.getMaxZoom() - this.getMinZoom();
                    },
                    _panInsideMaxBounds: function() {
                        if (!this._enforcingBounds) this.panInsideBounds(this.options.maxBounds);
                    },
                    _checkIfLoaded: function() {
                        if (!this._loaded) throw new Error("Set map center and zoom first.");
                    },
                    _initEvents: function(remove) {
                        this._targets = {};
                        this._targets[stamp(this._container)] = this;
                        var onOff = remove ? off : on;
                        onOff(this._container, "click dblclick mousedown mouseup " + "mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
                        if (this.options.trackResize) onOff(window, "resize", this._onResize, this);
                        if (Browser.any3d && this.options.transform3DLimit) (remove ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
                    },
                    _onResize: function() {
                        cancelAnimFrame(this._resizeRequest);
                        this._resizeRequest = requestAnimFrame((function() {
                            this.invalidateSize({
                                debounceMoveend: true
                            });
                        }), this);
                    },
                    _onScroll: function() {
                        this._container.scrollTop = 0;
                        this._container.scrollLeft = 0;
                    },
                    _onMoveEnd: function() {
                        var pos = this._getMapPanePos();
                        if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) this._resetView(this.getCenter(), this.getZoom());
                    },
                    _findEventTargets: function(e, type) {
                        var target, targets = [], isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
                        while (src) {
                            target = this._targets[stamp(src)];
                            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                                dragging = true;
                                break;
                            }
                            if (target && target.listens(type, true)) {
                                if (isHover && !isExternalTarget(src, e)) break;
                                targets.push(target);
                                if (isHover) break;
                            }
                            if (src === this._container) break;
                            src = src.parentNode;
                        }
                        if (!targets.length && !dragging && !isHover && this.listens(type, true)) targets = [ this ];
                        return targets;
                    },
                    _isClickDisabled: function(el) {
                        while (el && el !== this._container) {
                            if (el["_leaflet_disable_click"]) return true;
                            el = el.parentNode;
                        }
                    },
                    _handleDOMEvent: function(e) {
                        var el = e.target || e.srcElement;
                        if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) return;
                        var type = e.type;
                        if (type === "mousedown") preventOutline(el);
                        this._fireDOMEvent(e, type);
                    },
                    _mouseEvents: [ "click", "dblclick", "mouseover", "mouseout", "contextmenu" ],
                    _fireDOMEvent: function(e, type, canvasTargets) {
                        if (e.type === "click") {
                            var synth = extend({}, e);
                            synth.type = "preclick";
                            this._fireDOMEvent(synth, synth.type, canvasTargets);
                        }
                        var targets = this._findEventTargets(e, type);
                        if (canvasTargets) {
                            var filtered = [];
                            for (var i = 0; i < canvasTargets.length; i++) if (canvasTargets[i].listens(type, true)) filtered.push(canvasTargets[i]);
                            targets = filtered.concat(targets);
                        }
                        if (!targets.length) return;
                        if (type === "contextmenu") preventDefault(e);
                        var target = targets[0];
                        var data = {
                            originalEvent: e
                        };
                        if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
                            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
                            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
                            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
                            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
                        }
                        for (i = 0; i < targets.length; i++) {
                            targets[i].fire(type, data, true);
                            if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) return;
                        }
                    },
                    _draggableMoved: function(obj) {
                        obj = obj.dragging && obj.dragging.enabled() ? obj : this;
                        return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
                    },
                    _clearHandlers: function() {
                        for (var i = 0, len = this._handlers.length; i < len; i++) this._handlers[i].disable();
                    },
                    whenReady: function(callback, context) {
                        if (this._loaded) callback.call(context || this, {
                            target: this
                        }); else this.on("load", callback, context);
                        return this;
                    },
                    _getMapPanePos: function() {
                        return getPosition(this._mapPane) || new Point(0, 0);
                    },
                    _moved: function() {
                        var pos = this._getMapPanePos();
                        return pos && !pos.equals([ 0, 0 ]);
                    },
                    _getTopLeftPoint: function(center, zoom) {
                        var pixelOrigin = center && zoom !== void 0 ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
                        return pixelOrigin.subtract(this._getMapPanePos());
                    },
                    _getNewPixelOrigin: function(center, zoom) {
                        var viewHalf = this.getSize()._divideBy(2);
                        return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
                    },
                    _latLngToNewLayerPoint: function(latlng, zoom, center) {
                        var topLeft = this._getNewPixelOrigin(center, zoom);
                        return this.project(latlng, zoom)._subtract(topLeft);
                    },
                    _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom, center) {
                        var topLeft = this._getNewPixelOrigin(center, zoom);
                        return toBounds([ this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft) ]);
                    },
                    _getCenterLayerPoint: function() {
                        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
                    },
                    _getCenterOffset: function(latlng) {
                        return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
                    },
                    _limitCenter: function(center, zoom, bounds) {
                        if (!bounds) return center;
                        var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);
                        if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) return center;
                        return this.unproject(centerPoint.add(offset), zoom);
                    },
                    _limitOffset: function(offset, bounds) {
                        if (!bounds) return offset;
                        var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
                        return offset.add(this._getBoundsOffset(newBounds, bounds));
                    },
                    _getBoundsOffset: function(pxBounds, maxBounds, zoom) {
                        var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
                        return new Point(dx, dy);
                    },
                    _rebound: function(left, right) {
                        return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
                    },
                    _limitZoom: function(zoom) {
                        var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
                        if (snap) zoom = Math.round(zoom / snap) * snap;
                        return Math.max(min, Math.min(max, zoom));
                    },
                    _onPanTransitionStep: function() {
                        this.fire("move");
                    },
                    _onPanTransitionEnd: function() {
                        removeClass(this._mapPane, "leaflet-pan-anim");
                        this.fire("moveend");
                    },
                    _tryAnimatedPan: function(center, options) {
                        var offset = this._getCenterOffset(center)._trunc();
                        if ((options && options.animate) !== true && !this.getSize().contains(offset)) return false;
                        this.panBy(offset, options);
                        return true;
                    },
                    _createAnimProxy: function() {
                        var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
                        this._panes.mapPane.appendChild(proxy);
                        this.on("zoomanim", (function(e) {
                            var prop = TRANSFORM, transform = this._proxy.style[prop];
                            setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
                            if (transform === this._proxy.style[prop] && this._animatingZoom) this._onZoomTransitionEnd();
                        }), this);
                        this.on("load moveend", this._animMoveEnd, this);
                        this._on("unload", this._destroyAnimProxy, this);
                    },
                    _destroyAnimProxy: function() {
                        remove(this._proxy);
                        this.off("load moveend", this._animMoveEnd, this);
                        delete this._proxy;
                    },
                    _animMoveEnd: function() {
                        var c = this.getCenter(), z = this.getZoom();
                        setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
                    },
                    _catchTransitionEnd: function(e) {
                        if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) this._onZoomTransitionEnd();
                    },
                    _nothingToAnimate: function() {
                        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
                    },
                    _tryAnimatedZoom: function(center, zoom, options) {
                        if (this._animatingZoom) return true;
                        options = options || {};
                        if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) return false;
                        var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);
                        if (options.animate !== true && !this.getSize().contains(offset)) return false;
                        requestAnimFrame((function() {
                            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);
                        }), this);
                        return true;
                    },
                    _animateZoom: function(center, zoom, startAnim, noUpdate) {
                        if (!this._mapPane) return;
                        if (startAnim) {
                            this._animatingZoom = true;
                            this._animateToCenter = center;
                            this._animateToZoom = zoom;
                            addClass(this._mapPane, "leaflet-zoom-anim");
                        }
                        this.fire("zoomanim", {
                            center,
                            zoom,
                            noUpdate
                        });
                        if (!this._tempFireZoomEvent) this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
                        this._move(this._animateToCenter, this._animateToZoom, void 0, true);
                        setTimeout(bind(this._onZoomTransitionEnd, this), 250);
                    },
                    _onZoomTransitionEnd: function() {
                        if (!this._animatingZoom) return;
                        if (this._mapPane) removeClass(this._mapPane, "leaflet-zoom-anim");
                        this._animatingZoom = false;
                        this._move(this._animateToCenter, this._animateToZoom, void 0, true);
                        if (this._tempFireZoomEvent) this.fire("zoom");
                        delete this._tempFireZoomEvent;
                        this.fire("move");
                        this._moveEnd(true);
                    }
                });
                function createMap(id, options) {
                    return new Map(id, options);
                }
                var Control = Class.extend({
                    options: {
                        position: "topright"
                    },
                    initialize: function(options) {
                        setOptions(this, options);
                    },
                    getPosition: function() {
                        return this.options.position;
                    },
                    setPosition: function(position) {
                        var map = this._map;
                        if (map) map.removeControl(this);
                        this.options.position = position;
                        if (map) map.addControl(this);
                        return this;
                    },
                    getContainer: function() {
                        return this._container;
                    },
                    addTo: function(map) {
                        this.remove();
                        this._map = map;
                        var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
                        addClass(container, "leaflet-control");
                        if (pos.indexOf("bottom") !== -1) corner.insertBefore(container, corner.firstChild); else corner.appendChild(container);
                        this._map.on("unload", this.remove, this);
                        return this;
                    },
                    remove: function() {
                        if (!this._map) return this;
                        remove(this._container);
                        if (this.onRemove) this.onRemove(this._map);
                        this._map.off("unload", this.remove, this);
                        this._map = null;
                        return this;
                    },
                    _refocusOnMap: function(e) {
                        if (this._map && e && e.screenX > 0 && e.screenY > 0) this._map.getContainer().focus();
                    }
                });
                var control = function(options) {
                    return new Control(options);
                };
                Map.include({
                    addControl: function(control) {
                        control.addTo(this);
                        return this;
                    },
                    removeControl: function(control) {
                        control.remove();
                        return this;
                    },
                    _initControlPos: function() {
                        var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
                        function createCorner(vSide, hSide) {
                            var className = l + vSide + " " + l + hSide;
                            corners[vSide + hSide] = create$1("div", className, container);
                        }
                        createCorner("top", "left");
                        createCorner("top", "right");
                        createCorner("bottom", "left");
                        createCorner("bottom", "right");
                    },
                    _clearControlPos: function() {
                        for (var i in this._controlCorners) remove(this._controlCorners[i]);
                        remove(this._controlContainer);
                        delete this._controlCorners;
                        delete this._controlContainer;
                    }
                });
                var Layers = Control.extend({
                    options: {
                        collapsed: true,
                        position: "topright",
                        autoZIndex: true,
                        hideSingleBase: false,
                        sortLayers: false,
                        sortFunction: function(layerA, layerB, nameA, nameB) {
                            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
                        }
                    },
                    initialize: function(baseLayers, overlays, options) {
                        setOptions(this, options);
                        this._layerControlInputs = [];
                        this._layers = [];
                        this._lastZIndex = 0;
                        this._handlingClick = false;
                        this._preventClick = false;
                        for (var i in baseLayers) this._addLayer(baseLayers[i], i);
                        for (i in overlays) this._addLayer(overlays[i], i, true);
                    },
                    onAdd: function(map) {
                        this._initLayout();
                        this._update();
                        this._map = map;
                        map.on("zoomend", this._checkDisabledLayers, this);
                        for (var i = 0; i < this._layers.length; i++) this._layers[i].layer.on("add remove", this._onLayerChange, this);
                        return this._container;
                    },
                    addTo: function(map) {
                        Control.prototype.addTo.call(this, map);
                        return this._expandIfNotCollapsed();
                    },
                    onRemove: function() {
                        this._map.off("zoomend", this._checkDisabledLayers, this);
                        for (var i = 0; i < this._layers.length; i++) this._layers[i].layer.off("add remove", this._onLayerChange, this);
                    },
                    addBaseLayer: function(layer, name) {
                        this._addLayer(layer, name);
                        return this._map ? this._update() : this;
                    },
                    addOverlay: function(layer, name) {
                        this._addLayer(layer, name, true);
                        return this._map ? this._update() : this;
                    },
                    removeLayer: function(layer) {
                        layer.off("add remove", this._onLayerChange, this);
                        var obj = this._getLayer(stamp(layer));
                        if (obj) this._layers.splice(this._layers.indexOf(obj), 1);
                        return this._map ? this._update() : this;
                    },
                    expand: function() {
                        addClass(this._container, "leaflet-control-layers-expanded");
                        this._section.style.height = null;
                        var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
                        if (acceptableHeight < this._section.clientHeight) {
                            addClass(this._section, "leaflet-control-layers-scrollbar");
                            this._section.style.height = acceptableHeight + "px";
                        } else removeClass(this._section, "leaflet-control-layers-scrollbar");
                        this._checkDisabledLayers();
                        return this;
                    },
                    collapse: function() {
                        removeClass(this._container, "leaflet-control-layers-expanded");
                        return this;
                    },
                    _initLayout: function() {
                        var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
                        container.setAttribute("aria-haspopup", true);
                        disableClickPropagation(container);
                        disableScrollPropagation(container);
                        var section = this._section = create$1("section", className + "-list");
                        if (collapsed) {
                            this._map.on("click", this.collapse, this);
                            on(container, {
                                mouseenter: this._expandSafely,
                                mouseleave: this.collapse
                            }, this);
                        }
                        var link = this._layersLink = create$1("a", className + "-toggle", container);
                        link.href = "#";
                        link.title = "Layers";
                        link.setAttribute("role", "button");
                        on(link, {
                            keydown: function(e) {
                                if (e.keyCode === 13) this._expandSafely();
                            },
                            click: function(e) {
                                preventDefault(e);
                                this._expandSafely();
                            }
                        }, this);
                        if (!collapsed) this.expand();
                        this._baseLayersList = create$1("div", className + "-base", section);
                        this._separator = create$1("div", className + "-separator", section);
                        this._overlaysList = create$1("div", className + "-overlays", section);
                        container.appendChild(section);
                    },
                    _getLayer: function(id) {
                        for (var i = 0; i < this._layers.length; i++) if (this._layers[i] && stamp(this._layers[i].layer) === id) return this._layers[i];
                    },
                    _addLayer: function(layer, name, overlay) {
                        if (this._map) layer.on("add remove", this._onLayerChange, this);
                        this._layers.push({
                            layer,
                            name,
                            overlay
                        });
                        if (this.options.sortLayers) this._layers.sort(bind((function(a, b) {
                            return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
                        }), this));
                        if (this.options.autoZIndex && layer.setZIndex) {
                            this._lastZIndex++;
                            layer.setZIndex(this._lastZIndex);
                        }
                        this._expandIfNotCollapsed();
                    },
                    _update: function() {
                        if (!this._container) return this;
                        empty(this._baseLayersList);
                        empty(this._overlaysList);
                        this._layerControlInputs = [];
                        var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
                        for (i = 0; i < this._layers.length; i++) {
                            obj = this._layers[i];
                            this._addItem(obj);
                            overlaysPresent = overlaysPresent || obj.overlay;
                            baseLayersPresent = baseLayersPresent || !obj.overlay;
                            baseLayersCount += !obj.overlay ? 1 : 0;
                        }
                        if (this.options.hideSingleBase) {
                            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
                            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
                        }
                        this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
                        return this;
                    },
                    _onLayerChange: function(e) {
                        if (!this._handlingClick) this._update();
                        var obj = this._getLayer(stamp(e.target));
                        var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
                        if (type) this._map.fire(type, obj);
                    },
                    _createRadioElement: function(name, checked) {
                        var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
                        var radioFragment = document.createElement("div");
                        radioFragment.innerHTML = radioHtml;
                        return radioFragment.firstChild;
                    },
                    _addItem: function(obj) {
                        var input, label = document.createElement("label"), checked = this._map.hasLayer(obj.layer);
                        if (obj.overlay) {
                            input = document.createElement("input");
                            input.type = "checkbox";
                            input.className = "leaflet-control-layers-selector";
                            input.defaultChecked = checked;
                        } else input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
                        this._layerControlInputs.push(input);
                        input.layerId = stamp(obj.layer);
                        on(input, "click", this._onInputClick, this);
                        var name = document.createElement("span");
                        name.innerHTML = " " + obj.name;
                        var holder = document.createElement("span");
                        label.appendChild(holder);
                        holder.appendChild(input);
                        holder.appendChild(name);
                        var container = obj.overlay ? this._overlaysList : this._baseLayersList;
                        container.appendChild(label);
                        this._checkDisabledLayers();
                        return label;
                    },
                    _onInputClick: function() {
                        if (this._preventClick) return;
                        var input, layer, inputs = this._layerControlInputs;
                        var addedLayers = [], removedLayers = [];
                        this._handlingClick = true;
                        for (var i = inputs.length - 1; i >= 0; i--) {
                            input = inputs[i];
                            layer = this._getLayer(input.layerId).layer;
                            if (input.checked) addedLayers.push(layer); else if (!input.checked) removedLayers.push(layer);
                        }
                        for (i = 0; i < removedLayers.length; i++) if (this._map.hasLayer(removedLayers[i])) this._map.removeLayer(removedLayers[i]);
                        for (i = 0; i < addedLayers.length; i++) if (!this._map.hasLayer(addedLayers[i])) this._map.addLayer(addedLayers[i]);
                        this._handlingClick = false;
                        this._refocusOnMap();
                    },
                    _checkDisabledLayers: function() {
                        var input, layer, inputs = this._layerControlInputs, zoom = this._map.getZoom();
                        for (var i = inputs.length - 1; i >= 0; i--) {
                            input = inputs[i];
                            layer = this._getLayer(input.layerId).layer;
                            input.disabled = layer.options.minZoom !== void 0 && zoom < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom > layer.options.maxZoom;
                        }
                    },
                    _expandIfNotCollapsed: function() {
                        if (this._map && !this.options.collapsed) this.expand();
                        return this;
                    },
                    _expandSafely: function() {
                        var section = this._section;
                        this._preventClick = true;
                        on(section, "click", preventDefault);
                        this.expand();
                        var that = this;
                        setTimeout((function() {
                            off(section, "click", preventDefault);
                            that._preventClick = false;
                        }));
                    }
                });
                var layers = function(baseLayers, overlays, options) {
                    return new Layers(baseLayers, overlays, options);
                };
                var Zoom = Control.extend({
                    options: {
                        position: "topleft",
                        zoomInText: '<span aria-hidden="true">+</span>',
                        zoomInTitle: "Zoom in",
                        zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
                        zoomOutTitle: "Zoom out"
                    },
                    onAdd: function(map) {
                        var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
                        this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + "-in", container, this._zoomIn);
                        this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + "-out", container, this._zoomOut);
                        this._updateDisabled();
                        map.on("zoomend zoomlevelschange", this._updateDisabled, this);
                        return container;
                    },
                    onRemove: function(map) {
                        map.off("zoomend zoomlevelschange", this._updateDisabled, this);
                    },
                    disable: function() {
                        this._disabled = true;
                        this._updateDisabled();
                        return this;
                    },
                    enable: function() {
                        this._disabled = false;
                        this._updateDisabled();
                        return this;
                    },
                    _zoomIn: function(e) {
                        if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
                    },
                    _zoomOut: function(e) {
                        if (!this._disabled && this._map._zoom > this._map.getMinZoom()) this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
                    },
                    _createButton: function(html, title, className, container, fn) {
                        var link = create$1("a", className, container);
                        link.innerHTML = html;
                        link.href = "#";
                        link.title = title;
                        link.setAttribute("role", "button");
                        link.setAttribute("aria-label", title);
                        disableClickPropagation(link);
                        on(link, "click", stop);
                        on(link, "click", fn, this);
                        on(link, "click", this._refocusOnMap, this);
                        return link;
                    },
                    _updateDisabled: function() {
                        var map = this._map, className = "leaflet-disabled";
                        removeClass(this._zoomInButton, className);
                        removeClass(this._zoomOutButton, className);
                        this._zoomInButton.setAttribute("aria-disabled", "false");
                        this._zoomOutButton.setAttribute("aria-disabled", "false");
                        if (this._disabled || map._zoom === map.getMinZoom()) {
                            addClass(this._zoomOutButton, className);
                            this._zoomOutButton.setAttribute("aria-disabled", "true");
                        }
                        if (this._disabled || map._zoom === map.getMaxZoom()) {
                            addClass(this._zoomInButton, className);
                            this._zoomInButton.setAttribute("aria-disabled", "true");
                        }
                    }
                });
                Map.mergeOptions({
                    zoomControl: true
                });
                Map.addInitHook((function() {
                    if (this.options.zoomControl) {
                        this.zoomControl = new Zoom;
                        this.addControl(this.zoomControl);
                    }
                }));
                var zoom = function(options) {
                    return new Zoom(options);
                };
                var Scale = Control.extend({
                    options: {
                        position: "bottomleft",
                        maxWidth: 100,
                        metric: true,
                        imperial: true
                    },
                    onAdd: function(map) {
                        var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
                        this._addScales(options, className + "-line", container);
                        map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
                        map.whenReady(this._update, this);
                        return container;
                    },
                    onRemove: function(map) {
                        map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
                    },
                    _addScales: function(options, className, container) {
                        if (options.metric) this._mScale = create$1("div", className, container);
                        if (options.imperial) this._iScale = create$1("div", className, container);
                    },
                    _update: function() {
                        var map = this._map, y = map.getSize().y / 2;
                        var maxMeters = map.distance(map.containerPointToLatLng([ 0, y ]), map.containerPointToLatLng([ this.options.maxWidth, y ]));
                        this._updateScales(maxMeters);
                    },
                    _updateScales: function(maxMeters) {
                        if (this.options.metric && maxMeters) this._updateMetric(maxMeters);
                        if (this.options.imperial && maxMeters) this._updateImperial(maxMeters);
                    },
                    _updateMetric: function(maxMeters) {
                        var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
                        this._updateScale(this._mScale, label, meters / maxMeters);
                    },
                    _updateImperial: function(maxMeters) {
                        var maxMiles, miles, feet, maxFeet = maxMeters * 3.2808399;
                        if (maxFeet > 5280) {
                            maxMiles = maxFeet / 5280;
                            miles = this._getRoundNum(maxMiles);
                            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
                        } else {
                            feet = this._getRoundNum(maxFeet);
                            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
                        }
                    },
                    _updateScale: function(scale, text, ratio) {
                        scale.style.width = Math.round(this.options.maxWidth * ratio) + "px";
                        scale.innerHTML = text;
                    },
                    _getRoundNum: function(num) {
                        var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
                        d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
                        return pow10 * d;
                    }
                });
                var scale = function(options) {
                    return new Scale(options);
                };
                var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
                var Attribution = Control.extend({
                    options: {
                        position: "bottomright",
                        prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
                    },
                    initialize: function(options) {
                        setOptions(this, options);
                        this._attributions = {};
                    },
                    onAdd: function(map) {
                        map.attributionControl = this;
                        this._container = create$1("div", "leaflet-control-attribution");
                        disableClickPropagation(this._container);
                        for (var i in map._layers) if (map._layers[i].getAttribution) this.addAttribution(map._layers[i].getAttribution());
                        this._update();
                        map.on("layeradd", this._addAttribution, this);
                        return this._container;
                    },
                    onRemove: function(map) {
                        map.off("layeradd", this._addAttribution, this);
                    },
                    _addAttribution: function(ev) {
                        if (ev.layer.getAttribution) {
                            this.addAttribution(ev.layer.getAttribution());
                            ev.layer.once("remove", (function() {
                                this.removeAttribution(ev.layer.getAttribution());
                            }), this);
                        }
                    },
                    setPrefix: function(prefix) {
                        this.options.prefix = prefix;
                        this._update();
                        return this;
                    },
                    addAttribution: function(text) {
                        if (!text) return this;
                        if (!this._attributions[text]) this._attributions[text] = 0;
                        this._attributions[text]++;
                        this._update();
                        return this;
                    },
                    removeAttribution: function(text) {
                        if (!text) return this;
                        if (this._attributions[text]) {
                            this._attributions[text]--;
                            this._update();
                        }
                        return this;
                    },
                    _update: function() {
                        if (!this._map) return;
                        var attribs = [];
                        for (var i in this._attributions) if (this._attributions[i]) attribs.push(i);
                        var prefixAndAttribs = [];
                        if (this.options.prefix) prefixAndAttribs.push(this.options.prefix);
                        if (attribs.length) prefixAndAttribs.push(attribs.join(", "));
                        this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
                    }
                });
                Map.mergeOptions({
                    attributionControl: true
                });
                Map.addInitHook((function() {
                    if (this.options.attributionControl) (new Attribution).addTo(this);
                }));
                var attribution = function(options) {
                    return new Attribution(options);
                };
                Control.Layers = Layers;
                Control.Zoom = Zoom;
                Control.Scale = Scale;
                Control.Attribution = Attribution;
                control.layers = layers;
                control.zoom = zoom;
                control.scale = scale;
                control.attribution = attribution;
                var Handler = Class.extend({
                    initialize: function(map) {
                        this._map = map;
                    },
                    enable: function() {
                        if (this._enabled) return this;
                        this._enabled = true;
                        this.addHooks();
                        return this;
                    },
                    disable: function() {
                        if (!this._enabled) return this;
                        this._enabled = false;
                        this.removeHooks();
                        return this;
                    },
                    enabled: function() {
                        return !!this._enabled;
                    }
                });
                Handler.addTo = function(map, name) {
                    map.addHandler(name, this);
                    return this;
                };
                var Mixin = {
                    Events
                };
                var START = Browser.touch ? "touchstart mousedown" : "mousedown";
                var Draggable = Evented.extend({
                    options: {
                        clickTolerance: 3
                    },
                    initialize: function(element, dragStartTarget, preventOutline, options) {
                        setOptions(this, options);
                        this._element = element;
                        this._dragStartTarget = dragStartTarget || element;
                        this._preventOutline = preventOutline;
                    },
                    enable: function() {
                        if (this._enabled) return;
                        on(this._dragStartTarget, START, this._onDown, this);
                        this._enabled = true;
                    },
                    disable: function() {
                        if (!this._enabled) return;
                        if (Draggable._dragging === this) this.finishDrag(true);
                        off(this._dragStartTarget, START, this._onDown, this);
                        this._enabled = false;
                        this._moved = false;
                    },
                    _onDown: function(e) {
                        if (!this._enabled) return;
                        this._moved = false;
                        if (hasClass(this._element, "leaflet-zoom-anim")) return;
                        if (e.touches && e.touches.length !== 1) {
                            if (Draggable._dragging === this) this.finishDrag();
                            return;
                        }
                        if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) return;
                        Draggable._dragging = this;
                        if (this._preventOutline) preventOutline(this._element);
                        disableImageDrag();
                        disableTextSelection();
                        if (this._moving) return;
                        this.fire("down");
                        var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
                        this._startPoint = new Point(first.clientX, first.clientY);
                        this._startPos = getPosition(this._element);
                        this._parentScale = getScale(sizedParent);
                        var mouseevent = e.type === "mousedown";
                        on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
                        on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
                    },
                    _onMove: function(e) {
                        if (!this._enabled) return;
                        if (e.touches && e.touches.length > 1) {
                            this._moved = true;
                            return;
                        }
                        var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
                        if (!offset.x && !offset.y) return;
                        if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) return;
                        offset.x /= this._parentScale.x;
                        offset.y /= this._parentScale.y;
                        preventDefault(e);
                        if (!this._moved) {
                            this.fire("dragstart");
                            this._moved = true;
                            addClass(document.body, "leaflet-dragging");
                            this._lastTarget = e.target || e.srcElement;
                            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) this._lastTarget = this._lastTarget.correspondingUseElement;
                            addClass(this._lastTarget, "leaflet-drag-target");
                        }
                        this._newPos = this._startPos.add(offset);
                        this._moving = true;
                        this._lastEvent = e;
                        this._updatePosition();
                    },
                    _updatePosition: function() {
                        var e = {
                            originalEvent: this._lastEvent
                        };
                        this.fire("predrag", e);
                        setPosition(this._element, this._newPos);
                        this.fire("drag", e);
                    },
                    _onUp: function() {
                        if (!this._enabled) return;
                        this.finishDrag();
                    },
                    finishDrag: function(noInertia) {
                        removeClass(document.body, "leaflet-dragging");
                        if (this._lastTarget) {
                            removeClass(this._lastTarget, "leaflet-drag-target");
                            this._lastTarget = null;
                        }
                        off(document, "mousemove touchmove", this._onMove, this);
                        off(document, "mouseup touchend touchcancel", this._onUp, this);
                        enableImageDrag();
                        enableTextSelection();
                        var fireDragend = this._moved && this._moving;
                        this._moving = false;
                        Draggable._dragging = false;
                        if (fireDragend) this.fire("dragend", {
                            noInertia,
                            distance: this._newPos.distanceTo(this._startPos)
                        });
                    }
                });
                function clipPolygon(points, bounds, round) {
                    var clippedPoints, i, j, k, a, b, len, edge, p, edges = [ 1, 4, 2, 8 ];
                    for (i = 0, len = points.length; i < len; i++) points[i]._code = _getBitCode(points[i], bounds);
                    for (k = 0; k < 4; k++) {
                        edge = edges[k];
                        clippedPoints = [];
                        for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                            a = points[i];
                            b = points[j];
                            if (!(a._code & edge)) {
                                if (b._code & edge) {
                                    p = _getEdgeIntersection(b, a, edge, bounds, round);
                                    p._code = _getBitCode(p, bounds);
                                    clippedPoints.push(p);
                                }
                                clippedPoints.push(a);
                            } else if (!(b._code & edge)) {
                                p = _getEdgeIntersection(b, a, edge, bounds, round);
                                p._code = _getBitCode(p, bounds);
                                clippedPoints.push(p);
                            }
                        }
                        points = clippedPoints;
                    }
                    return points;
                }
                function polygonCenter(latlngs, crs) {
                    var i, j, p1, p2, f, area, x, y, center;
                    if (!latlngs || latlngs.length === 0) throw new Error("latlngs not passed");
                    if (!isFlat(latlngs)) {
                        console.warn("latlngs are not flat! Only the first ring will be used");
                        latlngs = latlngs[0];
                    }
                    var centroidLatLng = toLatLng([ 0, 0 ]);
                    var bounds = toLatLngBounds(latlngs);
                    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
                    if (areaBounds < 1700) centroidLatLng = centroid(latlngs);
                    var len = latlngs.length;
                    var points = [];
                    for (i = 0; i < len; i++) {
                        var latlng = toLatLng(latlngs[i]);
                        points.push(crs.project(toLatLng([ latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng ])));
                    }
                    area = x = y = 0;
                    for (i = 0, j = len - 1; i < len; j = i++) {
                        p1 = points[i];
                        p2 = points[j];
                        f = p1.y * p2.x - p2.y * p1.x;
                        x += (p1.x + p2.x) * f;
                        y += (p1.y + p2.y) * f;
                        area += f * 3;
                    }
                    if (area === 0) center = points[0]; else center = [ x / area, y / area ];
                    var latlngCenter = crs.unproject(toPoint(center));
                    return toLatLng([ latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng ]);
                }
                function centroid(coords) {
                    var latSum = 0;
                    var lngSum = 0;
                    var len = 0;
                    for (var i = 0; i < coords.length; i++) {
                        var latlng = toLatLng(coords[i]);
                        latSum += latlng.lat;
                        lngSum += latlng.lng;
                        len++;
                    }
                    return toLatLng([ latSum / len, lngSum / len ]);
                }
                var PolyUtil = {
                    __proto__: null,
                    clipPolygon,
                    polygonCenter,
                    centroid
                };
                function simplify(points, tolerance) {
                    if (!tolerance || !points.length) return points.slice();
                    var sqTolerance = tolerance * tolerance;
                    points = _reducePoints(points, sqTolerance);
                    points = _simplifyDP(points, sqTolerance);
                    return points;
                }
                function pointToSegmentDistance(p, p1, p2) {
                    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
                }
                function closestPointOnSegment(p, p1, p2) {
                    return _sqClosestPointOnSegment(p, p1, p2);
                }
                function _simplifyDP(points, sqTolerance) {
                    var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
                    markers[0] = markers[len - 1] = 1;
                    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
                    var i, newPoints = [];
                    for (i = 0; i < len; i++) if (markers[i]) newPoints.push(points[i]);
                    return newPoints;
                }
                function _simplifyDPStep(points, markers, sqTolerance, first, last) {
                    var index, i, sqDist, maxSqDist = 0;
                    for (i = first + 1; i <= last - 1; i++) {
                        sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
                        if (sqDist > maxSqDist) {
                            index = i;
                            maxSqDist = sqDist;
                        }
                    }
                    if (maxSqDist > sqTolerance) {
                        markers[index] = 1;
                        _simplifyDPStep(points, markers, sqTolerance, first, index);
                        _simplifyDPStep(points, markers, sqTolerance, index, last);
                    }
                }
                function _reducePoints(points, sqTolerance) {
                    var reducedPoints = [ points[0] ];
                    for (var i = 1, prev = 0, len = points.length; i < len; i++) if (_sqDist(points[i], points[prev]) > sqTolerance) {
                        reducedPoints.push(points[i]);
                        prev = i;
                    }
                    if (prev < len - 1) reducedPoints.push(points[len - 1]);
                    return reducedPoints;
                }
                var _lastCode;
                function clipSegment(a, b, bounds, useLastCode, round) {
                    var codeOut, p, newCode, codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds);
                    _lastCode = codeB;
                    while (true) {
                        if (!(codeA | codeB)) return [ a, b ];
                        if (codeA & codeB) return false;
                        codeOut = codeA || codeB;
                        p = _getEdgeIntersection(a, b, codeOut, bounds, round);
                        newCode = _getBitCode(p, bounds);
                        if (codeOut === codeA) {
                            a = p;
                            codeA = newCode;
                        } else {
                            b = p;
                            codeB = newCode;
                        }
                    }
                }
                function _getEdgeIntersection(a, b, code, bounds, round) {
                    var x, y, dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max;
                    if (code & 8) {
                        x = a.x + dx * (max.y - a.y) / dy;
                        y = max.y;
                    } else if (code & 4) {
                        x = a.x + dx * (min.y - a.y) / dy;
                        y = min.y;
                    } else if (code & 2) {
                        x = max.x;
                        y = a.y + dy * (max.x - a.x) / dx;
                    } else if (code & 1) {
                        x = min.x;
                        y = a.y + dy * (min.x - a.x) / dx;
                    }
                    return new Point(x, y, round);
                }
                function _getBitCode(p, bounds) {
                    var code = 0;
                    if (p.x < bounds.min.x) code |= 1; else if (p.x > bounds.max.x) code |= 2;
                    if (p.y < bounds.min.y) code |= 4; else if (p.y > bounds.max.y) code |= 8;
                    return code;
                }
                function _sqDist(p1, p2) {
                    var dx = p2.x - p1.x, dy = p2.y - p1.y;
                    return dx * dx + dy * dy;
                }
                function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
                    var t, x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy;
                    if (dot > 0) {
                        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
                        if (t > 1) {
                            x = p2.x;
                            y = p2.y;
                        } else if (t > 0) {
                            x += dx * t;
                            y += dy * t;
                        }
                    }
                    dx = p.x - x;
                    dy = p.y - y;
                    return sqDist ? dx * dx + dy * dy : new Point(x, y);
                }
                function isFlat(latlngs) {
                    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
                }
                function _flat(latlngs) {
                    console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
                    return isFlat(latlngs);
                }
                function polylineCenter(latlngs, crs) {
                    var i, halfDist, segDist, dist, p1, p2, ratio, center;
                    if (!latlngs || latlngs.length === 0) throw new Error("latlngs not passed");
                    if (!isFlat(latlngs)) {
                        console.warn("latlngs are not flat! Only the first ring will be used");
                        latlngs = latlngs[0];
                    }
                    var centroidLatLng = toLatLng([ 0, 0 ]);
                    var bounds = toLatLngBounds(latlngs);
                    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
                    if (areaBounds < 1700) centroidLatLng = centroid(latlngs);
                    var len = latlngs.length;
                    var points = [];
                    for (i = 0; i < len; i++) {
                        var latlng = toLatLng(latlngs[i]);
                        points.push(crs.project(toLatLng([ latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng ])));
                    }
                    for (i = 0, halfDist = 0; i < len - 1; i++) halfDist += points[i].distanceTo(points[i + 1]) / 2;
                    if (halfDist === 0) center = points[0]; else for (i = 0, dist = 0; i < len - 1; i++) {
                        p1 = points[i];
                        p2 = points[i + 1];
                        segDist = p1.distanceTo(p2);
                        dist += segDist;
                        if (dist > halfDist) {
                            ratio = (dist - halfDist) / segDist;
                            center = [ p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y) ];
                            break;
                        }
                    }
                    var latlngCenter = crs.unproject(toPoint(center));
                    return toLatLng([ latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng ]);
                }
                var LineUtil = {
                    __proto__: null,
                    simplify,
                    pointToSegmentDistance,
                    closestPointOnSegment,
                    clipSegment,
                    _getEdgeIntersection,
                    _getBitCode,
                    _sqClosestPointOnSegment,
                    isFlat,
                    _flat,
                    polylineCenter
                };
                var LonLat = {
                    project: function(latlng) {
                        return new Point(latlng.lng, latlng.lat);
                    },
                    unproject: function(point) {
                        return new LatLng(point.y, point.x);
                    },
                    bounds: new Bounds([ -180, -90 ], [ 180, 90 ])
                };
                var Mercator = {
                    R: 6378137,
                    R_MINOR: 6356752.314245179,
                    bounds: new Bounds([ -20037508.34279, -15496570.73972 ], [ 20037508.34279, 18764656.23138 ]),
                    project: function(latlng) {
                        var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
                        var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
                        y = -r * Math.log(Math.max(ts, 1e-10));
                        return new Point(latlng.lng * d * r, y);
                    },
                    unproject: function(point) {
                        var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
                        for (var con, i = 0, dphi = .1; i < 15 && Math.abs(dphi) > 1e-7; i++) {
                            con = e * Math.sin(phi);
                            con = Math.pow((1 - con) / (1 + con), e / 2);
                            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                            phi += dphi;
                        }
                        return new LatLng(phi * d, point.x * d / r);
                    }
                };
                var index = {
                    __proto__: null,
                    LonLat,
                    Mercator,
                    SphericalMercator
                };
                var EPSG3395 = extend({}, Earth, {
                    code: "EPSG:3395",
                    projection: Mercator,
                    transformation: function() {
                        var scale = .5 / (Math.PI * Mercator.R);
                        return toTransformation(scale, .5, -scale, .5);
                    }()
                });
                var EPSG4326 = extend({}, Earth, {
                    code: "EPSG:4326",
                    projection: LonLat,
                    transformation: toTransformation(1 / 180, 1, -1 / 180, .5)
                });
                var Simple = extend({}, CRS, {
                    projection: LonLat,
                    transformation: toTransformation(1, 0, -1, 0),
                    scale: function(zoom) {
                        return Math.pow(2, zoom);
                    },
                    zoom: function(scale) {
                        return Math.log(scale) / Math.LN2;
                    },
                    distance: function(latlng1, latlng2) {
                        var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
                        return Math.sqrt(dx * dx + dy * dy);
                    },
                    infinite: true
                });
                CRS.Earth = Earth;
                CRS.EPSG3395 = EPSG3395;
                CRS.EPSG3857 = EPSG3857;
                CRS.EPSG900913 = EPSG900913;
                CRS.EPSG4326 = EPSG4326;
                CRS.Simple = Simple;
                var Layer = Evented.extend({
                    options: {
                        pane: "overlayPane",
                        attribution: null,
                        bubblingMouseEvents: true
                    },
                    addTo: function(map) {
                        map.addLayer(this);
                        return this;
                    },
                    remove: function() {
                        return this.removeFrom(this._map || this._mapToAdd);
                    },
                    removeFrom: function(obj) {
                        if (obj) obj.removeLayer(this);
                        return this;
                    },
                    getPane: function(name) {
                        return this._map.getPane(name ? this.options[name] || name : this.options.pane);
                    },
                    addInteractiveTarget: function(targetEl) {
                        this._map._targets[stamp(targetEl)] = this;
                        return this;
                    },
                    removeInteractiveTarget: function(targetEl) {
                        delete this._map._targets[stamp(targetEl)];
                        return this;
                    },
                    getAttribution: function() {
                        return this.options.attribution;
                    },
                    _layerAdd: function(e) {
                        var map = e.target;
                        if (!map.hasLayer(this)) return;
                        this._map = map;
                        this._zoomAnimated = map._zoomAnimated;
                        if (this.getEvents) {
                            var events = this.getEvents();
                            map.on(events, this);
                            this.once("remove", (function() {
                                map.off(events, this);
                            }), this);
                        }
                        this.onAdd(map);
                        this.fire("add");
                        map.fire("layeradd", {
                            layer: this
                        });
                    }
                });
                Map.include({
                    addLayer: function(layer) {
                        if (!layer._layerAdd) throw new Error("The provided object is not a Layer.");
                        var id = stamp(layer);
                        if (this._layers[id]) return this;
                        this._layers[id] = layer;
                        layer._mapToAdd = this;
                        if (layer.beforeAdd) layer.beforeAdd(this);
                        this.whenReady(layer._layerAdd, layer);
                        return this;
                    },
                    removeLayer: function(layer) {
                        var id = stamp(layer);
                        if (!this._layers[id]) return this;
                        if (this._loaded) layer.onRemove(this);
                        delete this._layers[id];
                        if (this._loaded) {
                            this.fire("layerremove", {
                                layer
                            });
                            layer.fire("remove");
                        }
                        layer._map = layer._mapToAdd = null;
                        return this;
                    },
                    hasLayer: function(layer) {
                        return stamp(layer) in this._layers;
                    },
                    eachLayer: function(method, context) {
                        for (var i in this._layers) method.call(context, this._layers[i]);
                        return this;
                    },
                    _addLayers: function(layers) {
                        layers = layers ? isArray(layers) ? layers : [ layers ] : [];
                        for (var i = 0, len = layers.length; i < len; i++) this.addLayer(layers[i]);
                    },
                    _addZoomLimit: function(layer) {
                        if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
                            this._zoomBoundLayers[stamp(layer)] = layer;
                            this._updateZoomLevels();
                        }
                    },
                    _removeZoomLimit: function(layer) {
                        var id = stamp(layer);
                        if (this._zoomBoundLayers[id]) {
                            delete this._zoomBoundLayers[id];
                            this._updateZoomLevels();
                        }
                    },
                    _updateZoomLevels: function() {
                        var minZoom = 1 / 0, maxZoom = -1 / 0, oldZoomSpan = this._getZoomSpan();
                        for (var i in this._zoomBoundLayers) {
                            var options = this._zoomBoundLayers[i].options;
                            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
                            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
                        }
                        this._layersMaxZoom = maxZoom === -1 / 0 ? void 0 : maxZoom;
                        this._layersMinZoom = minZoom === 1 / 0 ? void 0 : minZoom;
                        if (oldZoomSpan !== this._getZoomSpan()) this.fire("zoomlevelschange");
                        if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) this.setZoom(this._layersMaxZoom);
                        if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) this.setZoom(this._layersMinZoom);
                    }
                });
                var LayerGroup = Layer.extend({
                    initialize: function(layers, options) {
                        setOptions(this, options);
                        this._layers = {};
                        var i, len;
                        if (layers) for (i = 0, len = layers.length; i < len; i++) this.addLayer(layers[i]);
                    },
                    addLayer: function(layer) {
                        var id = this.getLayerId(layer);
                        this._layers[id] = layer;
                        if (this._map) this._map.addLayer(layer);
                        return this;
                    },
                    removeLayer: function(layer) {
                        var id = layer in this._layers ? layer : this.getLayerId(layer);
                        if (this._map && this._layers[id]) this._map.removeLayer(this._layers[id]);
                        delete this._layers[id];
                        return this;
                    },
                    hasLayer: function(layer) {
                        var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
                        return layerId in this._layers;
                    },
                    clearLayers: function() {
                        return this.eachLayer(this.removeLayer, this);
                    },
                    invoke: function(methodName) {
                        var i, layer, args = Array.prototype.slice.call(arguments, 1);
                        for (i in this._layers) {
                            layer = this._layers[i];
                            if (layer[methodName]) layer[methodName].apply(layer, args);
                        }
                        return this;
                    },
                    onAdd: function(map) {
                        this.eachLayer(map.addLayer, map);
                    },
                    onRemove: function(map) {
                        this.eachLayer(map.removeLayer, map);
                    },
                    eachLayer: function(method, context) {
                        for (var i in this._layers) method.call(context, this._layers[i]);
                        return this;
                    },
                    getLayer: function(id) {
                        return this._layers[id];
                    },
                    getLayers: function() {
                        var layers = [];
                        this.eachLayer(layers.push, layers);
                        return layers;
                    },
                    setZIndex: function(zIndex) {
                        return this.invoke("setZIndex", zIndex);
                    },
                    getLayerId: function(layer) {
                        return stamp(layer);
                    }
                });
                var layerGroup = function(layers, options) {
                    return new LayerGroup(layers, options);
                };
                var FeatureGroup = LayerGroup.extend({
                    addLayer: function(layer) {
                        if (this.hasLayer(layer)) return this;
                        layer.addEventParent(this);
                        LayerGroup.prototype.addLayer.call(this, layer);
                        return this.fire("layeradd", {
                            layer
                        });
                    },
                    removeLayer: function(layer) {
                        if (!this.hasLayer(layer)) return this;
                        if (layer in this._layers) layer = this._layers[layer];
                        layer.removeEventParent(this);
                        LayerGroup.prototype.removeLayer.call(this, layer);
                        return this.fire("layerremove", {
                            layer
                        });
                    },
                    setStyle: function(style) {
                        return this.invoke("setStyle", style);
                    },
                    bringToFront: function() {
                        return this.invoke("bringToFront");
                    },
                    bringToBack: function() {
                        return this.invoke("bringToBack");
                    },
                    getBounds: function() {
                        var bounds = new LatLngBounds;
                        for (var id in this._layers) {
                            var layer = this._layers[id];
                            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
                        }
                        return bounds;
                    }
                });
                var featureGroup = function(layers, options) {
                    return new FeatureGroup(layers, options);
                };
                var Icon = Class.extend({
                    options: {
                        popupAnchor: [ 0, 0 ],
                        tooltipAnchor: [ 0, 0 ],
                        crossOrigin: false
                    },
                    initialize: function(options) {
                        setOptions(this, options);
                    },
                    createIcon: function(oldIcon) {
                        return this._createIcon("icon", oldIcon);
                    },
                    createShadow: function(oldIcon) {
                        return this._createIcon("shadow", oldIcon);
                    },
                    _createIcon: function(name, oldIcon) {
                        var src = this._getIconUrl(name);
                        if (!src) {
                            if (name === "icon") throw new Error("iconUrl not set in Icon options (see the docs).");
                            return null;
                        }
                        var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
                        this._setIconStyles(img, name);
                        if (this.options.crossOrigin || this.options.crossOrigin === "") img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
                        return img;
                    },
                    _setIconStyles: function(img, name) {
                        var options = this.options;
                        var sizeOption = options[name + "Size"];
                        if (typeof sizeOption === "number") sizeOption = [ sizeOption, sizeOption ];
                        var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
                        img.className = "leaflet-marker-" + name + " " + (options.className || "");
                        if (anchor) {
                            img.style.marginLeft = -anchor.x + "px";
                            img.style.marginTop = -anchor.y + "px";
                        }
                        if (size) {
                            img.style.width = size.x + "px";
                            img.style.height = size.y + "px";
                        }
                    },
                    _createImg: function(src, el) {
                        el = el || document.createElement("img");
                        el.src = src;
                        return el;
                    },
                    _getIconUrl: function(name) {
                        return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
                    }
                });
                function icon(options) {
                    return new Icon(options);
                }
                var IconDefault = Icon.extend({
                    options: {
                        iconUrl: "marker-icon.png",
                        iconRetinaUrl: "marker-icon-2x.png",
                        shadowUrl: "marker-shadow.png",
                        iconSize: [ 25, 41 ],
                        iconAnchor: [ 12, 41 ],
                        popupAnchor: [ 1, -34 ],
                        tooltipAnchor: [ 16, -28 ],
                        shadowSize: [ 41, 41 ]
                    },
                    _getIconUrl: function(name) {
                        if (typeof IconDefault.imagePath !== "string") IconDefault.imagePath = this._detectIconPath();
                        return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
                    },
                    _stripUrl: function(path) {
                        var strip = function(str, re, idx) {
                            var match = re.exec(str);
                            return match && match[idx];
                        };
                        path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
                        return path && strip(path, /^(.*)marker-icon\.png$/, 1);
                    },
                    _detectIconPath: function() {
                        var el = create$1("div", "leaflet-default-icon-path", document.body);
                        var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
                        document.body.removeChild(el);
                        path = this._stripUrl(path);
                        if (path) return path;
                        var link = document.querySelector('link[href$="leaflet.css"]');
                        if (!link) return "";
                        return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
                    }
                });
                var MarkerDrag = Handler.extend({
                    initialize: function(marker) {
                        this._marker = marker;
                    },
                    addHooks: function() {
                        var icon = this._marker._icon;
                        if (!this._draggable) this._draggable = new Draggable(icon, icon, true);
                        this._draggable.on({
                            dragstart: this._onDragStart,
                            predrag: this._onPreDrag,
                            drag: this._onDrag,
                            dragend: this._onDragEnd
                        }, this).enable();
                        addClass(icon, "leaflet-marker-draggable");
                    },
                    removeHooks: function() {
                        this._draggable.off({
                            dragstart: this._onDragStart,
                            predrag: this._onPreDrag,
                            drag: this._onDrag,
                            dragend: this._onDragEnd
                        }, this).disable();
                        if (this._marker._icon) removeClass(this._marker._icon, "leaflet-marker-draggable");
                    },
                    moved: function() {
                        return this._draggable && this._draggable._moved;
                    },
                    _adjustPan: function(e) {
                        var marker = this._marker, map = marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
                        var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
                        if (!panBounds.contains(iconPos)) {
                            var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
                            map.panBy(movement, {
                                animate: false
                            });
                            this._draggable._newPos._add(movement);
                            this._draggable._startPos._add(movement);
                            setPosition(marker._icon, this._draggable._newPos);
                            this._onDrag(e);
                            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
                        }
                    },
                    _onDragStart: function() {
                        this._oldLatLng = this._marker.getLatLng();
                        this._marker.closePopup && this._marker.closePopup();
                        this._marker.fire("movestart").fire("dragstart");
                    },
                    _onPreDrag: function(e) {
                        if (this._marker.options.autoPan) {
                            cancelAnimFrame(this._panRequest);
                            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
                        }
                    },
                    _onDrag: function(e) {
                        var marker = this._marker, shadow = marker._shadow, iconPos = getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
                        if (shadow) setPosition(shadow, iconPos);
                        marker._latlng = latlng;
                        e.latlng = latlng;
                        e.oldLatLng = this._oldLatLng;
                        marker.fire("move", e).fire("drag", e);
                    },
                    _onDragEnd: function(e) {
                        cancelAnimFrame(this._panRequest);
                        delete this._oldLatLng;
                        this._marker.fire("moveend").fire("dragend", e);
                    }
                });
                var Marker = Layer.extend({
                    options: {
                        icon: new IconDefault,
                        interactive: true,
                        keyboard: true,
                        title: "",
                        alt: "Marker",
                        zIndexOffset: 0,
                        opacity: 1,
                        riseOnHover: false,
                        riseOffset: 250,
                        pane: "markerPane",
                        shadowPane: "shadowPane",
                        bubblingMouseEvents: false,
                        autoPanOnFocus: true,
                        draggable: false,
                        autoPan: false,
                        autoPanPadding: [ 50, 50 ],
                        autoPanSpeed: 10
                    },
                    initialize: function(latlng, options) {
                        setOptions(this, options);
                        this._latlng = toLatLng(latlng);
                    },
                    onAdd: function(map) {
                        this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
                        if (this._zoomAnimated) map.on("zoomanim", this._animateZoom, this);
                        this._initIcon();
                        this.update();
                    },
                    onRemove: function(map) {
                        if (this.dragging && this.dragging.enabled()) {
                            this.options.draggable = true;
                            this.dragging.removeHooks();
                        }
                        delete this.dragging;
                        if (this._zoomAnimated) map.off("zoomanim", this._animateZoom, this);
                        this._removeIcon();
                        this._removeShadow();
                    },
                    getEvents: function() {
                        return {
                            zoom: this.update,
                            viewreset: this.update
                        };
                    },
                    getLatLng: function() {
                        return this._latlng;
                    },
                    setLatLng: function(latlng) {
                        var oldLatLng = this._latlng;
                        this._latlng = toLatLng(latlng);
                        this.update();
                        return this.fire("move", {
                            oldLatLng,
                            latlng: this._latlng
                        });
                    },
                    setZIndexOffset: function(offset) {
                        this.options.zIndexOffset = offset;
                        return this.update();
                    },
                    getIcon: function() {
                        return this.options.icon;
                    },
                    setIcon: function(icon) {
                        this.options.icon = icon;
                        if (this._map) {
                            this._initIcon();
                            this.update();
                        }
                        if (this._popup) this.bindPopup(this._popup, this._popup.options);
                        return this;
                    },
                    getElement: function() {
                        return this._icon;
                    },
                    update: function() {
                        if (this._icon && this._map) {
                            var pos = this._map.latLngToLayerPoint(this._latlng).round();
                            this._setPos(pos);
                        }
                        return this;
                    },
                    _initIcon: function() {
                        var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
                        var icon = options.icon.createIcon(this._icon), addIcon = false;
                        if (icon !== this._icon) {
                            if (this._icon) this._removeIcon();
                            addIcon = true;
                            if (options.title) icon.title = options.title;
                            if (icon.tagName === "IMG") icon.alt = options.alt || "";
                        }
                        addClass(icon, classToAdd);
                        if (options.keyboard) {
                            icon.tabIndex = "0";
                            icon.setAttribute("role", "button");
                        }
                        this._icon = icon;
                        if (options.riseOnHover) this.on({
                            mouseover: this._bringToFront,
                            mouseout: this._resetZIndex
                        });
                        if (this.options.autoPanOnFocus) on(icon, "focus", this._panOnFocus, this);
                        var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
                        if (newShadow !== this._shadow) {
                            this._removeShadow();
                            addShadow = true;
                        }
                        if (newShadow) {
                            addClass(newShadow, classToAdd);
                            newShadow.alt = "";
                        }
                        this._shadow = newShadow;
                        if (options.opacity < 1) this._updateOpacity();
                        if (addIcon) this.getPane().appendChild(this._icon);
                        this._initInteraction();
                        if (newShadow && addShadow) this.getPane(options.shadowPane).appendChild(this._shadow);
                    },
                    _removeIcon: function() {
                        if (this.options.riseOnHover) this.off({
                            mouseover: this._bringToFront,
                            mouseout: this._resetZIndex
                        });
                        if (this.options.autoPanOnFocus) off(this._icon, "focus", this._panOnFocus, this);
                        remove(this._icon);
                        this.removeInteractiveTarget(this._icon);
                        this._icon = null;
                    },
                    _removeShadow: function() {
                        if (this._shadow) remove(this._shadow);
                        this._shadow = null;
                    },
                    _setPos: function(pos) {
                        if (this._icon) setPosition(this._icon, pos);
                        if (this._shadow) setPosition(this._shadow, pos);
                        this._zIndex = pos.y + this.options.zIndexOffset;
                        this._resetZIndex();
                    },
                    _updateZIndex: function(offset) {
                        if (this._icon) this._icon.style.zIndex = this._zIndex + offset;
                    },
                    _animateZoom: function(opt) {
                        var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
                        this._setPos(pos);
                    },
                    _initInteraction: function() {
                        if (!this.options.interactive) return;
                        addClass(this._icon, "leaflet-interactive");
                        this.addInteractiveTarget(this._icon);
                        if (MarkerDrag) {
                            var draggable = this.options.draggable;
                            if (this.dragging) {
                                draggable = this.dragging.enabled();
                                this.dragging.disable();
                            }
                            this.dragging = new MarkerDrag(this);
                            if (draggable) this.dragging.enable();
                        }
                    },
                    setOpacity: function(opacity) {
                        this.options.opacity = opacity;
                        if (this._map) this._updateOpacity();
                        return this;
                    },
                    _updateOpacity: function() {
                        var opacity = this.options.opacity;
                        if (this._icon) setOpacity(this._icon, opacity);
                        if (this._shadow) setOpacity(this._shadow, opacity);
                    },
                    _bringToFront: function() {
                        this._updateZIndex(this.options.riseOffset);
                    },
                    _resetZIndex: function() {
                        this._updateZIndex(0);
                    },
                    _panOnFocus: function() {
                        var map = this._map;
                        if (!map) return;
                        var iconOpts = this.options.icon.options;
                        var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
                        var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
                        map.panInside(this._latlng, {
                            paddingTopLeft: anchor,
                            paddingBottomRight: size.subtract(anchor)
                        });
                    },
                    _getPopupAnchor: function() {
                        return this.options.icon.options.popupAnchor;
                    },
                    _getTooltipAnchor: function() {
                        return this.options.icon.options.tooltipAnchor;
                    }
                });
                function marker(latlng, options) {
                    return new Marker(latlng, options);
                }
                var Path = Layer.extend({
                    options: {
                        stroke: true,
                        color: "#3388ff",
                        weight: 3,
                        opacity: 1,
                        lineCap: "round",
                        lineJoin: "round",
                        dashArray: null,
                        dashOffset: null,
                        fill: false,
                        fillColor: null,
                        fillOpacity: .2,
                        fillRule: "evenodd",
                        interactive: true,
                        bubblingMouseEvents: true
                    },
                    beforeAdd: function(map) {
                        this._renderer = map.getRenderer(this);
                    },
                    onAdd: function() {
                        this._renderer._initPath(this);
                        this._reset();
                        this._renderer._addPath(this);
                    },
                    onRemove: function() {
                        this._renderer._removePath(this);
                    },
                    redraw: function() {
                        if (this._map) this._renderer._updatePath(this);
                        return this;
                    },
                    setStyle: function(style) {
                        setOptions(this, style);
                        if (this._renderer) {
                            this._renderer._updateStyle(this);
                            if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight")) this._updateBounds();
                        }
                        return this;
                    },
                    bringToFront: function() {
                        if (this._renderer) this._renderer._bringToFront(this);
                        return this;
                    },
                    bringToBack: function() {
                        if (this._renderer) this._renderer._bringToBack(this);
                        return this;
                    },
                    getElement: function() {
                        return this._path;
                    },
                    _reset: function() {
                        this._project();
                        this._update();
                    },
                    _clickTolerance: function() {
                        return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
                    }
                });
                var CircleMarker = Path.extend({
                    options: {
                        fill: true,
                        radius: 10
                    },
                    initialize: function(latlng, options) {
                        setOptions(this, options);
                        this._latlng = toLatLng(latlng);
                        this._radius = this.options.radius;
                    },
                    setLatLng: function(latlng) {
                        var oldLatLng = this._latlng;
                        this._latlng = toLatLng(latlng);
                        this.redraw();
                        return this.fire("move", {
                            oldLatLng,
                            latlng: this._latlng
                        });
                    },
                    getLatLng: function() {
                        return this._latlng;
                    },
                    setRadius: function(radius) {
                        this.options.radius = this._radius = radius;
                        return this.redraw();
                    },
                    getRadius: function() {
                        return this._radius;
                    },
                    setStyle: function(options) {
                        var radius = options && options.radius || this._radius;
                        Path.prototype.setStyle.call(this, options);
                        this.setRadius(radius);
                        return this;
                    },
                    _project: function() {
                        this._point = this._map.latLngToLayerPoint(this._latlng);
                        this._updateBounds();
                    },
                    _updateBounds: function() {
                        var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [ r + w, r2 + w ];
                        this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
                    },
                    _update: function() {
                        if (this._map) this._updatePath();
                    },
                    _updatePath: function() {
                        this._renderer._updateCircle(this);
                    },
                    _empty: function() {
                        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
                    },
                    _containsPoint: function(p) {
                        return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
                    }
                });
                function circleMarker(latlng, options) {
                    return new CircleMarker(latlng, options);
                }
                var Circle = CircleMarker.extend({
                    initialize: function(latlng, options, legacyOptions) {
                        if (typeof options === "number") options = extend({}, legacyOptions, {
                            radius: options
                        });
                        setOptions(this, options);
                        this._latlng = toLatLng(latlng);
                        if (isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN");
                        this._mRadius = this.options.radius;
                    },
                    setRadius: function(radius) {
                        this._mRadius = radius;
                        return this.redraw();
                    },
                    getRadius: function() {
                        return this._mRadius;
                    },
                    getBounds: function() {
                        var half = [ this._radius, this._radiusY || this._radius ];
                        return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
                    },
                    setStyle: Path.prototype.setStyle,
                    _project: function() {
                        var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
                        if (crs.distance === Earth.distance) {
                            var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([ lat + latR, lng ]), bottom = map.project([ lat - latR, lng ]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
                            if (isNaN(lngR) || lngR === 0) lngR = latR / Math.cos(Math.PI / 180 * lat);
                            this._point = p.subtract(map.getPixelOrigin());
                            this._radius = isNaN(lngR) ? 0 : p.x - map.project([ lat2, lng - lngR ]).x;
                            this._radiusY = p.y - top.y;
                        } else {
                            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([ this._mRadius, 0 ]));
                            this._point = map.latLngToLayerPoint(this._latlng);
                            this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
                        }
                        this._updateBounds();
                    }
                });
                function circle(latlng, options, legacyOptions) {
                    return new Circle(latlng, options, legacyOptions);
                }
                var Polyline = Path.extend({
                    options: {
                        smoothFactor: 1,
                        noClip: false
                    },
                    initialize: function(latlngs, options) {
                        setOptions(this, options);
                        this._setLatLngs(latlngs);
                    },
                    getLatLngs: function() {
                        return this._latlngs;
                    },
                    setLatLngs: function(latlngs) {
                        this._setLatLngs(latlngs);
                        return this.redraw();
                    },
                    isEmpty: function() {
                        return !this._latlngs.length;
                    },
                    closestLayerPoint: function(p) {
                        var p1, p2, minDistance = 1 / 0, minPoint = null, closest = _sqClosestPointOnSegment;
                        for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
                            var points = this._parts[j];
                            for (var i = 1, len = points.length; i < len; i++) {
                                p1 = points[i - 1];
                                p2 = points[i];
                                var sqDist = closest(p, p1, p2, true);
                                if (sqDist < minDistance) {
                                    minDistance = sqDist;
                                    minPoint = closest(p, p1, p2);
                                }
                            }
                        }
                        if (minPoint) minPoint.distance = Math.sqrt(minDistance);
                        return minPoint;
                    },
                    getCenter: function() {
                        if (!this._map) throw new Error("Must add layer to map before using getCenter()");
                        return polylineCenter(this._defaultShape(), this._map.options.crs);
                    },
                    getBounds: function() {
                        return this._bounds;
                    },
                    addLatLng: function(latlng, latlngs) {
                        latlngs = latlngs || this._defaultShape();
                        latlng = toLatLng(latlng);
                        latlngs.push(latlng);
                        this._bounds.extend(latlng);
                        return this.redraw();
                    },
                    _setLatLngs: function(latlngs) {
                        this._bounds = new LatLngBounds;
                        this._latlngs = this._convertLatLngs(latlngs);
                    },
                    _defaultShape: function() {
                        return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
                    },
                    _convertLatLngs: function(latlngs) {
                        var result = [], flat = isFlat(latlngs);
                        for (var i = 0, len = latlngs.length; i < len; i++) if (flat) {
                            result[i] = toLatLng(latlngs[i]);
                            this._bounds.extend(result[i]);
                        } else result[i] = this._convertLatLngs(latlngs[i]);
                        return result;
                    },
                    _project: function() {
                        var pxBounds = new Bounds;
                        this._rings = [];
                        this._projectLatlngs(this._latlngs, this._rings, pxBounds);
                        if (this._bounds.isValid() && pxBounds.isValid()) {
                            this._rawPxBounds = pxBounds;
                            this._updateBounds();
                        }
                    },
                    _updateBounds: function() {
                        var w = this._clickTolerance(), p = new Point(w, w);
                        if (!this._rawPxBounds) return;
                        this._pxBounds = new Bounds([ this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p) ]);
                    },
                    _projectLatlngs: function(latlngs, result, projectedBounds) {
                        var i, ring, flat = latlngs[0] instanceof LatLng, len = latlngs.length;
                        if (flat) {
                            ring = [];
                            for (i = 0; i < len; i++) {
                                ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                                projectedBounds.extend(ring[i]);
                            }
                            result.push(ring);
                        } else for (i = 0; i < len; i++) this._projectLatlngs(latlngs[i], result, projectedBounds);
                    },
                    _clipPoints: function() {
                        var bounds = this._renderer._bounds;
                        this._parts = [];
                        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) return;
                        if (this.options.noClip) {
                            this._parts = this._rings;
                            return;
                        }
                        var i, j, k, len, len2, segment, points, parts = this._parts;
                        for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
                            points = this._rings[i];
                            for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                                segment = clipSegment(points[j], points[j + 1], bounds, j, true);
                                if (!segment) continue;
                                parts[k] = parts[k] || [];
                                parts[k].push(segment[0]);
                                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                                    parts[k].push(segment[1]);
                                    k++;
                                }
                            }
                        }
                    },
                    _simplifyPoints: function() {
                        var parts = this._parts, tolerance = this.options.smoothFactor;
                        for (var i = 0, len = parts.length; i < len; i++) parts[i] = simplify(parts[i], tolerance);
                    },
                    _update: function() {
                        if (!this._map) return;
                        this._clipPoints();
                        this._simplifyPoints();
                        this._updatePath();
                    },
                    _updatePath: function() {
                        this._renderer._updatePoly(this);
                    },
                    _containsPoint: function(p, closed) {
                        var i, j, k, len, len2, part, w = this._clickTolerance();
                        if (!this._pxBounds || !this._pxBounds.contains(p)) return false;
                        for (i = 0, len = this._parts.length; i < len; i++) {
                            part = this._parts[i];
                            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                                if (!closed && j === 0) continue;
                                if (pointToSegmentDistance(p, part[k], part[j]) <= w) return true;
                            }
                        }
                        return false;
                    }
                });
                function polyline(latlngs, options) {
                    return new Polyline(latlngs, options);
                }
                Polyline._flat = _flat;
                var Polygon = Polyline.extend({
                    options: {
                        fill: true
                    },
                    isEmpty: function() {
                        return !this._latlngs.length || !this._latlngs[0].length;
                    },
                    getCenter: function() {
                        if (!this._map) throw new Error("Must add layer to map before using getCenter()");
                        return polygonCenter(this._defaultShape(), this._map.options.crs);
                    },
                    _convertLatLngs: function(latlngs) {
                        var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
                        if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) result.pop();
                        return result;
                    },
                    _setLatLngs: function(latlngs) {
                        Polyline.prototype._setLatLngs.call(this, latlngs);
                        if (isFlat(this._latlngs)) this._latlngs = [ this._latlngs ];
                    },
                    _defaultShape: function() {
                        return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
                    },
                    _clipPoints: function() {
                        var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
                        bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
                        this._parts = [];
                        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) return;
                        if (this.options.noClip) {
                            this._parts = this._rings;
                            return;
                        }
                        for (var clipped, i = 0, len = this._rings.length; i < len; i++) {
                            clipped = clipPolygon(this._rings[i], bounds, true);
                            if (clipped.length) this._parts.push(clipped);
                        }
                    },
                    _updatePath: function() {
                        this._renderer._updatePoly(this, true);
                    },
                    _containsPoint: function(p) {
                        var part, p1, p2, i, j, k, len, len2, inside = false;
                        if (!this._pxBounds || !this._pxBounds.contains(p)) return false;
                        for (i = 0, len = this._parts.length; i < len; i++) {
                            part = this._parts[i];
                            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                                p1 = part[j];
                                p2 = part[k];
                                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) inside = !inside;
                            }
                        }
                        return inside || Polyline.prototype._containsPoint.call(this, p, true);
                    }
                });
                function polygon(latlngs, options) {
                    return new Polygon(latlngs, options);
                }
                var GeoJSON = FeatureGroup.extend({
                    initialize: function(geojson, options) {
                        setOptions(this, options);
                        this._layers = {};
                        if (geojson) this.addData(geojson);
                    },
                    addData: function(geojson) {
                        var i, len, feature, features = isArray(geojson) ? geojson : geojson.features;
                        if (features) {
                            for (i = 0, len = features.length; i < len; i++) {
                                feature = features[i];
                                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) this.addData(feature);
                            }
                            return this;
                        }
                        var options = this.options;
                        if (options.filter && !options.filter(geojson)) return this;
                        var layer = geometryToLayer(geojson, options);
                        if (!layer) return this;
                        layer.feature = asFeature(geojson);
                        layer.defaultOptions = layer.options;
                        this.resetStyle(layer);
                        if (options.onEachFeature) options.onEachFeature(geojson, layer);
                        return this.addLayer(layer);
                    },
                    resetStyle: function(layer) {
                        if (layer === void 0) return this.eachLayer(this.resetStyle, this);
                        layer.options = extend({}, layer.defaultOptions);
                        this._setLayerStyle(layer, this.options.style);
                        return this;
                    },
                    setStyle: function(style) {
                        return this.eachLayer((function(layer) {
                            this._setLayerStyle(layer, style);
                        }), this);
                    },
                    _setLayerStyle: function(layer, style) {
                        if (layer.setStyle) {
                            if (typeof style === "function") style = style(layer.feature);
                            layer.setStyle(style);
                        }
                    }
                });
                function geometryToLayer(geojson, options) {
                    var latlng, latlngs, i, len, geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng;
                    if (!coords && !geometry) return null;
                    switch (geometry.type) {
                      case "Point":
                        latlng = _coordsToLatLng(coords);
                        return _pointToLayer(pointToLayer, geojson, latlng, options);

                      case "MultiPoint":
                        for (i = 0, len = coords.length; i < len; i++) {
                            latlng = _coordsToLatLng(coords[i]);
                            layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
                        }
                        return new FeatureGroup(layers);

                      case "LineString":
                      case "MultiLineString":
                        latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
                        return new Polyline(latlngs, options);

                      case "Polygon":
                      case "MultiPolygon":
                        latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
                        return new Polygon(latlngs, options);

                      case "GeometryCollection":
                        for (i = 0, len = geometry.geometries.length; i < len; i++) {
                            var geoLayer = geometryToLayer({
                                geometry: geometry.geometries[i],
                                type: "Feature",
                                properties: geojson.properties
                            }, options);
                            if (geoLayer) layers.push(geoLayer);
                        }
                        return new FeatureGroup(layers);

                      case "FeatureCollection":
                        for (i = 0, len = geometry.features.length; i < len; i++) {
                            var featureLayer = geometryToLayer(geometry.features[i], options);
                            if (featureLayer) layers.push(featureLayer);
                        }
                        return new FeatureGroup(layers);

                      default:
                        throw new Error("Invalid GeoJSON object.");
                    }
                }
                function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
                    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
                }
                function coordsToLatLng(coords) {
                    return new LatLng(coords[1], coords[0], coords[2]);
                }
                function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
                    var latlngs = [];
                    for (var latlng, i = 0, len = coords.length; i < len; i++) {
                        latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
                        latlngs.push(latlng);
                    }
                    return latlngs;
                }
                function latLngToCoords(latlng, precision) {
                    latlng = toLatLng(latlng);
                    return latlng.alt !== void 0 ? [ formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision) ] : [ formatNum(latlng.lng, precision), formatNum(latlng.lat, precision) ];
                }
                function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
                    var coords = [];
                    for (var i = 0, len = latlngs.length; i < len; i++) coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
                    if (!levelsDeep && closed && coords.length > 0) coords.push(coords[0].slice());
                    return coords;
                }
                function getFeature(layer, newGeometry) {
                    return layer.feature ? extend({}, layer.feature, {
                        geometry: newGeometry
                    }) : asFeature(newGeometry);
                }
                function asFeature(geojson) {
                    if (geojson.type === "Feature" || geojson.type === "FeatureCollection") return geojson;
                    return {
                        type: "Feature",
                        properties: {},
                        geometry: geojson
                    };
                }
                var PointToGeoJSON = {
                    toGeoJSON: function(precision) {
                        return getFeature(this, {
                            type: "Point",
                            coordinates: latLngToCoords(this.getLatLng(), precision)
                        });
                    }
                };
                Marker.include(PointToGeoJSON);
                Circle.include(PointToGeoJSON);
                CircleMarker.include(PointToGeoJSON);
                Polyline.include({
                    toGeoJSON: function(precision) {
                        var multi = !isFlat(this._latlngs);
                        var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
                        return getFeature(this, {
                            type: (multi ? "Multi" : "") + "LineString",
                            coordinates: coords
                        });
                    }
                });
                Polygon.include({
                    toGeoJSON: function(precision) {
                        var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
                        var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
                        if (!holes) coords = [ coords ];
                        return getFeature(this, {
                            type: (multi ? "Multi" : "") + "Polygon",
                            coordinates: coords
                        });
                    }
                });
                LayerGroup.include({
                    toMultiPoint: function(precision) {
                        var coords = [];
                        this.eachLayer((function(layer) {
                            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
                        }));
                        return getFeature(this, {
                            type: "MultiPoint",
                            coordinates: coords
                        });
                    },
                    toGeoJSON: function(precision) {
                        var type = this.feature && this.feature.geometry && this.feature.geometry.type;
                        if (type === "MultiPoint") return this.toMultiPoint(precision);
                        var isGeometryCollection = type === "GeometryCollection", jsons = [];
                        this.eachLayer((function(layer) {
                            if (layer.toGeoJSON) {
                                var json = layer.toGeoJSON(precision);
                                if (isGeometryCollection) jsons.push(json.geometry); else {
                                    var feature = asFeature(json);
                                    if (feature.type === "FeatureCollection") jsons.push.apply(jsons, feature.features); else jsons.push(feature);
                                }
                            }
                        }));
                        if (isGeometryCollection) return getFeature(this, {
                            geometries: jsons,
                            type: "GeometryCollection"
                        });
                        return {
                            type: "FeatureCollection",
                            features: jsons
                        };
                    }
                });
                function geoJSON(geojson, options) {
                    return new GeoJSON(geojson, options);
                }
                var geoJson = geoJSON;
                var ImageOverlay = Layer.extend({
                    options: {
                        opacity: 1,
                        alt: "",
                        interactive: false,
                        crossOrigin: false,
                        errorOverlayUrl: "",
                        zIndex: 1,
                        className: ""
                    },
                    initialize: function(url, bounds, options) {
                        this._url = url;
                        this._bounds = toLatLngBounds(bounds);
                        setOptions(this, options);
                    },
                    onAdd: function() {
                        if (!this._image) {
                            this._initImage();
                            if (this.options.opacity < 1) this._updateOpacity();
                        }
                        if (this.options.interactive) {
                            addClass(this._image, "leaflet-interactive");
                            this.addInteractiveTarget(this._image);
                        }
                        this.getPane().appendChild(this._image);
                        this._reset();
                    },
                    onRemove: function() {
                        remove(this._image);
                        if (this.options.interactive) this.removeInteractiveTarget(this._image);
                    },
                    setOpacity: function(opacity) {
                        this.options.opacity = opacity;
                        if (this._image) this._updateOpacity();
                        return this;
                    },
                    setStyle: function(styleOpts) {
                        if (styleOpts.opacity) this.setOpacity(styleOpts.opacity);
                        return this;
                    },
                    bringToFront: function() {
                        if (this._map) toFront(this._image);
                        return this;
                    },
                    bringToBack: function() {
                        if (this._map) toBack(this._image);
                        return this;
                    },
                    setUrl: function(url) {
                        this._url = url;
                        if (this._image) this._image.src = url;
                        return this;
                    },
                    setBounds: function(bounds) {
                        this._bounds = toLatLngBounds(bounds);
                        if (this._map) this._reset();
                        return this;
                    },
                    getEvents: function() {
                        var events = {
                            zoom: this._reset,
                            viewreset: this._reset
                        };
                        if (this._zoomAnimated) events.zoomanim = this._animateZoom;
                        return events;
                    },
                    setZIndex: function(value) {
                        this.options.zIndex = value;
                        this._updateZIndex();
                        return this;
                    },
                    getBounds: function() {
                        return this._bounds;
                    },
                    getElement: function() {
                        return this._image;
                    },
                    _initImage: function() {
                        var wasElementSupplied = this._url.tagName === "IMG";
                        var img = this._image = wasElementSupplied ? this._url : create$1("img");
                        addClass(img, "leaflet-image-layer");
                        if (this._zoomAnimated) addClass(img, "leaflet-zoom-animated");
                        if (this.options.className) addClass(img, this.options.className);
                        img.onselectstart = falseFn;
                        img.onmousemove = falseFn;
                        img.onload = bind(this.fire, this, "load");
                        img.onerror = bind(this._overlayOnError, this, "error");
                        if (this.options.crossOrigin || this.options.crossOrigin === "") img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
                        if (this.options.zIndex) this._updateZIndex();
                        if (wasElementSupplied) {
                            this._url = img.src;
                            return;
                        }
                        img.src = this._url;
                        img.alt = this.options.alt;
                    },
                    _animateZoom: function(e) {
                        var scale = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
                        setTransform(this._image, offset, scale);
                    },
                    _reset: function() {
                        var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
                        setPosition(image, bounds.min);
                        image.style.width = size.x + "px";
                        image.style.height = size.y + "px";
                    },
                    _updateOpacity: function() {
                        setOpacity(this._image, this.options.opacity);
                    },
                    _updateZIndex: function() {
                        if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) this._image.style.zIndex = this.options.zIndex;
                    },
                    _overlayOnError: function() {
                        this.fire("error");
                        var errorUrl = this.options.errorOverlayUrl;
                        if (errorUrl && this._url !== errorUrl) {
                            this._url = errorUrl;
                            this._image.src = errorUrl;
                        }
                    },
                    getCenter: function() {
                        return this._bounds.getCenter();
                    }
                });
                var imageOverlay = function(url, bounds, options) {
                    return new ImageOverlay(url, bounds, options);
                };
                var VideoOverlay = ImageOverlay.extend({
                    options: {
                        autoplay: true,
                        loop: true,
                        keepAspectRatio: true,
                        muted: false,
                        playsInline: true
                    },
                    _initImage: function() {
                        var wasElementSupplied = this._url.tagName === "VIDEO";
                        var vid = this._image = wasElementSupplied ? this._url : create$1("video");
                        addClass(vid, "leaflet-image-layer");
                        if (this._zoomAnimated) addClass(vid, "leaflet-zoom-animated");
                        if (this.options.className) addClass(vid, this.options.className);
                        vid.onselectstart = falseFn;
                        vid.onmousemove = falseFn;
                        vid.onloadeddata = bind(this.fire, this, "load");
                        if (wasElementSupplied) {
                            var sourceElements = vid.getElementsByTagName("source");
                            var sources = [];
                            for (var j = 0; j < sourceElements.length; j++) sources.push(sourceElements[j].src);
                            this._url = sourceElements.length > 0 ? sources : [ vid.src ];
                            return;
                        }
                        if (!isArray(this._url)) this._url = [ this._url ];
                        if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) vid.style["objectFit"] = "fill";
                        vid.autoplay = !!this.options.autoplay;
                        vid.loop = !!this.options.loop;
                        vid.muted = !!this.options.muted;
                        vid.playsInline = !!this.options.playsInline;
                        for (var i = 0; i < this._url.length; i++) {
                            var source = create$1("source");
                            source.src = this._url[i];
                            vid.appendChild(source);
                        }
                    }
                });
                function videoOverlay(video, bounds, options) {
                    return new VideoOverlay(video, bounds, options);
                }
                var SVGOverlay = ImageOverlay.extend({
                    _initImage: function() {
                        var el = this._image = this._url;
                        addClass(el, "leaflet-image-layer");
                        if (this._zoomAnimated) addClass(el, "leaflet-zoom-animated");
                        if (this.options.className) addClass(el, this.options.className);
                        el.onselectstart = falseFn;
                        el.onmousemove = falseFn;
                    }
                });
                function svgOverlay(el, bounds, options) {
                    return new SVGOverlay(el, bounds, options);
                }
                var DivOverlay = Layer.extend({
                    options: {
                        interactive: false,
                        offset: [ 0, 0 ],
                        className: "",
                        pane: void 0,
                        content: ""
                    },
                    initialize: function(options, source) {
                        if (options && (options instanceof LatLng || isArray(options))) {
                            this._latlng = toLatLng(options);
                            setOptions(this, source);
                        } else {
                            setOptions(this, options);
                            this._source = source;
                        }
                        if (this.options.content) this._content = this.options.content;
                    },
                    openOn: function(map) {
                        map = arguments.length ? map : this._source._map;
                        if (!map.hasLayer(this)) map.addLayer(this);
                        return this;
                    },
                    close: function() {
                        if (this._map) this._map.removeLayer(this);
                        return this;
                    },
                    toggle: function(layer) {
                        if (this._map) this.close(); else {
                            if (arguments.length) this._source = layer; else layer = this._source;
                            this._prepareOpen();
                            this.openOn(layer._map);
                        }
                        return this;
                    },
                    onAdd: function(map) {
                        this._zoomAnimated = map._zoomAnimated;
                        if (!this._container) this._initLayout();
                        if (map._fadeAnimated) setOpacity(this._container, 0);
                        clearTimeout(this._removeTimeout);
                        this.getPane().appendChild(this._container);
                        this.update();
                        if (map._fadeAnimated) setOpacity(this._container, 1);
                        this.bringToFront();
                        if (this.options.interactive) {
                            addClass(this._container, "leaflet-interactive");
                            this.addInteractiveTarget(this._container);
                        }
                    },
                    onRemove: function(map) {
                        if (map._fadeAnimated) {
                            setOpacity(this._container, 0);
                            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
                        } else remove(this._container);
                        if (this.options.interactive) {
                            removeClass(this._container, "leaflet-interactive");
                            this.removeInteractiveTarget(this._container);
                        }
                    },
                    getLatLng: function() {
                        return this._latlng;
                    },
                    setLatLng: function(latlng) {
                        this._latlng = toLatLng(latlng);
                        if (this._map) {
                            this._updatePosition();
                            this._adjustPan();
                        }
                        return this;
                    },
                    getContent: function() {
                        return this._content;
                    },
                    setContent: function(content) {
                        this._content = content;
                        this.update();
                        return this;
                    },
                    getElement: function() {
                        return this._container;
                    },
                    update: function() {
                        if (!this._map) return;
                        this._container.style.visibility = "hidden";
                        this._updateContent();
                        this._updateLayout();
                        this._updatePosition();
                        this._container.style.visibility = "";
                        this._adjustPan();
                    },
                    getEvents: function() {
                        var events = {
                            zoom: this._updatePosition,
                            viewreset: this._updatePosition
                        };
                        if (this._zoomAnimated) events.zoomanim = this._animateZoom;
                        return events;
                    },
                    isOpen: function() {
                        return !!this._map && this._map.hasLayer(this);
                    },
                    bringToFront: function() {
                        if (this._map) toFront(this._container);
                        return this;
                    },
                    bringToBack: function() {
                        if (this._map) toBack(this._container);
                        return this;
                    },
                    _prepareOpen: function(latlng) {
                        var source = this._source;
                        if (!source._map) return false;
                        if (source instanceof FeatureGroup) {
                            source = null;
                            var layers = this._source._layers;
                            for (var id in layers) if (layers[id]._map) {
                                source = layers[id];
                                break;
                            }
                            if (!source) return false;
                            this._source = source;
                        }
                        if (!latlng) if (source.getCenter) latlng = source.getCenter(); else if (source.getLatLng) latlng = source.getLatLng(); else if (source.getBounds) latlng = source.getBounds().getCenter(); else throw new Error("Unable to get source layer LatLng.");
                        this.setLatLng(latlng);
                        if (this._map) this.update();
                        return true;
                    },
                    _updateContent: function() {
                        if (!this._content) return;
                        var node = this._contentNode;
                        var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
                        if (typeof content === "string") node.innerHTML = content; else {
                            while (node.hasChildNodes()) node.removeChild(node.firstChild);
                            node.appendChild(content);
                        }
                        this.fire("contentupdate");
                    },
                    _updatePosition: function() {
                        if (!this._map) return;
                        var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
                        if (this._zoomAnimated) setPosition(this._container, pos.add(anchor)); else offset = offset.add(pos).add(anchor);
                        var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
                        this._container.style.bottom = bottom + "px";
                        this._container.style.left = left + "px";
                    },
                    _getAnchor: function() {
                        return [ 0, 0 ];
                    }
                });
                Map.include({
                    _initOverlay: function(OverlayClass, content, latlng, options) {
                        var overlay = content;
                        if (!(overlay instanceof OverlayClass)) overlay = new OverlayClass(options).setContent(content);
                        if (latlng) overlay.setLatLng(latlng);
                        return overlay;
                    }
                });
                Layer.include({
                    _initOverlay: function(OverlayClass, old, content, options) {
                        var overlay = content;
                        if (overlay instanceof OverlayClass) {
                            setOptions(overlay, options);
                            overlay._source = this;
                        } else {
                            overlay = old && !options ? old : new OverlayClass(options, this);
                            overlay.setContent(content);
                        }
                        return overlay;
                    }
                });
                var Popup = DivOverlay.extend({
                    options: {
                        pane: "popupPane",
                        offset: [ 0, 7 ],
                        maxWidth: 300,
                        minWidth: 50,
                        maxHeight: null,
                        autoPan: true,
                        autoPanPaddingTopLeft: null,
                        autoPanPaddingBottomRight: null,
                        autoPanPadding: [ 5, 5 ],
                        keepInView: false,
                        closeButton: true,
                        autoClose: true,
                        closeOnEscapeKey: true,
                        className: ""
                    },
                    openOn: function(map) {
                        map = arguments.length ? map : this._source._map;
                        if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) map.removeLayer(map._popup);
                        map._popup = this;
                        return DivOverlay.prototype.openOn.call(this, map);
                    },
                    onAdd: function(map) {
                        DivOverlay.prototype.onAdd.call(this, map);
                        map.fire("popupopen", {
                            popup: this
                        });
                        if (this._source) {
                            this._source.fire("popupopen", {
                                popup: this
                            }, true);
                            if (!(this._source instanceof Path)) this._source.on("preclick", stopPropagation);
                        }
                    },
                    onRemove: function(map) {
                        DivOverlay.prototype.onRemove.call(this, map);
                        map.fire("popupclose", {
                            popup: this
                        });
                        if (this._source) {
                            this._source.fire("popupclose", {
                                popup: this
                            }, true);
                            if (!(this._source instanceof Path)) this._source.off("preclick", stopPropagation);
                        }
                    },
                    getEvents: function() {
                        var events = DivOverlay.prototype.getEvents.call(this);
                        if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) events.preclick = this.close;
                        if (this.options.keepInView) events.moveend = this._adjustPan;
                        return events;
                    },
                    _initLayout: function() {
                        var prefix = "leaflet-popup", container = this._container = create$1("div", prefix + " " + (this.options.className || "") + " leaflet-zoom-animated");
                        var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
                        this._contentNode = create$1("div", prefix + "-content", wrapper);
                        disableClickPropagation(container);
                        disableScrollPropagation(this._contentNode);
                        on(container, "contextmenu", stopPropagation);
                        this._tipContainer = create$1("div", prefix + "-tip-container", container);
                        this._tip = create$1("div", prefix + "-tip", this._tipContainer);
                        if (this.options.closeButton) {
                            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
                            closeButton.setAttribute("role", "button");
                            closeButton.setAttribute("aria-label", "Close popup");
                            closeButton.href = "#close";
                            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
                            on(closeButton, "click", (function(ev) {
                                preventDefault(ev);
                                this.close();
                            }), this);
                        }
                    },
                    _updateLayout: function() {
                        var container = this._contentNode, style = container.style;
                        style.width = "";
                        style.whiteSpace = "nowrap";
                        var width = container.offsetWidth;
                        width = Math.min(width, this.options.maxWidth);
                        width = Math.max(width, this.options.minWidth);
                        style.width = width + 1 + "px";
                        style.whiteSpace = "";
                        style.height = "";
                        var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
                        if (maxHeight && height > maxHeight) {
                            style.height = maxHeight + "px";
                            addClass(container, scrolledClass);
                        } else removeClass(container, scrolledClass);
                        this._containerWidth = this._container.offsetWidth;
                    },
                    _animateZoom: function(e) {
                        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
                        setPosition(this._container, pos.add(anchor));
                    },
                    _adjustPan: function() {
                        if (!this.options.autoPan) return;
                        if (this._map._panAnim) this._map._panAnim.stop();
                        if (this._autopanning) {
                            this._autopanning = false;
                            return;
                        }
                        var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
                        layerPos._add(getPosition(this._container));
                        var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
                        if (containerPos.x + containerWidth + paddingBR.x > size.x) dx = containerPos.x + containerWidth - size.x + paddingBR.x;
                        if (containerPos.x - dx - paddingTL.x < 0) dx = containerPos.x - paddingTL.x;
                        if (containerPos.y + containerHeight + paddingBR.y > size.y) dy = containerPos.y + containerHeight - size.y + paddingBR.y;
                        if (containerPos.y - dy - paddingTL.y < 0) dy = containerPos.y - paddingTL.y;
                        if (dx || dy) {
                            if (this.options.keepInView) this._autopanning = true;
                            map.fire("autopanstart").panBy([ dx, dy ]);
                        }
                    },
                    _getAnchor: function() {
                        return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [ 0, 0 ]);
                    }
                });
                var popup = function(options, source) {
                    return new Popup(options, source);
                };
                Map.mergeOptions({
                    closePopupOnClick: true
                });
                Map.include({
                    openPopup: function(popup, latlng, options) {
                        this._initOverlay(Popup, popup, latlng, options).openOn(this);
                        return this;
                    },
                    closePopup: function(popup) {
                        popup = arguments.length ? popup : this._popup;
                        if (popup) popup.close();
                        return this;
                    }
                });
                Layer.include({
                    bindPopup: function(content, options) {
                        this._popup = this._initOverlay(Popup, this._popup, content, options);
                        if (!this._popupHandlersAdded) {
                            this.on({
                                click: this._openPopup,
                                keypress: this._onKeyPress,
                                remove: this.closePopup,
                                move: this._movePopup
                            });
                            this._popupHandlersAdded = true;
                        }
                        return this;
                    },
                    unbindPopup: function() {
                        if (this._popup) {
                            this.off({
                                click: this._openPopup,
                                keypress: this._onKeyPress,
                                remove: this.closePopup,
                                move: this._movePopup
                            });
                            this._popupHandlersAdded = false;
                            this._popup = null;
                        }
                        return this;
                    },
                    openPopup: function(latlng) {
                        if (this._popup) {
                            if (!(this instanceof FeatureGroup)) this._popup._source = this;
                            if (this._popup._prepareOpen(latlng || this._latlng)) this._popup.openOn(this._map);
                        }
                        return this;
                    },
                    closePopup: function() {
                        if (this._popup) this._popup.close();
                        return this;
                    },
                    togglePopup: function() {
                        if (this._popup) this._popup.toggle(this);
                        return this;
                    },
                    isPopupOpen: function() {
                        return this._popup ? this._popup.isOpen() : false;
                    },
                    setPopupContent: function(content) {
                        if (this._popup) this._popup.setContent(content);
                        return this;
                    },
                    getPopup: function() {
                        return this._popup;
                    },
                    _openPopup: function(e) {
                        if (!this._popup || !this._map) return;
                        stop(e);
                        var target = e.layer || e.target;
                        if (this._popup._source === target && !(target instanceof Path)) {
                            if (this._map.hasLayer(this._popup)) this.closePopup(); else this.openPopup(e.latlng);
                            return;
                        }
                        this._popup._source = target;
                        this.openPopup(e.latlng);
                    },
                    _movePopup: function(e) {
                        this._popup.setLatLng(e.latlng);
                    },
                    _onKeyPress: function(e) {
                        if (e.originalEvent.keyCode === 13) this._openPopup(e);
                    }
                });
                var Tooltip = DivOverlay.extend({
                    options: {
                        pane: "tooltipPane",
                        offset: [ 0, 0 ],
                        direction: "auto",
                        permanent: false,
                        sticky: false,
                        opacity: .9
                    },
                    onAdd: function(map) {
                        DivOverlay.prototype.onAdd.call(this, map);
                        this.setOpacity(this.options.opacity);
                        map.fire("tooltipopen", {
                            tooltip: this
                        });
                        if (this._source) {
                            this.addEventParent(this._source);
                            this._source.fire("tooltipopen", {
                                tooltip: this
                            }, true);
                        }
                    },
                    onRemove: function(map) {
                        DivOverlay.prototype.onRemove.call(this, map);
                        map.fire("tooltipclose", {
                            tooltip: this
                        });
                        if (this._source) {
                            this.removeEventParent(this._source);
                            this._source.fire("tooltipclose", {
                                tooltip: this
                            }, true);
                        }
                    },
                    getEvents: function() {
                        var events = DivOverlay.prototype.getEvents.call(this);
                        if (!this.options.permanent) events.preclick = this.close;
                        return events;
                    },
                    _initLayout: function() {
                        var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
                        this._contentNode = this._container = create$1("div", className);
                        this._container.setAttribute("role", "tooltip");
                        this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
                    },
                    _updateLayout: function() {},
                    _adjustPan: function() {},
                    _setPosition: function(pos) {
                        var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
                        if (direction === "top") {
                            subX = tooltipWidth / 2;
                            subY = tooltipHeight;
                        } else if (direction === "bottom") {
                            subX = tooltipWidth / 2;
                            subY = 0;
                        } else if (direction === "center") {
                            subX = tooltipWidth / 2;
                            subY = tooltipHeight / 2;
                        } else if (direction === "right") {
                            subX = 0;
                            subY = tooltipHeight / 2;
                        } else if (direction === "left") {
                            subX = tooltipWidth;
                            subY = tooltipHeight / 2;
                        } else if (tooltipPoint.x < centerPoint.x) {
                            direction = "right";
                            subX = 0;
                            subY = tooltipHeight / 2;
                        } else {
                            direction = "left";
                            subX = tooltipWidth + (offset.x + anchor.x) * 2;
                            subY = tooltipHeight / 2;
                        }
                        pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
                        removeClass(container, "leaflet-tooltip-right");
                        removeClass(container, "leaflet-tooltip-left");
                        removeClass(container, "leaflet-tooltip-top");
                        removeClass(container, "leaflet-tooltip-bottom");
                        addClass(container, "leaflet-tooltip-" + direction);
                        setPosition(container, pos);
                    },
                    _updatePosition: function() {
                        var pos = this._map.latLngToLayerPoint(this._latlng);
                        this._setPosition(pos);
                    },
                    setOpacity: function(opacity) {
                        this.options.opacity = opacity;
                        if (this._container) setOpacity(this._container, opacity);
                    },
                    _animateZoom: function(e) {
                        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
                        this._setPosition(pos);
                    },
                    _getAnchor: function() {
                        return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [ 0, 0 ]);
                    }
                });
                var tooltip = function(options, source) {
                    return new Tooltip(options, source);
                };
                Map.include({
                    openTooltip: function(tooltip, latlng, options) {
                        this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);
                        return this;
                    },
                    closeTooltip: function(tooltip) {
                        tooltip.close();
                        return this;
                    }
                });
                Layer.include({
                    bindTooltip: function(content, options) {
                        if (this._tooltip && this.isTooltipOpen()) this.unbindTooltip();
                        this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
                        this._initTooltipInteractions();
                        if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) this.openTooltip();
                        return this;
                    },
                    unbindTooltip: function() {
                        if (this._tooltip) {
                            this._initTooltipInteractions(true);
                            this.closeTooltip();
                            this._tooltip = null;
                        }
                        return this;
                    },
                    _initTooltipInteractions: function(remove) {
                        if (!remove && this._tooltipHandlersAdded) return;
                        var onOff = remove ? "off" : "on", events = {
                            remove: this.closeTooltip,
                            move: this._moveTooltip
                        };
                        if (!this._tooltip.options.permanent) {
                            events.mouseover = this._openTooltip;
                            events.mouseout = this.closeTooltip;
                            events.click = this._openTooltip;
                            if (this._map) this._addFocusListeners(); else events.add = this._addFocusListeners;
                        } else events.add = this._openTooltip;
                        if (this._tooltip.options.sticky) events.mousemove = this._moveTooltip;
                        this[onOff](events);
                        this._tooltipHandlersAdded = !remove;
                    },
                    openTooltip: function(latlng) {
                        if (this._tooltip) {
                            if (!(this instanceof FeatureGroup)) this._tooltip._source = this;
                            if (this._tooltip._prepareOpen(latlng)) {
                                this._tooltip.openOn(this._map);
                                if (this.getElement) this._setAriaDescribedByOnLayer(this); else if (this.eachLayer) this.eachLayer(this._setAriaDescribedByOnLayer, this);
                            }
                        }
                        return this;
                    },
                    closeTooltip: function() {
                        if (this._tooltip) return this._tooltip.close();
                    },
                    toggleTooltip: function() {
                        if (this._tooltip) this._tooltip.toggle(this);
                        return this;
                    },
                    isTooltipOpen: function() {
                        return this._tooltip.isOpen();
                    },
                    setTooltipContent: function(content) {
                        if (this._tooltip) this._tooltip.setContent(content);
                        return this;
                    },
                    getTooltip: function() {
                        return this._tooltip;
                    },
                    _addFocusListeners: function() {
                        if (this.getElement) this._addFocusListenersOnLayer(this); else if (this.eachLayer) this.eachLayer(this._addFocusListenersOnLayer, this);
                    },
                    _addFocusListenersOnLayer: function(layer) {
                        var el = typeof layer.getElement === "function" && layer.getElement();
                        if (el) {
                            on(el, "focus", (function() {
                                this._tooltip._source = layer;
                                this.openTooltip();
                            }), this);
                            on(el, "blur", this.closeTooltip, this);
                        }
                    },
                    _setAriaDescribedByOnLayer: function(layer) {
                        var el = typeof layer.getElement === "function" && layer.getElement();
                        if (el) el.setAttribute("aria-describedby", this._tooltip._container.id);
                    },
                    _openTooltip: function(e) {
                        if (!this._tooltip || !this._map) return;
                        if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
                            this._openOnceFlag = true;
                            var that = this;
                            this._map.once("moveend", (function() {
                                that._openOnceFlag = false;
                                that._openTooltip(e);
                            }));
                            return;
                        }
                        this._tooltip._source = e.layer || e.target;
                        this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
                    },
                    _moveTooltip: function(e) {
                        var containerPoint, layerPoint, latlng = e.latlng;
                        if (this._tooltip.options.sticky && e.originalEvent) {
                            containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
                            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
                            latlng = this._map.layerPointToLatLng(layerPoint);
                        }
                        this._tooltip.setLatLng(latlng);
                    }
                });
                var DivIcon = Icon.extend({
                    options: {
                        iconSize: [ 12, 12 ],
                        html: false,
                        bgPos: null,
                        className: "leaflet-div-icon"
                    },
                    createIcon: function(oldIcon) {
                        var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
                        if (options.html instanceof Element) {
                            empty(div);
                            div.appendChild(options.html);
                        } else div.innerHTML = options.html !== false ? options.html : "";
                        if (options.bgPos) {
                            var bgPos = toPoint(options.bgPos);
                            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
                        }
                        this._setIconStyles(div, "icon");
                        return div;
                    },
                    createShadow: function() {
                        return null;
                    }
                });
                function divIcon(options) {
                    return new DivIcon(options);
                }
                Icon.Default = IconDefault;
                var GridLayer = Layer.extend({
                    options: {
                        tileSize: 256,
                        opacity: 1,
                        updateWhenIdle: Browser.mobile,
                        updateWhenZooming: true,
                        updateInterval: 200,
                        zIndex: 1,
                        bounds: null,
                        minZoom: 0,
                        maxZoom: void 0,
                        maxNativeZoom: void 0,
                        minNativeZoom: void 0,
                        noWrap: false,
                        pane: "tilePane",
                        className: "",
                        keepBuffer: 2
                    },
                    initialize: function(options) {
                        setOptions(this, options);
                    },
                    onAdd: function() {
                        this._initContainer();
                        this._levels = {};
                        this._tiles = {};
                        this._resetView();
                    },
                    beforeAdd: function(map) {
                        map._addZoomLimit(this);
                    },
                    onRemove: function(map) {
                        this._removeAllTiles();
                        remove(this._container);
                        map._removeZoomLimit(this);
                        this._container = null;
                        this._tileZoom = void 0;
                    },
                    bringToFront: function() {
                        if (this._map) {
                            toFront(this._container);
                            this._setAutoZIndex(Math.max);
                        }
                        return this;
                    },
                    bringToBack: function() {
                        if (this._map) {
                            toBack(this._container);
                            this._setAutoZIndex(Math.min);
                        }
                        return this;
                    },
                    getContainer: function() {
                        return this._container;
                    },
                    setOpacity: function(opacity) {
                        this.options.opacity = opacity;
                        this._updateOpacity();
                        return this;
                    },
                    setZIndex: function(zIndex) {
                        this.options.zIndex = zIndex;
                        this._updateZIndex();
                        return this;
                    },
                    isLoading: function() {
                        return this._loading;
                    },
                    redraw: function() {
                        if (this._map) {
                            this._removeAllTiles();
                            var tileZoom = this._clampZoom(this._map.getZoom());
                            if (tileZoom !== this._tileZoom) {
                                this._tileZoom = tileZoom;
                                this._updateLevels();
                            }
                            this._update();
                        }
                        return this;
                    },
                    getEvents: function() {
                        var events = {
                            viewprereset: this._invalidateAll,
                            viewreset: this._resetView,
                            zoom: this._resetView,
                            moveend: this._onMoveEnd
                        };
                        if (!this.options.updateWhenIdle) {
                            if (!this._onMove) this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
                            events.move = this._onMove;
                        }
                        if (this._zoomAnimated) events.zoomanim = this._animateZoom;
                        return events;
                    },
                    createTile: function() {
                        return document.createElement("div");
                    },
                    getTileSize: function() {
                        var s = this.options.tileSize;
                        return s instanceof Point ? s : new Point(s, s);
                    },
                    _updateZIndex: function() {
                        if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) this._container.style.zIndex = this.options.zIndex;
                    },
                    _setAutoZIndex: function(compare) {
                        var layers = this.getPane().children, edgeZIndex = -compare(-1 / 0, 1 / 0);
                        for (var zIndex, i = 0, len = layers.length; i < len; i++) {
                            zIndex = layers[i].style.zIndex;
                            if (layers[i] !== this._container && zIndex) edgeZIndex = compare(edgeZIndex, +zIndex);
                        }
                        if (isFinite(edgeZIndex)) {
                            this.options.zIndex = edgeZIndex + compare(-1, 1);
                            this._updateZIndex();
                        }
                    },
                    _updateOpacity: function() {
                        if (!this._map) return;
                        if (Browser.ielt9) return;
                        setOpacity(this._container, this.options.opacity);
                        var now = +new Date, nextFrame = false, willPrune = false;
                        for (var key in this._tiles) {
                            var tile = this._tiles[key];
                            if (!tile.current || !tile.loaded) continue;
                            var fade = Math.min(1, (now - tile.loaded) / 200);
                            setOpacity(tile.el, fade);
                            if (fade < 1) nextFrame = true; else {
                                if (tile.active) willPrune = true; else this._onOpaqueTile(tile);
                                tile.active = true;
                            }
                        }
                        if (willPrune && !this._noPrune) this._pruneTiles();
                        if (nextFrame) {
                            cancelAnimFrame(this._fadeFrame);
                            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
                        }
                    },
                    _onOpaqueTile: falseFn,
                    _initContainer: function() {
                        if (this._container) return;
                        this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
                        this._updateZIndex();
                        if (this.options.opacity < 1) this._updateOpacity();
                        this.getPane().appendChild(this._container);
                    },
                    _updateLevels: function() {
                        var zoom = this._tileZoom, maxZoom = this.options.maxZoom;
                        if (zoom === void 0) return;
                        for (var z in this._levels) {
                            z = Number(z);
                            if (this._levels[z].el.children.length || z === zoom) {
                                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
                                this._onUpdateLevel(z);
                            } else {
                                remove(this._levels[z].el);
                                this._removeTilesAtZoom(z);
                                this._onRemoveLevel(z);
                                delete this._levels[z];
                            }
                        }
                        var level = this._levels[zoom], map = this._map;
                        if (!level) {
                            level = this._levels[zoom] = {};
                            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
                            level.el.style.zIndex = maxZoom;
                            level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
                            level.zoom = zoom;
                            this._setZoomTransform(level, map.getCenter(), map.getZoom());
                            falseFn(level.el.offsetWidth);
                            this._onCreateLevel(level);
                        }
                        this._level = level;
                        return level;
                    },
                    _onUpdateLevel: falseFn,
                    _onRemoveLevel: falseFn,
                    _onCreateLevel: falseFn,
                    _pruneTiles: function() {
                        if (!this._map) return;
                        var key, tile;
                        var zoom = this._map.getZoom();
                        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                            this._removeAllTiles();
                            return;
                        }
                        for (key in this._tiles) {
                            tile = this._tiles[key];
                            tile.retain = tile.current;
                        }
                        for (key in this._tiles) {
                            tile = this._tiles[key];
                            if (tile.current && !tile.active) {
                                var coords = tile.coords;
                                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                            }
                        }
                        for (key in this._tiles) if (!this._tiles[key].retain) this._removeTile(key);
                    },
                    _removeTilesAtZoom: function(zoom) {
                        for (var key in this._tiles) {
                            if (this._tiles[key].coords.z !== zoom) continue;
                            this._removeTile(key);
                        }
                    },
                    _removeAllTiles: function() {
                        for (var key in this._tiles) this._removeTile(key);
                    },
                    _invalidateAll: function() {
                        for (var z in this._levels) {
                            remove(this._levels[z].el);
                            this._onRemoveLevel(Number(z));
                            delete this._levels[z];
                        }
                        this._removeAllTiles();
                        this._tileZoom = void 0;
                    },
                    _retainParent: function(x, y, z, minZoom) {
                        var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
                        coords2.z = +z2;
                        var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
                        if (tile && tile.active) {
                            tile.retain = true;
                            return true;
                        } else if (tile && tile.loaded) tile.retain = true;
                        if (z2 > minZoom) return this._retainParent(x2, y2, z2, minZoom);
                        return false;
                    },
                    _retainChildren: function(x, y, z, maxZoom) {
                        for (var i = 2 * x; i < 2 * x + 2; i++) for (var j = 2 * y; j < 2 * y + 2; j++) {
                            var coords = new Point(i, j);
                            coords.z = z + 1;
                            var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                            if (tile && tile.active) {
                                tile.retain = true;
                                continue;
                            } else if (tile && tile.loaded) tile.retain = true;
                            if (z + 1 < maxZoom) this._retainChildren(i, j, z + 1, maxZoom);
                        }
                    },
                    _resetView: function(e) {
                        var animating = e && (e.pinch || e.flyTo);
                        this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
                    },
                    _animateZoom: function(e) {
                        this._setView(e.center, e.zoom, true, e.noUpdate);
                    },
                    _clampZoom: function(zoom) {
                        var options = this.options;
                        if (void 0 !== options.minNativeZoom && zoom < options.minNativeZoom) return options.minNativeZoom;
                        if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom) return options.maxNativeZoom;
                        return zoom;
                    },
                    _setView: function(center, zoom, noPrune, noUpdate) {
                        var tileZoom = Math.round(zoom);
                        if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) tileZoom = void 0; else tileZoom = this._clampZoom(tileZoom);
                        var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
                        if (!noUpdate || tileZoomChanged) {
                            this._tileZoom = tileZoom;
                            if (this._abortLoading) this._abortLoading();
                            this._updateLevels();
                            this._resetGrid();
                            if (tileZoom !== void 0) this._update(center);
                            if (!noPrune) this._pruneTiles();
                            this._noPrune = !!noPrune;
                        }
                        this._setZoomTransforms(center, zoom);
                    },
                    _setZoomTransforms: function(center, zoom) {
                        for (var i in this._levels) this._setZoomTransform(this._levels[i], center, zoom);
                    },
                    _setZoomTransform: function(level, center, zoom) {
                        var scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();
                        if (Browser.any3d) setTransform(level.el, translate, scale); else setPosition(level.el, translate);
                    },
                    _resetGrid: function() {
                        var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
                        var bounds = this._map.getPixelWorldBounds(this._tileZoom);
                        if (bounds) this._globalTileRange = this._pxBoundsToTileRange(bounds);
                        this._wrapX = crs.wrapLng && !this.options.noWrap && [ Math.floor(map.project([ 0, crs.wrapLng[0] ], tileZoom).x / tileSize.x), Math.ceil(map.project([ 0, crs.wrapLng[1] ], tileZoom).x / tileSize.y) ];
                        this._wrapY = crs.wrapLat && !this.options.noWrap && [ Math.floor(map.project([ crs.wrapLat[0], 0 ], tileZoom).y / tileSize.x), Math.ceil(map.project([ crs.wrapLat[1], 0 ], tileZoom).y / tileSize.y) ];
                    },
                    _onMoveEnd: function() {
                        if (!this._map || this._map._animatingZoom) return;
                        this._update();
                    },
                    _getTiledPixelBounds: function(center) {
                        var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale * 2);
                        return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
                    },
                    _update: function(center) {
                        var map = this._map;
                        if (!map) return;
                        var zoom = this._clampZoom(map.getZoom());
                        if (center === void 0) center = map.getCenter();
                        if (this._tileZoom === void 0) return;
                        var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([ margin, -margin ]), tileRange.getTopRight().add([ margin, -margin ]));
                        if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) throw new Error("Attempted to load an infinite number of tiles");
                        for (var key in this._tiles) {
                            var c = this._tiles[key].coords;
                            if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) this._tiles[key].current = false;
                        }
                        if (Math.abs(zoom - this._tileZoom) > 1) {
                            this._setView(center, zoom);
                            return;
                        }
                        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                            var coords = new Point(i, j);
                            coords.z = this._tileZoom;
                            if (!this._isValidTile(coords)) continue;
                            var tile = this._tiles[this._tileCoordsToKey(coords)];
                            if (tile) tile.current = true; else queue.push(coords);
                        }
                        queue.sort((function(a, b) {
                            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
                        }));
                        if (queue.length !== 0) {
                            if (!this._loading) {
                                this._loading = true;
                                this.fire("loading");
                            }
                            var fragment = document.createDocumentFragment();
                            for (i = 0; i < queue.length; i++) this._addTile(queue[i], fragment);
                            this._level.el.appendChild(fragment);
                        }
                    },
                    _isValidTile: function(coords) {
                        var crs = this._map.options.crs;
                        if (!crs.infinite) {
                            var bounds = this._globalTileRange;
                            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) return false;
                        }
                        if (!this.options.bounds) return true;
                        var tileBounds = this._tileCoordsToBounds(coords);
                        return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
                    },
                    _keyToBounds: function(key) {
                        return this._tileCoordsToBounds(this._keyToTileCoords(key));
                    },
                    _tileCoordsToNwSe: function(coords) {
                        var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
                        return [ nw, se ];
                    },
                    _tileCoordsToBounds: function(coords) {
                        var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
                        if (!this.options.noWrap) bounds = this._map.wrapLatLngBounds(bounds);
                        return bounds;
                    },
                    _tileCoordsToKey: function(coords) {
                        return coords.x + ":" + coords.y + ":" + coords.z;
                    },
                    _keyToTileCoords: function(key) {
                        var k = key.split(":"), coords = new Point(+k[0], +k[1]);
                        coords.z = +k[2];
                        return coords;
                    },
                    _removeTile: function(key) {
                        var tile = this._tiles[key];
                        if (!tile) return;
                        remove(tile.el);
                        delete this._tiles[key];
                        this.fire("tileunload", {
                            tile: tile.el,
                            coords: this._keyToTileCoords(key)
                        });
                    },
                    _initTile: function(tile) {
                        addClass(tile, "leaflet-tile");
                        var tileSize = this.getTileSize();
                        tile.style.width = tileSize.x + "px";
                        tile.style.height = tileSize.y + "px";
                        tile.onselectstart = falseFn;
                        tile.onmousemove = falseFn;
                        if (Browser.ielt9 && this.options.opacity < 1) setOpacity(tile, this.options.opacity);
                    },
                    _addTile: function(coords, container) {
                        var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
                        var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
                        this._initTile(tile);
                        if (this.createTile.length < 2) requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
                        setPosition(tile, tilePos);
                        this._tiles[key] = {
                            el: tile,
                            coords,
                            current: true
                        };
                        container.appendChild(tile);
                        this.fire("tileloadstart", {
                            tile,
                            coords
                        });
                    },
                    _tileReady: function(coords, err, tile) {
                        if (err) this.fire("tileerror", {
                            error: err,
                            tile,
                            coords
                        });
                        var key = this._tileCoordsToKey(coords);
                        tile = this._tiles[key];
                        if (!tile) return;
                        tile.loaded = +new Date;
                        if (this._map._fadeAnimated) {
                            setOpacity(tile.el, 0);
                            cancelAnimFrame(this._fadeFrame);
                            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
                        } else {
                            tile.active = true;
                            this._pruneTiles();
                        }
                        if (!err) {
                            addClass(tile.el, "leaflet-tile-loaded");
                            this.fire("tileload", {
                                tile: tile.el,
                                coords
                            });
                        }
                        if (this._noTilesToLoad()) {
                            this._loading = false;
                            this.fire("load");
                            if (Browser.ielt9 || !this._map._fadeAnimated) requestAnimFrame(this._pruneTiles, this); else setTimeout(bind(this._pruneTiles, this), 250);
                        }
                    },
                    _getTilePos: function(coords) {
                        return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
                    },
                    _wrapCoords: function(coords) {
                        var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
                        newCoords.z = coords.z;
                        return newCoords;
                    },
                    _pxBoundsToTileRange: function(bounds) {
                        var tileSize = this.getTileSize();
                        return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([ 1, 1 ]));
                    },
                    _noTilesToLoad: function() {
                        for (var key in this._tiles) if (!this._tiles[key].loaded) return false;
                        return true;
                    }
                });
                function gridLayer(options) {
                    return new GridLayer(options);
                }
                var TileLayer = GridLayer.extend({
                    options: {
                        minZoom: 0,
                        maxZoom: 18,
                        subdomains: "abc",
                        errorTileUrl: "",
                        zoomOffset: 0,
                        tms: false,
                        zoomReverse: false,
                        detectRetina: false,
                        crossOrigin: false,
                        referrerPolicy: false
                    },
                    initialize: function(url, options) {
                        this._url = url;
                        options = setOptions(this, options);
                        if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
                            options.tileSize = Math.floor(options.tileSize / 2);
                            if (!options.zoomReverse) {
                                options.zoomOffset++;
                                options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
                            } else {
                                options.zoomOffset--;
                                options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
                            }
                            options.minZoom = Math.max(0, options.minZoom);
                        } else if (!options.zoomReverse) options.maxZoom = Math.max(options.minZoom, options.maxZoom); else options.minZoom = Math.min(options.maxZoom, options.minZoom);
                        if (typeof options.subdomains === "string") options.subdomains = options.subdomains.split("");
                        this.on("tileunload", this._onTileRemove);
                    },
                    setUrl: function(url, noRedraw) {
                        if (this._url === url && noRedraw === void 0) noRedraw = true;
                        this._url = url;
                        if (!noRedraw) this.redraw();
                        return this;
                    },
                    createTile: function(coords, done) {
                        var tile = document.createElement("img");
                        on(tile, "load", bind(this._tileOnLoad, this, done, tile));
                        on(tile, "error", bind(this._tileOnError, this, done, tile));
                        if (this.options.crossOrigin || this.options.crossOrigin === "") tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
                        if (typeof this.options.referrerPolicy === "string") tile.referrerPolicy = this.options.referrerPolicy;
                        tile.alt = "";
                        tile.src = this.getTileUrl(coords);
                        return tile;
                    },
                    getTileUrl: function(coords) {
                        var data = {
                            r: Browser.retina ? "@2x" : "",
                            s: this._getSubdomain(coords),
                            x: coords.x,
                            y: coords.y,
                            z: this._getZoomForUrl()
                        };
                        if (this._map && !this._map.options.crs.infinite) {
                            var invertedY = this._globalTileRange.max.y - coords.y;
                            if (this.options.tms) data["y"] = invertedY;
                            data["-y"] = invertedY;
                        }
                        return template(this._url, extend(data, this.options));
                    },
                    _tileOnLoad: function(done, tile) {
                        if (Browser.ielt9) setTimeout(bind(done, this, null, tile), 0); else done(null, tile);
                    },
                    _tileOnError: function(done, tile, e) {
                        var errorUrl = this.options.errorTileUrl;
                        if (errorUrl && tile.getAttribute("src") !== errorUrl) tile.src = errorUrl;
                        done(e, tile);
                    },
                    _onTileRemove: function(e) {
                        e.tile.onload = null;
                    },
                    _getZoomForUrl: function() {
                        var zoom = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
                        if (zoomReverse) zoom = maxZoom - zoom;
                        return zoom + zoomOffset;
                    },
                    _getSubdomain: function(tilePoint) {
                        var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
                        return this.options.subdomains[index];
                    },
                    _abortLoading: function() {
                        var i, tile;
                        for (i in this._tiles) if (this._tiles[i].coords.z !== this._tileZoom) {
                            tile = this._tiles[i].el;
                            tile.onload = falseFn;
                            tile.onerror = falseFn;
                            if (!tile.complete) {
                                tile.src = emptyImageUrl;
                                var coords = this._tiles[i].coords;
                                remove(tile);
                                delete this._tiles[i];
                                this.fire("tileabort", {
                                    tile,
                                    coords
                                });
                            }
                        }
                    },
                    _removeTile: function(key) {
                        var tile = this._tiles[key];
                        if (!tile) return;
                        tile.el.setAttribute("src", emptyImageUrl);
                        return GridLayer.prototype._removeTile.call(this, key);
                    },
                    _tileReady: function(coords, err, tile) {
                        if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) return;
                        return GridLayer.prototype._tileReady.call(this, coords, err, tile);
                    }
                });
                function tileLayer(url, options) {
                    return new TileLayer(url, options);
                }
                var TileLayerWMS = TileLayer.extend({
                    defaultWmsParams: {
                        service: "WMS",
                        request: "GetMap",
                        layers: "",
                        styles: "",
                        format: "image/jpeg",
                        transparent: false,
                        version: "1.1.1"
                    },
                    options: {
                        crs: null,
                        uppercase: false
                    },
                    initialize: function(url, options) {
                        this._url = url;
                        var wmsParams = extend({}, this.defaultWmsParams);
                        for (var i in options) if (!(i in this.options)) wmsParams[i] = options[i];
                        options = setOptions(this, options);
                        var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
                        var tileSize = this.getTileSize();
                        wmsParams.width = tileSize.x * realRetina;
                        wmsParams.height = tileSize.y * realRetina;
                        this.wmsParams = wmsParams;
                    },
                    onAdd: function(map) {
                        this._crs = this.options.crs || map.options.crs;
                        this._wmsVersion = parseFloat(this.wmsParams.version);
                        var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
                        this.wmsParams[projectionKey] = this._crs.code;
                        TileLayer.prototype.onAdd.call(this, map);
                    },
                    getTileUrl: function(coords) {
                        var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [ min.y, min.x, max.y, max.x ] : [ min.x, min.y, max.x, max.y ]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
                        return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
                    },
                    setParams: function(params, noRedraw) {
                        extend(this.wmsParams, params);
                        if (!noRedraw) this.redraw();
                        return this;
                    }
                });
                function tileLayerWMS(url, options) {
                    return new TileLayerWMS(url, options);
                }
                TileLayer.WMS = TileLayerWMS;
                tileLayer.wms = tileLayerWMS;
                var Renderer = Layer.extend({
                    options: {
                        padding: .1
                    },
                    initialize: function(options) {
                        setOptions(this, options);
                        stamp(this);
                        this._layers = this._layers || {};
                    },
                    onAdd: function() {
                        if (!this._container) {
                            this._initContainer();
                            addClass(this._container, "leaflet-zoom-animated");
                        }
                        this.getPane().appendChild(this._container);
                        this._update();
                        this.on("update", this._updatePaths, this);
                    },
                    onRemove: function() {
                        this.off("update", this._updatePaths, this);
                        this._destroyContainer();
                    },
                    getEvents: function() {
                        var events = {
                            viewreset: this._reset,
                            zoom: this._onZoom,
                            moveend: this._update,
                            zoomend: this._onZoomEnd
                        };
                        if (this._zoomAnimated) events.zoomanim = this._onAnimZoom;
                        return events;
                    },
                    _onAnimZoom: function(ev) {
                        this._updateTransform(ev.center, ev.zoom);
                    },
                    _onZoom: function() {
                        this._updateTransform(this._map.getCenter(), this._map.getZoom());
                    },
                    _updateTransform: function(center, zoom) {
                        var scale = this._map.getZoomScale(zoom, this._zoom), viewHalf = this._map.getSize().multiplyBy(.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom), topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));
                        if (Browser.any3d) setTransform(this._container, topLeftOffset, scale); else setPosition(this._container, topLeftOffset);
                    },
                    _reset: function() {
                        this._update();
                        this._updateTransform(this._center, this._zoom);
                        for (var id in this._layers) this._layers[id]._reset();
                    },
                    _onZoomEnd: function() {
                        for (var id in this._layers) this._layers[id]._project();
                    },
                    _updatePaths: function() {
                        for (var id in this._layers) this._layers[id]._update();
                    },
                    _update: function() {
                        var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
                        this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
                        this._center = this._map.getCenter();
                        this._zoom = this._map.getZoom();
                    }
                });
                var Canvas = Renderer.extend({
                    options: {
                        tolerance: 0
                    },
                    getEvents: function() {
                        var events = Renderer.prototype.getEvents.call(this);
                        events.viewprereset = this._onViewPreReset;
                        return events;
                    },
                    _onViewPreReset: function() {
                        this._postponeUpdatePaths = true;
                    },
                    onAdd: function() {
                        Renderer.prototype.onAdd.call(this);
                        this._draw();
                    },
                    _initContainer: function() {
                        var container = this._container = document.createElement("canvas");
                        on(container, "mousemove", this._onMouseMove, this);
                        on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
                        on(container, "mouseout", this._handleMouseOut, this);
                        container["_leaflet_disable_events"] = true;
                        this._ctx = container.getContext("2d");
                    },
                    _destroyContainer: function() {
                        cancelAnimFrame(this._redrawRequest);
                        delete this._ctx;
                        remove(this._container);
                        off(this._container);
                        delete this._container;
                    },
                    _updatePaths: function() {
                        if (this._postponeUpdatePaths) return;
                        var layer;
                        this._redrawBounds = null;
                        for (var id in this._layers) {
                            layer = this._layers[id];
                            layer._update();
                        }
                        this._redraw();
                    },
                    _update: function() {
                        if (this._map._animatingZoom && this._bounds) return;
                        Renderer.prototype._update.call(this);
                        var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
                        setPosition(container, b.min);
                        container.width = m * size.x;
                        container.height = m * size.y;
                        container.style.width = size.x + "px";
                        container.style.height = size.y + "px";
                        if (Browser.retina) this._ctx.scale(2, 2);
                        this._ctx.translate(-b.min.x, -b.min.y);
                        this.fire("update");
                    },
                    _reset: function() {
                        Renderer.prototype._reset.call(this);
                        if (this._postponeUpdatePaths) {
                            this._postponeUpdatePaths = false;
                            this._updatePaths();
                        }
                    },
                    _initPath: function(layer) {
                        this._updateDashArray(layer);
                        this._layers[stamp(layer)] = layer;
                        var order = layer._order = {
                            layer,
                            prev: this._drawLast,
                            next: null
                        };
                        if (this._drawLast) this._drawLast.next = order;
                        this._drawLast = order;
                        this._drawFirst = this._drawFirst || this._drawLast;
                    },
                    _addPath: function(layer) {
                        this._requestRedraw(layer);
                    },
                    _removePath: function(layer) {
                        var order = layer._order;
                        var next = order.next;
                        var prev = order.prev;
                        if (next) next.prev = prev; else this._drawLast = prev;
                        if (prev) prev.next = next; else this._drawFirst = next;
                        delete layer._order;
                        delete this._layers[stamp(layer)];
                        this._requestRedraw(layer);
                    },
                    _updatePath: function(layer) {
                        this._extendRedrawBounds(layer);
                        layer._project();
                        layer._update();
                        this._requestRedraw(layer);
                    },
                    _updateStyle: function(layer) {
                        this._updateDashArray(layer);
                        this._requestRedraw(layer);
                    },
                    _updateDashArray: function(layer) {
                        if (typeof layer.options.dashArray === "string") {
                            var dashValue, i, parts = layer.options.dashArray.split(/[, ]+/), dashArray = [];
                            for (i = 0; i < parts.length; i++) {
                                dashValue = Number(parts[i]);
                                if (isNaN(dashValue)) return;
                                dashArray.push(dashValue);
                            }
                            layer.options._dashArray = dashArray;
                        } else layer.options._dashArray = layer.options.dashArray;
                    },
                    _requestRedraw: function(layer) {
                        if (!this._map) return;
                        this._extendRedrawBounds(layer);
                        this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
                    },
                    _extendRedrawBounds: function(layer) {
                        if (layer._pxBounds) {
                            var padding = (layer.options.weight || 0) + 1;
                            this._redrawBounds = this._redrawBounds || new Bounds;
                            this._redrawBounds.extend(layer._pxBounds.min.subtract([ padding, padding ]));
                            this._redrawBounds.extend(layer._pxBounds.max.add([ padding, padding ]));
                        }
                    },
                    _redraw: function() {
                        this._redrawRequest = null;
                        if (this._redrawBounds) {
                            this._redrawBounds.min._floor();
                            this._redrawBounds.max._ceil();
                        }
                        this._clear();
                        this._draw();
                        this._redrawBounds = null;
                    },
                    _clear: function() {
                        var bounds = this._redrawBounds;
                        if (bounds) {
                            var size = bounds.getSize();
                            this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
                        } else {
                            this._ctx.save();
                            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
                            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
                            this._ctx.restore();
                        }
                    },
                    _draw: function() {
                        var layer, bounds = this._redrawBounds;
                        this._ctx.save();
                        if (bounds) {
                            var size = bounds.getSize();
                            this._ctx.beginPath();
                            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
                            this._ctx.clip();
                        }
                        this._drawing = true;
                        for (var order = this._drawFirst; order; order = order.next) {
                            layer = order.layer;
                            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) layer._updatePath();
                        }
                        this._drawing = false;
                        this._ctx.restore();
                    },
                    _updatePoly: function(layer, closed) {
                        if (!this._drawing) return;
                        var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
                        if (!len) return;
                        ctx.beginPath();
                        for (i = 0; i < len; i++) {
                            for (j = 0, len2 = parts[i].length; j < len2; j++) {
                                p = parts[i][j];
                                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
                            }
                            if (closed) ctx.closePath();
                        }
                        this._fillStroke(ctx, layer);
                    },
                    _updateCircle: function(layer) {
                        if (!this._drawing || layer._empty()) return;
                        var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
                        if (s !== 1) {
                            ctx.save();
                            ctx.scale(1, s);
                        }
                        ctx.beginPath();
                        ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
                        if (s !== 1) ctx.restore();
                        this._fillStroke(ctx, layer);
                    },
                    _fillStroke: function(ctx, layer) {
                        var options = layer.options;
                        if (options.fill) {
                            ctx.globalAlpha = options.fillOpacity;
                            ctx.fillStyle = options.fillColor || options.color;
                            ctx.fill(options.fillRule || "evenodd");
                        }
                        if (options.stroke && options.weight !== 0) {
                            if (ctx.setLineDash) ctx.setLineDash(layer.options && layer.options._dashArray || []);
                            ctx.globalAlpha = options.opacity;
                            ctx.lineWidth = options.weight;
                            ctx.strokeStyle = options.color;
                            ctx.lineCap = options.lineCap;
                            ctx.lineJoin = options.lineJoin;
                            ctx.stroke();
                        }
                    },
                    _onClick: function(e) {
                        var layer, clickedLayer, point = this._map.mouseEventToLayerPoint(e);
                        for (var order = this._drawFirst; order; order = order.next) {
                            layer = order.layer;
                            if (layer.options.interactive && layer._containsPoint(point)) if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) clickedLayer = layer;
                        }
                        this._fireEvent(clickedLayer ? [ clickedLayer ] : false, e);
                    },
                    _onMouseMove: function(e) {
                        if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) return;
                        var point = this._map.mouseEventToLayerPoint(e);
                        this._handleMouseHover(e, point);
                    },
                    _handleMouseOut: function(e) {
                        var layer = this._hoveredLayer;
                        if (layer) {
                            removeClass(this._container, "leaflet-interactive");
                            this._fireEvent([ layer ], e, "mouseout");
                            this._hoveredLayer = null;
                            this._mouseHoverThrottled = false;
                        }
                    },
                    _handleMouseHover: function(e, point) {
                        if (this._mouseHoverThrottled) return;
                        var layer, candidateHoveredLayer;
                        for (var order = this._drawFirst; order; order = order.next) {
                            layer = order.layer;
                            if (layer.options.interactive && layer._containsPoint(point)) candidateHoveredLayer = layer;
                        }
                        if (candidateHoveredLayer !== this._hoveredLayer) {
                            this._handleMouseOut(e);
                            if (candidateHoveredLayer) {
                                addClass(this._container, "leaflet-interactive");
                                this._fireEvent([ candidateHoveredLayer ], e, "mouseover");
                                this._hoveredLayer = candidateHoveredLayer;
                            }
                        }
                        this._fireEvent(this._hoveredLayer ? [ this._hoveredLayer ] : false, e);
                        this._mouseHoverThrottled = true;
                        setTimeout(bind((function() {
                            this._mouseHoverThrottled = false;
                        }), this), 32);
                    },
                    _fireEvent: function(layers, e, type) {
                        this._map._fireDOMEvent(e, type || e.type, layers);
                    },
                    _bringToFront: function(layer) {
                        var order = layer._order;
                        if (!order) return;
                        var next = order.next;
                        var prev = order.prev;
                        if (next) next.prev = prev; else return;
                        if (prev) prev.next = next; else if (next) this._drawFirst = next;
                        order.prev = this._drawLast;
                        this._drawLast.next = order;
                        order.next = null;
                        this._drawLast = order;
                        this._requestRedraw(layer);
                    },
                    _bringToBack: function(layer) {
                        var order = layer._order;
                        if (!order) return;
                        var next = order.next;
                        var prev = order.prev;
                        if (prev) prev.next = next; else return;
                        if (next) next.prev = prev; else if (prev) this._drawLast = prev;
                        order.prev = null;
                        order.next = this._drawFirst;
                        this._drawFirst.prev = order;
                        this._drawFirst = order;
                        this._requestRedraw(layer);
                    }
                });
                function canvas(options) {
                    return Browser.canvas ? new Canvas(options) : null;
                }
                var vmlCreate = function() {
                    try {
                        document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
                        return function(name) {
                            return document.createElement("<lvml:" + name + ' class="lvml">');
                        };
                    } catch (e) {}
                    return function(name) {
                        return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                    };
                }();
                var vmlMixin = {
                    _initContainer: function() {
                        this._container = create$1("div", "leaflet-vml-container");
                    },
                    _update: function() {
                        if (this._map._animatingZoom) return;
                        Renderer.prototype._update.call(this);
                        this.fire("update");
                    },
                    _initPath: function(layer) {
                        var container = layer._container = vmlCreate("shape");
                        addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
                        container.coordsize = "1 1";
                        layer._path = vmlCreate("path");
                        container.appendChild(layer._path);
                        this._updateStyle(layer);
                        this._layers[stamp(layer)] = layer;
                    },
                    _addPath: function(layer) {
                        var container = layer._container;
                        this._container.appendChild(container);
                        if (layer.options.interactive) layer.addInteractiveTarget(container);
                    },
                    _removePath: function(layer) {
                        var container = layer._container;
                        remove(container);
                        layer.removeInteractiveTarget(container);
                        delete this._layers[stamp(layer)];
                    },
                    _updateStyle: function(layer) {
                        var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
                        container.stroked = !!options.stroke;
                        container.filled = !!options.fill;
                        if (options.stroke) {
                            if (!stroke) stroke = layer._stroke = vmlCreate("stroke");
                            container.appendChild(stroke);
                            stroke.weight = options.weight + "px";
                            stroke.color = options.color;
                            stroke.opacity = options.opacity;
                            if (options.dashArray) stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " "); else stroke.dashStyle = "";
                            stroke.endcap = options.lineCap.replace("butt", "flat");
                            stroke.joinstyle = options.lineJoin;
                        } else if (stroke) {
                            container.removeChild(stroke);
                            layer._stroke = null;
                        }
                        if (options.fill) {
                            if (!fill) fill = layer._fill = vmlCreate("fill");
                            container.appendChild(fill);
                            fill.color = options.fillColor || options.color;
                            fill.opacity = options.fillOpacity;
                        } else if (fill) {
                            container.removeChild(fill);
                            layer._fill = null;
                        }
                    },
                    _updateCircle: function(layer) {
                        var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
                        this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
                    },
                    _setPath: function(layer, path) {
                        layer._path.v = path;
                    },
                    _bringToFront: function(layer) {
                        toFront(layer._container);
                    },
                    _bringToBack: function(layer) {
                        toBack(layer._container);
                    }
                };
                var create = Browser.vml ? vmlCreate : svgCreate;
                var SVG = Renderer.extend({
                    _initContainer: function() {
                        this._container = create("svg");
                        this._container.setAttribute("pointer-events", "none");
                        this._rootGroup = create("g");
                        this._container.appendChild(this._rootGroup);
                    },
                    _destroyContainer: function() {
                        remove(this._container);
                        off(this._container);
                        delete this._container;
                        delete this._rootGroup;
                        delete this._svgSize;
                    },
                    _update: function() {
                        if (this._map._animatingZoom && this._bounds) return;
                        Renderer.prototype._update.call(this);
                        var b = this._bounds, size = b.getSize(), container = this._container;
                        if (!this._svgSize || !this._svgSize.equals(size)) {
                            this._svgSize = size;
                            container.setAttribute("width", size.x);
                            container.setAttribute("height", size.y);
                        }
                        setPosition(container, b.min);
                        container.setAttribute("viewBox", [ b.min.x, b.min.y, size.x, size.y ].join(" "));
                        this.fire("update");
                    },
                    _initPath: function(layer) {
                        var path = layer._path = create("path");
                        if (layer.options.className) addClass(path, layer.options.className);
                        if (layer.options.interactive) addClass(path, "leaflet-interactive");
                        this._updateStyle(layer);
                        this._layers[stamp(layer)] = layer;
                    },
                    _addPath: function(layer) {
                        if (!this._rootGroup) this._initContainer();
                        this._rootGroup.appendChild(layer._path);
                        layer.addInteractiveTarget(layer._path);
                    },
                    _removePath: function(layer) {
                        remove(layer._path);
                        layer.removeInteractiveTarget(layer._path);
                        delete this._layers[stamp(layer)];
                    },
                    _updatePath: function(layer) {
                        layer._project();
                        layer._update();
                    },
                    _updateStyle: function(layer) {
                        var path = layer._path, options = layer.options;
                        if (!path) return;
                        if (options.stroke) {
                            path.setAttribute("stroke", options.color);
                            path.setAttribute("stroke-opacity", options.opacity);
                            path.setAttribute("stroke-width", options.weight);
                            path.setAttribute("stroke-linecap", options.lineCap);
                            path.setAttribute("stroke-linejoin", options.lineJoin);
                            if (options.dashArray) path.setAttribute("stroke-dasharray", options.dashArray); else path.removeAttribute("stroke-dasharray");
                            if (options.dashOffset) path.setAttribute("stroke-dashoffset", options.dashOffset); else path.removeAttribute("stroke-dashoffset");
                        } else path.setAttribute("stroke", "none");
                        if (options.fill) {
                            path.setAttribute("fill", options.fillColor || options.color);
                            path.setAttribute("fill-opacity", options.fillOpacity);
                            path.setAttribute("fill-rule", options.fillRule || "evenodd");
                        } else path.setAttribute("fill", "none");
                    },
                    _updatePoly: function(layer, closed) {
                        this._setPath(layer, pointsToPath(layer._parts, closed));
                    },
                    _updateCircle: function(layer) {
                        var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
                        var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
                        this._setPath(layer, d);
                    },
                    _setPath: function(layer, path) {
                        layer._path.setAttribute("d", path);
                    },
                    _bringToFront: function(layer) {
                        toFront(layer._path);
                    },
                    _bringToBack: function(layer) {
                        toBack(layer._path);
                    }
                });
                if (Browser.vml) SVG.include(vmlMixin);
                function svg(options) {
                    return Browser.svg || Browser.vml ? new SVG(options) : null;
                }
                Map.include({
                    getRenderer: function(layer) {
                        var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
                        if (!renderer) renderer = this._renderer = this._createRenderer();
                        if (!this.hasLayer(renderer)) this.addLayer(renderer);
                        return renderer;
                    },
                    _getPaneRenderer: function(name) {
                        if (name === "overlayPane" || name === void 0) return false;
                        var renderer = this._paneRenderers[name];
                        if (renderer === void 0) {
                            renderer = this._createRenderer({
                                pane: name
                            });
                            this._paneRenderers[name] = renderer;
                        }
                        return renderer;
                    },
                    _createRenderer: function(options) {
                        return this.options.preferCanvas && canvas(options) || svg(options);
                    }
                });
                var Rectangle = Polygon.extend({
                    initialize: function(latLngBounds, options) {
                        Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
                    },
                    setBounds: function(latLngBounds) {
                        return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
                    },
                    _boundsToLatLngs: function(latLngBounds) {
                        latLngBounds = toLatLngBounds(latLngBounds);
                        return [ latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast() ];
                    }
                });
                function rectangle(latLngBounds, options) {
                    return new Rectangle(latLngBounds, options);
                }
                SVG.create = create;
                SVG.pointsToPath = pointsToPath;
                GeoJSON.geometryToLayer = geometryToLayer;
                GeoJSON.coordsToLatLng = coordsToLatLng;
                GeoJSON.coordsToLatLngs = coordsToLatLngs;
                GeoJSON.latLngToCoords = latLngToCoords;
                GeoJSON.latLngsToCoords = latLngsToCoords;
                GeoJSON.getFeature = getFeature;
                GeoJSON.asFeature = asFeature;
                Map.mergeOptions({
                    boxZoom: true
                });
                var BoxZoom = Handler.extend({
                    initialize: function(map) {
                        this._map = map;
                        this._container = map._container;
                        this._pane = map._panes.overlayPane;
                        this._resetStateTimeout = 0;
                        map.on("unload", this._destroy, this);
                    },
                    addHooks: function() {
                        on(this._container, "mousedown", this._onMouseDown, this);
                    },
                    removeHooks: function() {
                        off(this._container, "mousedown", this._onMouseDown, this);
                    },
                    moved: function() {
                        return this._moved;
                    },
                    _destroy: function() {
                        remove(this._pane);
                        delete this._pane;
                    },
                    _resetState: function() {
                        this._resetStateTimeout = 0;
                        this._moved = false;
                    },
                    _clearDeferredResetState: function() {
                        if (this._resetStateTimeout !== 0) {
                            clearTimeout(this._resetStateTimeout);
                            this._resetStateTimeout = 0;
                        }
                    },
                    _onMouseDown: function(e) {
                        if (!e.shiftKey || e.which !== 1 && e.button !== 1) return false;
                        this._clearDeferredResetState();
                        this._resetState();
                        disableTextSelection();
                        disableImageDrag();
                        this._startPoint = this._map.mouseEventToContainerPoint(e);
                        on(document, {
                            contextmenu: stop,
                            mousemove: this._onMouseMove,
                            mouseup: this._onMouseUp,
                            keydown: this._onKeyDown
                        }, this);
                    },
                    _onMouseMove: function(e) {
                        if (!this._moved) {
                            this._moved = true;
                            this._box = create$1("div", "leaflet-zoom-box", this._container);
                            addClass(this._container, "leaflet-crosshair");
                            this._map.fire("boxzoomstart");
                        }
                        this._point = this._map.mouseEventToContainerPoint(e);
                        var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
                        setPosition(this._box, bounds.min);
                        this._box.style.width = size.x + "px";
                        this._box.style.height = size.y + "px";
                    },
                    _finish: function() {
                        if (this._moved) {
                            remove(this._box);
                            removeClass(this._container, "leaflet-crosshair");
                        }
                        enableTextSelection();
                        enableImageDrag();
                        off(document, {
                            contextmenu: stop,
                            mousemove: this._onMouseMove,
                            mouseup: this._onMouseUp,
                            keydown: this._onKeyDown
                        }, this);
                    },
                    _onMouseUp: function(e) {
                        if (e.which !== 1 && e.button !== 1) return;
                        this._finish();
                        if (!this._moved) return;
                        this._clearDeferredResetState();
                        this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
                        var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
                        this._map.fitBounds(bounds).fire("boxzoomend", {
                            boxZoomBounds: bounds
                        });
                    },
                    _onKeyDown: function(e) {
                        if (e.keyCode === 27) {
                            this._finish();
                            this._clearDeferredResetState();
                            this._resetState();
                        }
                    }
                });
                Map.addInitHook("addHandler", "boxZoom", BoxZoom);
                Map.mergeOptions({
                    doubleClickZoom: true
                });
                var DoubleClickZoom = Handler.extend({
                    addHooks: function() {
                        this._map.on("dblclick", this._onDoubleClick, this);
                    },
                    removeHooks: function() {
                        this._map.off("dblclick", this._onDoubleClick, this);
                    },
                    _onDoubleClick: function(e) {
                        var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
                        if (map.options.doubleClickZoom === "center") map.setZoom(zoom); else map.setZoomAround(e.containerPoint, zoom);
                    }
                });
                Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
                Map.mergeOptions({
                    dragging: true,
                    inertia: true,
                    inertiaDeceleration: 3400,
                    inertiaMaxSpeed: 1 / 0,
                    easeLinearity: .2,
                    worldCopyJump: false,
                    maxBoundsViscosity: 0
                });
                var Drag = Handler.extend({
                    addHooks: function() {
                        if (!this._draggable) {
                            var map = this._map;
                            this._draggable = new Draggable(map._mapPane, map._container);
                            this._draggable.on({
                                dragstart: this._onDragStart,
                                drag: this._onDrag,
                                dragend: this._onDragEnd
                            }, this);
                            this._draggable.on("predrag", this._onPreDragLimit, this);
                            if (map.options.worldCopyJump) {
                                this._draggable.on("predrag", this._onPreDragWrap, this);
                                map.on("zoomend", this._onZoomEnd, this);
                                map.whenReady(this._onZoomEnd, this);
                            }
                        }
                        addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
                        this._draggable.enable();
                        this._positions = [];
                        this._times = [];
                    },
                    removeHooks: function() {
                        removeClass(this._map._container, "leaflet-grab");
                        removeClass(this._map._container, "leaflet-touch-drag");
                        this._draggable.disable();
                    },
                    moved: function() {
                        return this._draggable && this._draggable._moved;
                    },
                    moving: function() {
                        return this._draggable && this._draggable._moving;
                    },
                    _onDragStart: function() {
                        var map = this._map;
                        map._stop();
                        if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
                            var bounds = toLatLngBounds(this._map.options.maxBounds);
                            this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
                            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
                        } else this._offsetLimit = null;
                        map.fire("movestart").fire("dragstart");
                        if (map.options.inertia) {
                            this._positions = [];
                            this._times = [];
                        }
                    },
                    _onDrag: function(e) {
                        if (this._map.options.inertia) {
                            var time = this._lastTime = +new Date, pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
                            this._positions.push(pos);
                            this._times.push(time);
                            this._prunePositions(time);
                        }
                        this._map.fire("move", e).fire("drag", e);
                    },
                    _prunePositions: function(time) {
                        while (this._positions.length > 1 && time - this._times[0] > 50) {
                            this._positions.shift();
                            this._times.shift();
                        }
                    },
                    _onZoomEnd: function() {
                        var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([ 0, 0 ]);
                        this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
                        this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
                    },
                    _viscousLimit: function(value, threshold) {
                        return value - (value - threshold) * this._viscosity;
                    },
                    _onPreDragLimit: function() {
                        if (!this._viscosity || !this._offsetLimit) return;
                        var offset = this._draggable._newPos.subtract(this._draggable._startPos);
                        var limit = this._offsetLimit;
                        if (offset.x < limit.min.x) offset.x = this._viscousLimit(offset.x, limit.min.x);
                        if (offset.y < limit.min.y) offset.y = this._viscousLimit(offset.y, limit.min.y);
                        if (offset.x > limit.max.x) offset.x = this._viscousLimit(offset.x, limit.max.x);
                        if (offset.y > limit.max.y) offset.y = this._viscousLimit(offset.y, limit.max.y);
                        this._draggable._newPos = this._draggable._startPos.add(offset);
                    },
                    _onPreDragWrap: function() {
                        var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
                        this._draggable._absPos = this._draggable._newPos.clone();
                        this._draggable._newPos.x = newX;
                    },
                    _onDragEnd: function(e) {
                        var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
                        map.fire("dragend", e);
                        if (noInertia) map.fire("moveend"); else {
                            this._prunePositions(+new Date);
                            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([ 0, 0 ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
                            if (!offset.x && !offset.y) map.fire("moveend"); else {
                                offset = map._limitOffset(offset, map.options.maxBounds);
                                requestAnimFrame((function() {
                                    map.panBy(offset, {
                                        duration: decelerationDuration,
                                        easeLinearity: ease,
                                        noMoveStart: true,
                                        animate: true
                                    });
                                }));
                            }
                        }
                    }
                });
                Map.addInitHook("addHandler", "dragging", Drag);
                Map.mergeOptions({
                    keyboard: true,
                    keyboardPanDelta: 80
                });
                var Keyboard = Handler.extend({
                    keyCodes: {
                        left: [ 37 ],
                        right: [ 39 ],
                        down: [ 40 ],
                        up: [ 38 ],
                        zoomIn: [ 187, 107, 61, 171 ],
                        zoomOut: [ 189, 109, 54, 173 ]
                    },
                    initialize: function(map) {
                        this._map = map;
                        this._setPanDelta(map.options.keyboardPanDelta);
                        this._setZoomDelta(map.options.zoomDelta);
                    },
                    addHooks: function() {
                        var container = this._map._container;
                        if (container.tabIndex <= 0) container.tabIndex = "0";
                        on(container, {
                            focus: this._onFocus,
                            blur: this._onBlur,
                            mousedown: this._onMouseDown
                        }, this);
                        this._map.on({
                            focus: this._addHooks,
                            blur: this._removeHooks
                        }, this);
                    },
                    removeHooks: function() {
                        this._removeHooks();
                        off(this._map._container, {
                            focus: this._onFocus,
                            blur: this._onBlur,
                            mousedown: this._onMouseDown
                        }, this);
                        this._map.off({
                            focus: this._addHooks,
                            blur: this._removeHooks
                        }, this);
                    },
                    _onMouseDown: function() {
                        if (this._focused) return;
                        var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
                        this._map._container.focus();
                        window.scrollTo(left, top);
                    },
                    _onFocus: function() {
                        this._focused = true;
                        this._map.fire("focus");
                    },
                    _onBlur: function() {
                        this._focused = false;
                        this._map.fire("blur");
                    },
                    _setPanDelta: function(panDelta) {
                        var i, len, keys = this._panKeys = {}, codes = this.keyCodes;
                        for (i = 0, len = codes.left.length; i < len; i++) keys[codes.left[i]] = [ -1 * panDelta, 0 ];
                        for (i = 0, len = codes.right.length; i < len; i++) keys[codes.right[i]] = [ panDelta, 0 ];
                        for (i = 0, len = codes.down.length; i < len; i++) keys[codes.down[i]] = [ 0, panDelta ];
                        for (i = 0, len = codes.up.length; i < len; i++) keys[codes.up[i]] = [ 0, -1 * panDelta ];
                    },
                    _setZoomDelta: function(zoomDelta) {
                        var i, len, keys = this._zoomKeys = {}, codes = this.keyCodes;
                        for (i = 0, len = codes.zoomIn.length; i < len; i++) keys[codes.zoomIn[i]] = zoomDelta;
                        for (i = 0, len = codes.zoomOut.length; i < len; i++) keys[codes.zoomOut[i]] = -zoomDelta;
                    },
                    _addHooks: function() {
                        on(document, "keydown", this._onKeyDown, this);
                    },
                    _removeHooks: function() {
                        off(document, "keydown", this._onKeyDown, this);
                    },
                    _onKeyDown: function(e) {
                        if (e.altKey || e.ctrlKey || e.metaKey) return;
                        var offset, key = e.keyCode, map = this._map;
                        if (key in this._panKeys) {
                            if (!map._panAnim || !map._panAnim._inProgress) {
                                offset = this._panKeys[key];
                                if (e.shiftKey) offset = toPoint(offset).multiplyBy(3);
                                if (map.options.maxBounds) offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
                                if (map.options.worldCopyJump) {
                                    var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
                                    map.panTo(newLatLng);
                                } else map.panBy(offset);
                            }
                        } else if (key in this._zoomKeys) map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]); else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) map.closePopup(); else return;
                        stop(e);
                    }
                });
                Map.addInitHook("addHandler", "keyboard", Keyboard);
                Map.mergeOptions({
                    scrollWheelZoom: true,
                    wheelDebounceTime: 40,
                    wheelPxPerZoomLevel: 60
                });
                var ScrollWheelZoom = Handler.extend({
                    addHooks: function() {
                        on(this._map._container, "wheel", this._onWheelScroll, this);
                        this._delta = 0;
                    },
                    removeHooks: function() {
                        off(this._map._container, "wheel", this._onWheelScroll, this);
                    },
                    _onWheelScroll: function(e) {
                        var delta = getWheelDelta(e);
                        var debounce = this._map.options.wheelDebounceTime;
                        this._delta += delta;
                        this._lastMousePos = this._map.mouseEventToContainerPoint(e);
                        if (!this._startTime) this._startTime = +new Date;
                        var left = Math.max(debounce - (+new Date - this._startTime), 0);
                        clearTimeout(this._timer);
                        this._timer = setTimeout(bind(this._performZoom, this), left);
                        stop(e);
                    },
                    _performZoom: function() {
                        var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;
                        map._stop();
                        var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
                        this._delta = 0;
                        this._startTime = null;
                        if (!delta) return;
                        if (map.options.scrollWheelZoom === "center") map.setZoom(zoom + delta); else map.setZoomAround(this._lastMousePos, zoom + delta);
                    }
                });
                Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
                var tapHoldDelay = 600;
                Map.mergeOptions({
                    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
                    tapTolerance: 15
                });
                var TapHold = Handler.extend({
                    addHooks: function() {
                        on(this._map._container, "touchstart", this._onDown, this);
                    },
                    removeHooks: function() {
                        off(this._map._container, "touchstart", this._onDown, this);
                    },
                    _onDown: function(e) {
                        clearTimeout(this._holdTimeout);
                        if (e.touches.length !== 1) return;
                        var first = e.touches[0];
                        this._startPos = this._newPos = new Point(first.clientX, first.clientY);
                        this._holdTimeout = setTimeout(bind((function() {
                            this._cancel();
                            if (!this._isTapValid()) return;
                            on(document, "touchend", preventDefault);
                            on(document, "touchend touchcancel", this._cancelClickPrevent);
                            this._simulateEvent("contextmenu", first);
                        }), this), tapHoldDelay);
                        on(document, "touchend touchcancel contextmenu", this._cancel, this);
                        on(document, "touchmove", this._onMove, this);
                    },
                    _cancelClickPrevent: function cancelClickPrevent() {
                        off(document, "touchend", preventDefault);
                        off(document, "touchend touchcancel", cancelClickPrevent);
                    },
                    _cancel: function() {
                        clearTimeout(this._holdTimeout);
                        off(document, "touchend touchcancel contextmenu", this._cancel, this);
                        off(document, "touchmove", this._onMove, this);
                    },
                    _onMove: function(e) {
                        var first = e.touches[0];
                        this._newPos = new Point(first.clientX, first.clientY);
                    },
                    _isTapValid: function() {
                        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
                    },
                    _simulateEvent: function(type, e) {
                        var simulatedEvent = new MouseEvent(type, {
                            bubbles: true,
                            cancelable: true,
                            view: window,
                            screenX: e.screenX,
                            screenY: e.screenY,
                            clientX: e.clientX,
                            clientY: e.clientY
                        });
                        simulatedEvent._simulated = true;
                        e.target.dispatchEvent(simulatedEvent);
                    }
                });
                Map.addInitHook("addHandler", "tapHold", TapHold);
                Map.mergeOptions({
                    touchZoom: Browser.touch,
                    bounceAtZoomLimits: true
                });
                var TouchZoom = Handler.extend({
                    addHooks: function() {
                        addClass(this._map._container, "leaflet-touch-zoom");
                        on(this._map._container, "touchstart", this._onTouchStart, this);
                    },
                    removeHooks: function() {
                        removeClass(this._map._container, "leaflet-touch-zoom");
                        off(this._map._container, "touchstart", this._onTouchStart, this);
                    },
                    _onTouchStart: function(e) {
                        var map = this._map;
                        if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) return;
                        var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
                        this._centerPoint = map.getSize()._divideBy(2);
                        this._startLatLng = map.containerPointToLatLng(this._centerPoint);
                        if (map.options.touchZoom !== "center") this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
                        this._startDist = p1.distanceTo(p2);
                        this._startZoom = map.getZoom();
                        this._moved = false;
                        this._zooming = true;
                        map._stop();
                        on(document, "touchmove", this._onTouchMove, this);
                        on(document, "touchend touchcancel", this._onTouchEnd, this);
                        preventDefault(e);
                    },
                    _onTouchMove: function(e) {
                        if (!e.touches || e.touches.length !== 2 || !this._zooming) return;
                        var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale = p1.distanceTo(p2) / this._startDist;
                        this._zoom = map.getScaleZoom(scale, this._startZoom);
                        if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) this._zoom = map._limitZoom(this._zoom);
                        if (map.options.touchZoom === "center") {
                            this._center = this._startLatLng;
                            if (scale === 1) return;
                        } else {
                            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
                            if (scale === 1 && delta.x === 0 && delta.y === 0) return;
                            this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
                        }
                        if (!this._moved) {
                            map._moveStart(true, false);
                            this._moved = true;
                        }
                        cancelAnimFrame(this._animRequest);
                        var moveFn = bind(map._move, map, this._center, this._zoom, {
                            pinch: true,
                            round: false
                        }, void 0);
                        this._animRequest = requestAnimFrame(moveFn, this, true);
                        preventDefault(e);
                    },
                    _onTouchEnd: function() {
                        if (!this._moved || !this._zooming) {
                            this._zooming = false;
                            return;
                        }
                        this._zooming = false;
                        cancelAnimFrame(this._animRequest);
                        off(document, "touchmove", this._onTouchMove, this);
                        off(document, "touchend touchcancel", this._onTouchEnd, this);
                        if (this._map.options.zoomAnimation) this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap); else this._map._resetView(this._center, this._map._limitZoom(this._zoom));
                    }
                });
                Map.addInitHook("addHandler", "touchZoom", TouchZoom);
                Map.BoxZoom = BoxZoom;
                Map.DoubleClickZoom = DoubleClickZoom;
                Map.Drag = Drag;
                Map.Keyboard = Keyboard;
                Map.ScrollWheelZoom = ScrollWheelZoom;
                Map.TapHold = TapHold;
                Map.TouchZoom = TouchZoom;
                exports.Bounds = Bounds;
                exports.Browser = Browser;
                exports.CRS = CRS;
                exports.Canvas = Canvas;
                exports.Circle = Circle;
                exports.CircleMarker = CircleMarker;
                exports.Class = Class;
                exports.Control = Control;
                exports.DivIcon = DivIcon;
                exports.DivOverlay = DivOverlay;
                exports.DomEvent = DomEvent;
                exports.DomUtil = DomUtil;
                exports.Draggable = Draggable;
                exports.Evented = Evented;
                exports.FeatureGroup = FeatureGroup;
                exports.GeoJSON = GeoJSON;
                exports.GridLayer = GridLayer;
                exports.Handler = Handler;
                exports.Icon = Icon;
                exports.ImageOverlay = ImageOverlay;
                exports.LatLng = LatLng;
                exports.LatLngBounds = LatLngBounds;
                exports.Layer = Layer;
                exports.LayerGroup = LayerGroup;
                exports.LineUtil = LineUtil;
                exports.Map = Map;
                exports.Marker = Marker;
                exports.Mixin = Mixin;
                exports.Path = Path;
                exports.Point = Point;
                exports.PolyUtil = PolyUtil;
                exports.Polygon = Polygon;
                exports.Polyline = Polyline;
                exports.Popup = Popup;
                exports.PosAnimation = PosAnimation;
                exports.Projection = index;
                exports.Rectangle = Rectangle;
                exports.Renderer = Renderer;
                exports.SVG = SVG;
                exports.SVGOverlay = SVGOverlay;
                exports.TileLayer = TileLayer;
                exports.Tooltip = Tooltip;
                exports.Transformation = Transformation;
                exports.Util = Util;
                exports.VideoOverlay = VideoOverlay;
                exports.bind = bind;
                exports.bounds = toBounds;
                exports.canvas = canvas;
                exports.circle = circle;
                exports.circleMarker = circleMarker;
                exports.control = control;
                exports.divIcon = divIcon;
                exports.extend = extend;
                exports.featureGroup = featureGroup;
                exports.geoJSON = geoJSON;
                exports.geoJson = geoJson;
                exports.gridLayer = gridLayer;
                exports.icon = icon;
                exports.imageOverlay = imageOverlay;
                exports.latLng = toLatLng;
                exports.latLngBounds = toLatLngBounds;
                exports.layerGroup = layerGroup;
                exports.map = createMap;
                exports.marker = marker;
                exports.point = toPoint;
                exports.polygon = polygon;
                exports.polyline = polyline;
                exports.popup = popup;
                exports.rectangle = rectangle;
                exports.setOptions = setOptions;
                exports.stamp = stamp;
                exports.svg = svg;
                exports.svgOverlay = svgOverlay;
                exports.tileLayer = tileLayer;
                exports.tooltip = tooltip;
                exports.transformation = toTransformation;
                exports.version = version;
                exports.videoOverlay = videoOverlay;
                var oldL = window.L;
                exports.noConflict = function() {
                    window.L = oldL;
                    return this;
                };
                window.L = exports;
            }));
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        "use strict";
        const modules_flsModules = {};
        let _slideUp = (target, duration = 500, direction = "vertical", showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                if (direction === "vertical") {
                    target.style.transitionProperty = "height, margin, padding";
                    target.style.height = `${target.offsetHeight}px`;
                } else {
                    target.style.transitionProperty = "width, margin, padding";
                    target.style.width = `${target.offsetWidth}px`;
                }
                target.style.transitionDuration = duration + "ms";
                target.offsetHeight;
                target.style.overflow = "hidden";
                if (direction === "vertical") {
                    target.style.height = showmore ? `${showmore}px` : `0px`;
                    target.style.paddingTop = 0;
                    target.style.paddingBottom = 0;
                    target.style.marginTop = 0;
                    target.style.marginBottom = 0;
                } else {
                    target.style.width = showmore ? `${showmore}px` : `0px`;
                    target.style.paddingLeft = 0;
                    target.style.paddingRight = 0;
                    target.style.marginLeft = 0;
                    target.style.marginRight = 0;
                }
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    if (direction === "vertical") {
                        !showmore ? target.style.removeProperty("height") : null;
                        target.style.removeProperty("padding-top");
                        target.style.removeProperty("padding-bottom");
                        target.style.removeProperty("margin-top");
                        target.style.removeProperty("margin-bottom");
                    } else {
                        !showmore ? target.style.removeProperty("width") : null;
                        target.style.removeProperty("padding-left");
                        target.style.removeProperty("padding-right");
                        target.style.removeProperty("margin-left");
                        target.style.removeProperty("margin-right");
                    }
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideDown = (target, duration = 500, direction = "vertical", showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty(direction === "vertical" ? "height" : "width") : null;
                let size = direction === "vertical" ? target.offsetHeight : target.offsetWidth;
                target.style.overflow = "hidden";
                if (direction === "vertical") {
                    target.style.height = showmore ? `${showmore}px` : `0px`;
                    target.style.paddingTop = 0;
                    target.style.paddingBottom = 0;
                    target.style.marginTop = 0;
                    target.style.marginBottom = 0;
                } else {
                    target.style.width = showmore ? `${showmore}px` : `0px`;
                    target.style.paddingLeft = 0;
                    target.style.paddingRight = 0;
                    target.style.marginLeft = 0;
                    target.style.marginRight = 0;
                }
                target.offsetHeight;
                target.style.transitionProperty = direction === "vertical" ? "height, margin, padding" : "width, margin, padding";
                target.style.transitionDuration = duration + "ms";
                if (direction === "vertical") {
                    target.style.height = size + "px";
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                } else {
                    target.style.width = size + "px";
                    target.style.removeProperty("padding-left");
                    target.style.removeProperty("padding-right");
                    target.style.removeProperty("margin-left");
                    target.style.removeProperty("margin-right");
                }
                window.setTimeout((() => {
                    direction === "vertical" ? target.style.removeProperty("height") : target.style.removeProperty("width");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideToggle = (target, duration = 500, direction = "vertical") => {
            if (target.hidden) return _slideDown(target, duration, direction); else return _slideUp(target, duration, direction);
        };
        let bodyLockStatus = true;
        let isBodyLocked = false;
        let bodyUnlock = (delay = 500) => {
            if (bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    lockPaddingElements.forEach((lockPaddingElement => {
                        lockPaddingElement.style.paddingRight = "";
                    }));
                    document.body.style.paddingRight = "";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                    isBodyLocked = false;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            if (bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                const lockPaddingValue = window.innerWidth - document.body.offsetWidth + "px";
                lockPaddingElements.forEach((lockPaddingElement => {
                    lockPaddingElement.style.paddingRight = lockPaddingValue;
                }));
                document.body.style.paddingRight = lockPaddingValue;
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                    isBodyLocked = true;
                }), delay);
            }
        };
        function functions_FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        class Popup {
            constructor(options) {
                let config = {
                    logging: true,
                    init: true,
                    attributeOpenButton: "data-popup",
                    attributeCloseButton: "data-close",
                    fixElementSelector: "[data-lp]",
                    youtubeAttribute: "data-popup-youtube",
                    youtubePlaceAttribute: "data-popup-youtube-place",
                    setAutoplayYoutube: true,
                    classes: {
                        popup: "popup",
                        popupContent: "popup__content",
                        popupActive: "popup_show",
                        bodyActive: "popup-show"
                    },
                    focusCatch: true,
                    closeEsc: true,
                    bodyLock: true,
                    hashSettings: {
                        location: false,
                        goHash: false
                    },
                    on: {
                        beforeOpen: function() {},
                        afterOpen: function() {},
                        beforeClose: function() {},
                        afterClose: function() {}
                    }
                };
                this.youTubeCode;
                this.isOpen = false;
                this.targetOpen = {
                    selector: false,
                    element: false
                };
                this.previousOpen = {
                    selector: false,
                    element: false
                };
                this.lastClosed = {
                    selector: false,
                    element: false
                };
                this._dataValue = false;
                this.hash = false;
                this._reopen = false;
                this._selectorOpen = false;
                this.lastFocusEl = false;
                this._focusEl = [ "a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])' ];
                this.options = {
                    ...config,
                    ...options,
                    classes: {
                        ...config.classes,
                        ...options?.classes
                    },
                    hashSettings: {
                        ...config.hashSettings,
                        ...options?.hashSettings
                    },
                    on: {
                        ...config.on,
                        ...options?.on
                    }
                };
                this.bodyLock = false;
                this.options.init ? this.initPopups() : null;
            }
            initPopups() {
                this.popupLogging(`Прокинувся`);
                this.eventsPopup();
            }
            eventsPopup() {
                document.addEventListener("click", function(e) {
                    const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
                    if (buttonOpen) {
                        e.preventDefault();
                        this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
                        this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
                        if (this._dataValue !== "error") {
                            if (!this.isOpen) this.lastFocusEl = buttonOpen;
                            this.targetOpen.selector = `${this._dataValue}`;
                            this._selectorOpen = true;
                            this.open();
                            return;
                        } else this.popupLogging(`Йой, не заповнено атрибут у ${buttonOpen.classList}`);
                        return;
                    }
                    const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
                    if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    if (this.options.closeEsc && e.which == 27 && e.code === "Escape" && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                    if (this.options.focusCatch && e.which == 9 && this.isOpen) {
                        this._focusCatch(e);
                        return;
                    }
                }.bind(this));
                if (this.options.hashSettings.goHash) {
                    window.addEventListener("hashchange", function() {
                        if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
                    }.bind(this));
                    window.addEventListener("load", function() {
                        if (window.location.hash) this._openToHash();
                    }.bind(this));
                }
            }
            open(selectorValue) {
                if (bodyLockStatus) {
                    this.bodyLock = document.documentElement.classList.contains("lock") && !this.isOpen ? true : false;
                    if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") {
                        this.targetOpen.selector = selectorValue;
                        this._selectorOpen = true;
                    }
                    if (this.isOpen) {
                        this._reopen = true;
                        this.close();
                    }
                    if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
                    if (!this._reopen) this.previousActiveElement = document.activeElement;
                    this.targetOpen.element = document.querySelector(this.targetOpen.selector);
                    if (this.targetOpen.element) {
                        if (this.youTubeCode) {
                            const codeVideo = this.youTubeCode;
                            const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                            const iframe = document.createElement("iframe");
                            iframe.setAttribute("allowfullscreen", "");
                            const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
                            iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
                            iframe.setAttribute("src", urlVideo);
                            if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
                                this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
                            }
                            this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
                        }
                        if (this.options.hashSettings.location) {
                            this._getHash();
                            this._setHash();
                        }
                        this.options.on.beforeOpen(this);
                        document.dispatchEvent(new CustomEvent("beforePopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.targetOpen.element.classList.add(this.options.classes.popupActive);
                        document.documentElement.classList.add(this.options.classes.bodyActive);
                        if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
                        this.targetOpen.element.setAttribute("aria-hidden", "false");
                        this.previousOpen.selector = this.targetOpen.selector;
                        this.previousOpen.element = this.targetOpen.element;
                        this._selectorOpen = false;
                        this.isOpen = true;
                        setTimeout((() => {
                            this._focusTrap();
                        }), 50);
                        this.options.on.afterOpen(this);
                        document.dispatchEvent(new CustomEvent("afterPopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.popupLogging(`Відкрив попап`);
                    } else this.popupLogging(`Йой, такого попапу немає. Перевірте коректність введення. `);
                }
            }
            close(selectorValue) {
                if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") this.previousOpen.selector = selectorValue;
                if (!this.isOpen || !bodyLockStatus) return;
                this.options.on.beforeClose(this);
                document.dispatchEvent(new CustomEvent("beforePopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
                this.previousOpen.element.classList.remove(this.options.classes.popupActive);
                this.previousOpen.element.setAttribute("aria-hidden", "true");
                if (!this._reopen) {
                    document.documentElement.classList.remove(this.options.classes.bodyActive);
                    !this.bodyLock ? bodyUnlock() : null;
                    this.isOpen = false;
                }
                this._removeHash();
                if (this._selectorOpen) {
                    this.lastClosed.selector = this.previousOpen.selector;
                    this.lastClosed.element = this.previousOpen.element;
                }
                this.options.on.afterClose(this);
                document.dispatchEvent(new CustomEvent("afterPopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                setTimeout((() => {
                    this._focusTrap();
                }), 50);
                this.popupLogging(`Закрив попап`);
            }
            _getHash() {
                if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
            }
            _openToHash() {
                let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
                const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
                this.youTubeCode = buttons.getAttribute(this.options.youtubeAttribute) ? buttons.getAttribute(this.options.youtubeAttribute) : null;
                if (buttons && classInHash) this.open(classInHash);
            }
            _setHash() {
                history.pushState("", "", this.hash);
            }
            _removeHash() {
                history.pushState("", "", window.location.href.split("#")[0]);
            }
            _focusCatch(e) {
                const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
                const focusArray = Array.prototype.slice.call(focusable);
                const focusedIndex = focusArray.indexOf(document.activeElement);
                if (e.shiftKey && focusedIndex === 0) {
                    focusArray[focusArray.length - 1].focus();
                    e.preventDefault();
                }
                if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
                    focusArray[0].focus();
                    e.preventDefault();
                }
            }
            _focusTrap() {
                const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
                if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
            }
            popupLogging(message) {
                this.options.logging ? functions_FLS(`[Попапос]: ${message}`) : null;
            }
        }
        modules_flsModules.popup = new Popup({});
        let formValidate = {
            getErrors(form) {
                let error = 0;
                let formRequiredItems = form.querySelectorAll("*[data-required]");
                if (formRequiredItems.length) formRequiredItems.forEach((formRequiredItem => {
                    if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) error += this.validateInput(formRequiredItem);
                }));
                return error;
            },
            validateInput(formRequiredItem) {
                let error = 0;
                if (formRequiredItem.dataset.required === "email") {
                    formRequiredItem.value = formRequiredItem.value.replace(" ", "");
                    if (this.emailTest(formRequiredItem)) {
                        this.addError(formRequiredItem);
                        error++;
                    } else this.removeError(formRequiredItem);
                } else if (formRequiredItem.type === "checkbox" && !formRequiredItem.checked) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (!formRequiredItem.value.trim()) {
                    this.addError(formRequiredItem);
                    error++;
                } else this.removeError(formRequiredItem);
                return error;
            },
            addError(formRequiredItem) {
                formRequiredItem.classList.add("_form-error");
                formRequiredItem.parentElement.classList.add("_form-error");
                let inputError = formRequiredItem.parentElement.querySelector(".form__error");
                if (inputError) formRequiredItem.parentElement.removeChild(inputError);
                if (formRequiredItem.dataset.error) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${formRequiredItem.dataset.error}</div>`);
            },
            removeError(formRequiredItem) {
                formRequiredItem.classList.remove("_form-error");
                formRequiredItem.parentElement.classList.remove("_form-error");
                if (formRequiredItem.parentElement.querySelector(".form__error")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__error"));
            },
            formClean(form) {
                form.reset();
                setTimeout((() => {
                    let inputs = form.querySelectorAll("input,textarea");
                    for (let index = 0; index < inputs.length; index++) {
                        const el = inputs[index];
                        el.parentElement.classList.remove("_form-focus");
                        el.classList.remove("_form-focus");
                        formValidate.removeError(el);
                    }
                    let checkboxes = form.querySelectorAll(".checkbox__input");
                    if (checkboxes.length > 0) for (let index = 0; index < checkboxes.length; index++) {
                        const checkbox = checkboxes[index];
                        checkbox.checked = false;
                    }
                    if (modules_flsModules.select) {
                        let selects = form.querySelectorAll("div.select");
                        if (selects.length) for (let index = 0; index < selects.length; index++) {
                            const select = selects[index].querySelector("select");
                            modules_flsModules.select.selectBuild(select);
                        }
                    }
                }), 0);
            },
            emailTest(formRequiredItem) {
                return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
            }
        };
        class SelectConstructor {
            constructor(props, data = null) {
                let defaultConfig = {
                    init: true,
                    logging: true,
                    speed: 150
                };
                this.config = Object.assign(defaultConfig, props);
                this.selectClasses = {
                    classSelect: "select",
                    classSelectBody: "select__body",
                    classSelectTitle: "select__title",
                    classSelectValue: "select__value",
                    classSelectLabel: "select__label",
                    classSelectInput: "select__input",
                    classSelectText: "select__text",
                    classSelectLink: "select__link",
                    classSelectOptions: "select__options",
                    classSelectOptionsScroll: "select__scroll",
                    classSelectOption: "select__option",
                    classSelectContent: "select__content",
                    classSelectRow: "select__row",
                    classSelectData: "select__asset",
                    classSelectDisabled: "_select-disabled",
                    classSelectTag: "_select-tag",
                    classSelectOpen: "_select-open",
                    classSelectActive: "_select-active",
                    classSelectFocus: "_select-focus",
                    classSelectMultiple: "_select-multiple",
                    classSelectCheckBox: "_select-checkbox",
                    classSelectOptionSelected: "_select-selected",
                    classSelectPseudoLabel: "_select-pseudo-label"
                };
                this._this = this;
                if (this.config.init) {
                    const selectItems = data ? document.querySelectorAll(data) : document.querySelectorAll("select");
                    if (selectItems.length) {
                        this.selectsInit(selectItems);
                        this.setLogging(`Прокинувся, построїв селектов: (${selectItems.length})`);
                    } else this.setLogging("Сплю, немає жодного select");
                }
            }
            getSelectClass(className) {
                return `.${className}`;
            }
            getSelectElement(selectItem, className) {
                return {
                    originalSelect: selectItem.querySelector("select"),
                    selectElement: selectItem.querySelector(this.getSelectClass(className))
                };
            }
            selectsInit(selectItems) {
                selectItems.forEach(((originalSelect, index) => {
                    this.selectInit(originalSelect, index + 1);
                }));
                document.addEventListener("click", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusin", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusout", function(e) {
                    this.selectsActions(e);
                }.bind(this));
            }
            selectInit(originalSelect, index) {
                const _this = this;
                let selectItem = document.createElement("div");
                selectItem.classList.add(this.selectClasses.classSelect);
                originalSelect.parentNode.insertBefore(selectItem, originalSelect);
                selectItem.appendChild(originalSelect);
                originalSelect.hidden = true;
                index ? originalSelect.dataset.id = index : null;
                if (this.getSelectPlaceholder(originalSelect)) {
                    originalSelect.dataset.placeholder = this.getSelectPlaceholder(originalSelect).value;
                    if (this.getSelectPlaceholder(originalSelect).label.show) {
                        const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                        selectItemTitle.insertAdjacentHTML("afterbegin", `<span class="${this.selectClasses.classSelectLabel}">${this.getSelectPlaceholder(originalSelect).label.text ? this.getSelectPlaceholder(originalSelect).label.text : this.getSelectPlaceholder(originalSelect).value}</span>`);
                    }
                }
                selectItem.insertAdjacentHTML("beforeend", `<div class="${this.selectClasses.classSelectBody}"><div hidden class="${this.selectClasses.classSelectOptions}"></div></div>`);
                this.selectBuild(originalSelect);
                originalSelect.dataset.speed = originalSelect.dataset.speed ? originalSelect.dataset.speed : this.config.speed;
                this.config.speed = +originalSelect.dataset.speed;
                originalSelect.addEventListener("change", (function(e) {
                    _this.selectChange(e);
                }));
            }
            selectBuild(originalSelect) {
                const selectItem = originalSelect.parentElement;
                selectItem.dataset.id = originalSelect.dataset.id;
                originalSelect.dataset.classModif ? selectItem.classList.add(`select_${originalSelect.dataset.classModif}`) : null;
                originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectMultiple) : selectItem.classList.remove(this.selectClasses.classSelectMultiple);
                originalSelect.hasAttribute("data-checkbox") && originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectCheckBox) : selectItem.classList.remove(this.selectClasses.classSelectCheckBox);
                this.setSelectTitleValue(selectItem, originalSelect);
                this.setOptions(selectItem, originalSelect);
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
                originalSelect.hasAttribute("data-open") ? this.selectAction(selectItem) : null;
                this.selectDisabled(selectItem, originalSelect);
            }
            selectsActions(e) {
                const targetElement = e.target;
                const targetType = e.type;
                if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect)) || targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                    const selectItem = targetElement.closest(".select") ? targetElement.closest(".select") : document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag)).dataset.selectId}"]`);
                    const originalSelect = this.getSelectElement(selectItem).originalSelect;
                    if (targetType === "click") {
                        if (!originalSelect.disabled) if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                            const targetTag = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag));
                            const optionItem = document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetTag.dataset.selectId}"] .select__option[data-value="${targetTag.dataset.value}"]`);
                            this.optionAction(selectItem, originalSelect, optionItem);
                        } else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTitle))) this.selectAction(selectItem); else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption))) {
                            const optionItem = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption));
                            this.optionAction(selectItem, originalSelect, optionItem);
                        }
                    } else if (targetType === "focusin" || targetType === "focusout") {
                        if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect))) targetType === "focusin" ? selectItem.classList.add(this.selectClasses.classSelectFocus) : selectItem.classList.remove(this.selectClasses.classSelectFocus);
                    } else if (targetType === "keydown" && e.code === "Escape") this.selectsСlose();
                } else this.selectsСlose();
            }
            selectsСlose(selectOneGroup) {
                const selectsGroup = selectOneGroup ? selectOneGroup : document;
                const selectActiveItems = selectsGroup.querySelectorAll(`${this.getSelectClass(this.selectClasses.classSelect)}${this.getSelectClass(this.selectClasses.classSelectOpen)}`);
                if (selectActiveItems.length) selectActiveItems.forEach((selectActiveItem => {
                    this.selectСlose(selectActiveItem);
                }));
            }
            selectСlose(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                if (!selectOptions.classList.contains("_slide")) {
                    selectItem.classList.remove(this.selectClasses.classSelectOpen);
                    _slideUp(selectOptions, originalSelect.dataset.speed);
                    setTimeout((() => {
                        selectItem.style.zIndex = "";
                    }), originalSelect.dataset.speed);
                }
            }
            selectAction(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOpenzIndex = originalSelect.dataset.zIndex ? originalSelect.dataset.zIndex : 3;
                this.setOptionsPosition(selectItem);
                if (originalSelect.closest("[data-one-select]")) {
                    const selectOneGroup = originalSelect.closest("[data-one-select]");
                    this.selectsСlose(selectOneGroup);
                }
                setTimeout((() => {
                    if (!selectOptions.classList.contains("_slide")) {
                        selectItem.classList.toggle(this.selectClasses.classSelectOpen);
                        _slideToggle(selectOptions, originalSelect.dataset.speed);
                        if (selectItem.classList.contains(this.selectClasses.classSelectOpen)) selectItem.style.zIndex = selectOpenzIndex; else setTimeout((() => {
                            selectItem.style.zIndex = "";
                        }), originalSelect.dataset.speed);
                    }
                }), 0);
            }
            setSelectTitleValue(selectItem, originalSelect) {
                const selectItemBody = this.getSelectElement(selectItem, this.selectClasses.classSelectBody).selectElement;
                const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                if (selectItemTitle) selectItemTitle.remove();
                selectItemBody.insertAdjacentHTML("afterbegin", this.getSelectTitleValue(selectItem, originalSelect));
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
            }
            getSelectTitleValue(selectItem, originalSelect) {
                let selectTitleValue = this.getSelectedOptionsData(originalSelect, 2).html;
                if (originalSelect.multiple && originalSelect.hasAttribute("data-tags")) {
                    selectTitleValue = this.getSelectedOptionsData(originalSelect).elements.map((option => `<span role="button" data-select-id="${selectItem.dataset.id}" data-value="${option.value}" class="_select-tag">${this.getSelectElementContent(option)}</span>`)).join("");
                    if (originalSelect.dataset.tags && document.querySelector(originalSelect.dataset.tags)) {
                        document.querySelector(originalSelect.dataset.tags).innerHTML = selectTitleValue;
                        if (originalSelect.hasAttribute("data-search")) selectTitleValue = false;
                    }
                }
                selectTitleValue = selectTitleValue.length ? selectTitleValue : originalSelect.dataset.placeholder ? originalSelect.dataset.placeholder : "";
                let pseudoAttribute = "";
                let pseudoAttributeClass = "";
                if (originalSelect.hasAttribute("data-pseudo-label")) {
                    pseudoAttribute = originalSelect.dataset.pseudoLabel ? ` data-pseudo-label="${originalSelect.dataset.pseudoLabel}"` : ` data-pseudo-label="Заповніть атрибут"`;
                    pseudoAttributeClass = ` ${this.selectClasses.classSelectPseudoLabel}`;
                }
                this.getSelectedOptionsData(originalSelect).values.length ? selectItem.classList.add(this.selectClasses.classSelectActive) : selectItem.classList.remove(this.selectClasses.classSelectActive);
                if (originalSelect.hasAttribute("data-search")) return `<div class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}"><input autocomplete="off" type="text" placeholder="${selectTitleValue}" data-placeholder="${selectTitleValue}" class="${this.selectClasses.classSelectInput}"></span></div>`; else {
                    const customClass = this.getSelectedOptionsData(originalSelect).elements.length && this.getSelectedOptionsData(originalSelect).elements[0].dataset.class ? ` ${this.getSelectedOptionsData(originalSelect).elements[0].dataset.class}` : "";
                    return `<button type="button" class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}${pseudoAttributeClass}"><span class="${this.selectClasses.classSelectContent}${customClass}">${selectTitleValue}</span></span></button>`;
                }
            }
            getSelectElementContent(selectOption) {
                const selectOptionData = selectOption.dataset.asset ? `${selectOption.dataset.asset}` : "";
                const selectOptionDataHTML = selectOptionData.indexOf("img") >= 0 ? `<img src="${selectOptionData}" alt="">` : selectOptionData;
                let selectOptionContentHTML = ``;
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectRow}">` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectData}">` : "";
                selectOptionContentHTML += selectOptionData ? selectOptionDataHTML : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectText}">` : "";
                selectOptionContentHTML += selectOption.textContent.replace(/\*(?!<)/g, "<span>*</span>");
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                return selectOptionContentHTML;
            }
            getSelectPlaceholder(originalSelect) {
                const selectPlaceholder = Array.from(originalSelect.options).find((option => !option.value));
                if (selectPlaceholder) return {
                    value: selectPlaceholder.textContent,
                    show: selectPlaceholder.hasAttribute("data-show"),
                    label: {
                        show: selectPlaceholder.hasAttribute("data-label"),
                        text: selectPlaceholder.dataset.label
                    }
                };
            }
            getSelectedOptionsData(originalSelect, type) {
                let selectedOptions = [];
                if (originalSelect.multiple) selectedOptions = Array.from(originalSelect.options).filter((option => option.value)).filter((option => option.selected)); else selectedOptions.push(originalSelect.options[originalSelect.selectedIndex]);
                return {
                    elements: selectedOptions.map((option => option)),
                    values: selectedOptions.filter((option => option.value)).map((option => option.value)),
                    html: selectedOptions.map((option => this.getSelectElementContent(option)))
                };
            }
            getOptions(originalSelect) {
                const selectOptionsScroll = originalSelect.hasAttribute("data-scroll") ? `data-simplebar` : "";
                const customMaxHeightValue = +originalSelect.dataset.scroll ? +originalSelect.dataset.scroll : null;
                let selectOptions = Array.from(originalSelect.options);
                if (selectOptions.length > 0) {
                    let selectOptionsHTML = ``;
                    if (this.getSelectPlaceholder(originalSelect) && !this.getSelectPlaceholder(originalSelect).show || originalSelect.multiple) selectOptions = selectOptions.filter((option => option.value));
                    selectOptionsHTML += `<div ${selectOptionsScroll} ${selectOptionsScroll ? `style="max-height: ${customMaxHeightValue}px"` : ""} class="${this.selectClasses.classSelectOptionsScroll}">`;
                    selectOptions.forEach((selectOption => {
                        selectOptionsHTML += this.getOption(selectOption, originalSelect);
                    }));
                    selectOptionsHTML += `</div>`;
                    return selectOptionsHTML;
                }
            }
            getOption(selectOption, originalSelect) {
                const selectOptionSelected = selectOption.selected && originalSelect.multiple ? ` ${this.selectClasses.classSelectOptionSelected}` : "";
                const selectOptionHide = selectOption.selected && !originalSelect.hasAttribute("data-show-selected") && !originalSelect.multiple ? `hidden` : ``;
                const selectOptionClass = selectOption.dataset.class ? ` ${selectOption.dataset.class}` : "";
                const selectOptionLink = selectOption.dataset.href ? selectOption.dataset.href : false;
                const selectOptionLinkTarget = selectOption.hasAttribute("data-href-blank") ? `target="_blank"` : "";
                let selectOptionHTML = ``;
                selectOptionHTML += selectOptionLink ? `<a ${selectOptionLinkTarget} ${selectOptionHide} href="${selectOptionLink}" data-value="${selectOption.value}" class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}">` : `<button ${selectOptionHide} class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}" data-value="${selectOption.value}" type="button">`;
                selectOptionHTML += this.getSelectElementContent(selectOption);
                selectOptionHTML += selectOptionLink ? `</a>` : `</button>`;
                return selectOptionHTML;
            }
            setOptions(selectItem, originalSelect) {
                const selectItemOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                selectItemOptions.innerHTML = this.getOptions(originalSelect);
            }
            setOptionsPosition(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectItemScroll = this.getSelectElement(selectItem, this.selectClasses.classSelectOptionsScroll).selectElement;
                const customMaxHeightValue = +originalSelect.dataset.scroll ? `${+originalSelect.dataset.scroll}px` : ``;
                const selectOptionsPosMargin = +originalSelect.dataset.optionsMargin ? +originalSelect.dataset.optionsMargin : 10;
                if (!selectItem.classList.contains(this.selectClasses.classSelectOpen)) {
                    selectOptions.hidden = false;
                    const selectItemScrollHeight = selectItemScroll.offsetHeight ? selectItemScroll.offsetHeight : parseInt(window.getComputedStyle(selectItemScroll).getPropertyValue("max-height"));
                    const selectOptionsHeight = selectOptions.offsetHeight > selectItemScrollHeight ? selectOptions.offsetHeight : selectItemScrollHeight + selectOptions.offsetHeight;
                    const selectOptionsScrollHeight = selectOptionsHeight - selectItemScrollHeight;
                    selectOptions.hidden = true;
                    const selectItemHeight = selectItem.offsetHeight;
                    const selectItemPos = selectItem.getBoundingClientRect().top;
                    const selectItemTotal = selectItemPos + selectOptionsHeight + selectItemHeight + selectOptionsScrollHeight;
                    const selectItemResult = window.innerHeight - (selectItemTotal + selectOptionsPosMargin);
                    if (selectItemResult < 0) {
                        const newMaxHeightValue = selectOptionsHeight + selectItemResult;
                        if (newMaxHeightValue < 100) {
                            selectItem.classList.add("select--show-top");
                            selectItemScroll.style.maxHeight = selectItemPos < selectOptionsHeight ? `${selectItemPos - (selectOptionsHeight - selectItemPos)}px` : customMaxHeightValue;
                        } else {
                            selectItem.classList.remove("select--show-top");
                            selectItemScroll.style.maxHeight = `${newMaxHeightValue}px`;
                        }
                    }
                } else setTimeout((() => {
                    selectItem.classList.remove("select--show-top");
                    selectItemScroll.style.maxHeight = customMaxHeightValue;
                }), +originalSelect.dataset.speed);
            }
            optionAction(selectItem, originalSelect, optionItem) {
                const selectOptions = selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOptions)}`);
                if (!selectOptions.classList.contains("_slide")) {
                    if (originalSelect.multiple) {
                        optionItem.classList.toggle(this.selectClasses.classSelectOptionSelected);
                        const originalSelectSelectedItems = this.getSelectedOptionsData(originalSelect).elements;
                        originalSelectSelectedItems.forEach((originalSelectSelectedItem => {
                            originalSelectSelectedItem.removeAttribute("selected");
                        }));
                        const selectSelectedItems = selectItem.querySelectorAll(this.getSelectClass(this.selectClasses.classSelectOptionSelected));
                        selectSelectedItems.forEach((selectSelectedItems => {
                            originalSelect.querySelector(`option[value = "${selectSelectedItems.dataset.value}"]`).setAttribute("selected", "selected");
                        }));
                    } else {
                        if (!originalSelect.hasAttribute("data-show-selected")) setTimeout((() => {
                            if (selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`)) selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`).hidden = false;
                            optionItem.hidden = true;
                        }), this.config.speed);
                        originalSelect.value = optionItem.hasAttribute("data-value") ? optionItem.dataset.value : optionItem.textContent;
                        this.selectAction(selectItem);
                    }
                    this.setSelectTitleValue(selectItem, originalSelect);
                    this.setSelectChange(originalSelect);
                }
            }
            selectChange(e) {
                const originalSelect = e.target;
                this.selectBuild(originalSelect);
                this.setSelectChange(originalSelect);
            }
            setSelectChange(originalSelect) {
                if (originalSelect.hasAttribute("data-validate")) formValidate.validateInput(originalSelect);
                if (originalSelect.hasAttribute("data-submit") && originalSelect.value) {
                    let tempButton = document.createElement("button");
                    tempButton.type = "submit";
                    originalSelect.closest("form").append(tempButton);
                    tempButton.click();
                    tempButton.remove();
                }
                const selectItem = originalSelect.parentElement;
                this.selectCallback(selectItem, originalSelect);
            }
            selectDisabled(selectItem, originalSelect) {
                if (originalSelect.disabled) {
                    selectItem.classList.add(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = true;
                } else {
                    selectItem.classList.remove(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = false;
                }
            }
            searchActions(selectItem) {
                this.getSelectElement(selectItem).originalSelect;
                const selectInput = this.getSelectElement(selectItem, this.selectClasses.classSelectInput).selectElement;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOptionsItems = selectOptions.querySelectorAll(`.${this.selectClasses.classSelectOption} `);
                const _this = this;
                selectInput.addEventListener("input", (function() {
                    selectOptionsItems.forEach((selectOptionsItem => {
                        if (selectOptionsItem.textContent.toUpperCase().includes(selectInput.value.toUpperCase())) selectOptionsItem.hidden = false; else selectOptionsItem.hidden = true;
                    }));
                    selectOptions.hidden === true ? _this.selectAction(selectItem) : null;
                }));
            }
            selectCallback(selectItem, originalSelect) {
                document.dispatchEvent(new CustomEvent("selectCallback", {
                    detail: {
                        select: originalSelect
                    }
                }));
            }
            setLogging(message) {
                this.config.logging ? functions_FLS(`[select]: ${message} `) : null;
            }
        }
        modules_flsModules.select = new SelectConstructor({});
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            Object.defineProperty(Constructor, "prototype", {
                writable: false
            });
            return Constructor;
        }
        /*!
 * Splide.js
 * Version  : 4.1.4
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
 */        var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
        var CREATED = 1;
        var MOUNTED = 2;
        var IDLE = 3;
        var MOVING = 4;
        var SCROLLING = 5;
        var DRAGGING = 6;
        var DESTROYED = 7;
        var STATES = {
            CREATED,
            MOUNTED,
            IDLE,
            MOVING,
            SCROLLING,
            DRAGGING,
            DESTROYED
        };
        function empty(array) {
            array.length = 0;
        }
        function slice(arrayLike, start, end) {
            return Array.prototype.slice.call(arrayLike, start, end);
        }
        function apply(func) {
            return func.bind.apply(func, [ null ].concat(slice(arguments, 1)));
        }
        var nextTick = setTimeout;
        var noop = function noop() {};
        function raf(func) {
            return requestAnimationFrame(func);
        }
        function typeOf(type, subject) {
            return typeof subject === type;
        }
        function isObject(subject) {
            return !isNull(subject) && typeOf("object", subject);
        }
        var isArray = Array.isArray;
        var isFunction = apply(typeOf, "function");
        var isString = apply(typeOf, "string");
        var isUndefined = apply(typeOf, "undefined");
        function isNull(subject) {
            return subject === null;
        }
        function isHTMLElement(subject) {
            try {
                return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
            } catch (e) {
                return false;
            }
        }
        function toArray(value) {
            return isArray(value) ? value : [ value ];
        }
        function forEach(values, iteratee) {
            toArray(values).forEach(iteratee);
        }
        function includes(array, value) {
            return array.indexOf(value) > -1;
        }
        function push(array, items) {
            array.push.apply(array, toArray(items));
            return array;
        }
        function toggleClass(elm, classes, add) {
            if (elm) forEach(classes, (function(name) {
                if (name) elm.classList[add ? "add" : "remove"](name);
            }));
        }
        function addClass(elm, classes) {
            toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
        }
        function append(parent, children) {
            forEach(children, parent.appendChild.bind(parent));
        }
        function before(nodes, ref) {
            forEach(nodes, (function(node) {
                var parent = (ref || node).parentNode;
                if (parent) parent.insertBefore(node, ref);
            }));
        }
        function matches(elm, selector) {
            return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
        }
        function children(parent, selector) {
            var children2 = parent ? slice(parent.children) : [];
            return selector ? children2.filter((function(child) {
                return matches(child, selector);
            })) : children2;
        }
        function child(parent, selector) {
            return selector ? children(parent, selector)[0] : parent.firstElementChild;
        }
        var ownKeys = Object.keys;
        function forOwn(object, iteratee, right) {
            if (object) (right ? ownKeys(object).reverse() : ownKeys(object)).forEach((function(key) {
                key !== "__proto__" && iteratee(object[key], key);
            }));
            return object;
        }
        function splide_esm_assign(object) {
            slice(arguments, 1).forEach((function(source) {
                forOwn(source, (function(value, key) {
                    object[key] = source[key];
                }));
            }));
            return object;
        }
        function merge(object) {
            slice(arguments, 1).forEach((function(source) {
                forOwn(source, (function(value, key) {
                    if (isArray(value)) object[key] = value.slice(); else if (isObject(value)) object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value); else object[key] = value;
                }));
            }));
            return object;
        }
        function omit(object, keys) {
            forEach(keys || ownKeys(object), (function(key) {
                delete object[key];
            }));
        }
        function removeAttribute(elms, attrs) {
            forEach(elms, (function(elm) {
                forEach(attrs, (function(attr) {
                    elm && elm.removeAttribute(attr);
                }));
            }));
        }
        function setAttribute(elms, attrs, value) {
            if (isObject(attrs)) forOwn(attrs, (function(value2, name) {
                setAttribute(elms, name, value2);
            })); else forEach(elms, (function(elm) {
                isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
            }));
        }
        function create(tag, attrs, parent) {
            var elm = document.createElement(tag);
            if (attrs) isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
            parent && append(parent, elm);
            return elm;
        }
        function style(elm, prop, value) {
            if (isUndefined(value)) return getComputedStyle(elm)[prop];
            if (!isNull(value)) elm.style[prop] = "" + value;
        }
        function display(elm, display2) {
            style(elm, "display", display2);
        }
        function splide_esm_focus(elm) {
            elm["setActive"] && elm["setActive"]() || elm.focus({
                preventScroll: true
            });
        }
        function getAttribute(elm, attr) {
            return elm.getAttribute(attr);
        }
        function hasClass(elm, className) {
            return elm && elm.classList.contains(className);
        }
        function rect(target) {
            return target.getBoundingClientRect();
        }
        function remove(nodes) {
            forEach(nodes, (function(node) {
                if (node && node.parentNode) node.parentNode.removeChild(node);
            }));
        }
        function parseHtml(html) {
            return child((new DOMParser).parseFromString(html, "text/html").body);
        }
        function prevent(e, stopPropagation) {
            e.preventDefault();
            if (stopPropagation) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
        function query(parent, selector) {
            return parent && parent.querySelector(selector);
        }
        function queryAll(parent, selector) {
            return selector ? slice(parent.querySelectorAll(selector)) : [];
        }
        function removeClass(elm, classes) {
            toggleClass(elm, classes, false);
        }
        function timeOf(e) {
            return e.timeStamp;
        }
        function unit(value) {
            return isString(value) ? value : value ? value + "px" : "";
        }
        var PROJECT_CODE = "splide";
        var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;
        function assert(condition, message) {
            if (!condition) throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
        }
        var min = Math.min, max = Math.max, floor = Math.floor, ceil = Math.ceil, abs = Math.abs;
        function approximatelyEqual(x, y, epsilon) {
            return abs(x - y) < epsilon;
        }
        function between(number, x, y, exclusive) {
            var minimum = min(x, y);
            var maximum = max(x, y);
            return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
        }
        function clamp(number, x, y) {
            var minimum = min(x, y);
            var maximum = max(x, y);
            return min(max(minimum, number), maximum);
        }
        function sign(x) {
            return +(x > 0) - +(x < 0);
        }
        function camelToKebab(string) {
            return string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
        }
        function format(string, replacements) {
            forEach(replacements, (function(replacement) {
                string = string.replace("%s", "" + replacement);
            }));
            return string;
        }
        function pad(number) {
            return number < 10 ? "0" + number : "" + number;
        }
        var ids = {};
        function uniqueId(prefix) {
            return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
        }
        function EventBinder() {
            var listeners = [];
            function bind(targets, events, callback, options) {
                forEachEvent(targets, events, (function(target, event, namespace) {
                    var isEventTarget = "addEventListener" in target;
                    var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
                    isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
                    listeners.push([ target, event, namespace, callback, remover ]);
                }));
            }
            function unbind(targets, events, callback) {
                forEachEvent(targets, events, (function(target, event, namespace) {
                    listeners = listeners.filter((function(listener) {
                        if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
                            listener[4]();
                            return false;
                        }
                        return true;
                    }));
                }));
            }
            function dispatch(target, type, detail) {
                var e;
                var bubbles = true;
                if (typeof CustomEvent === "function") e = new CustomEvent(type, {
                    bubbles,
                    detail
                }); else {
                    e = document.createEvent("CustomEvent");
                    e.initCustomEvent(type, bubbles, false, detail);
                }
                target.dispatchEvent(e);
                return e;
            }
            function forEachEvent(targets, events, iteratee) {
                forEach(targets, (function(target) {
                    target && forEach(events, (function(events2) {
                        events2.split(" ").forEach((function(eventNS) {
                            var fragment = eventNS.split(".");
                            iteratee(target, fragment[0], fragment[1]);
                        }));
                    }));
                }));
            }
            function destroy() {
                listeners.forEach((function(data) {
                    data[4]();
                }));
                empty(listeners);
            }
            return {
                bind,
                unbind,
                dispatch,
                destroy
            };
        }
        var EVENT_MOUNTED = "mounted";
        var EVENT_READY = "ready";
        var EVENT_MOVE = "move";
        var EVENT_MOVED = "moved";
        var EVENT_CLICK = "click";
        var EVENT_ACTIVE = "active";
        var EVENT_INACTIVE = "inactive";
        var EVENT_VISIBLE = "visible";
        var EVENT_HIDDEN = "hidden";
        var EVENT_REFRESH = "refresh";
        var EVENT_UPDATED = "updated";
        var EVENT_RESIZE = "resize";
        var EVENT_RESIZED = "resized";
        var EVENT_DRAG = "drag";
        var EVENT_DRAGGING = "dragging";
        var EVENT_DRAGGED = "dragged";
        var EVENT_SCROLL = "scroll";
        var EVENT_SCROLLED = "scrolled";
        var EVENT_OVERFLOW = "overflow";
        var EVENT_DESTROY = "destroy";
        var EVENT_ARROWS_MOUNTED = "arrows:mounted";
        var EVENT_ARROWS_UPDATED = "arrows:updated";
        var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
        var EVENT_PAGINATION_UPDATED = "pagination:updated";
        var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
        var EVENT_AUTOPLAY_PLAY = "autoplay:play";
        var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
        var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
        var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
        var EVENT_SLIDE_KEYDOWN = "sk";
        var EVENT_SHIFTED = "sh";
        var EVENT_END_INDEX_CHANGED = "ei";
        function EventInterface(Splide2) {
            var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
            var binder = EventBinder();
            function on(events, callback) {
                binder.bind(bus, toArray(events).join(" "), (function(e) {
                    callback.apply(callback, isArray(e.detail) ? e.detail : []);
                }));
            }
            function emit(event) {
                binder.dispatch(bus, event, slice(arguments, 1));
            }
            if (Splide2) Splide2.event.on(EVENT_DESTROY, binder.destroy);
            return splide_esm_assign(binder, {
                bus,
                on,
                off: apply(binder.unbind, bus),
                emit
            });
        }
        function RequestInterval(interval, onInterval, onUpdate, limit) {
            var now = Date.now;
            var startTime;
            var rate = 0;
            var id;
            var paused = true;
            var count = 0;
            function update() {
                if (!paused) {
                    rate = interval ? min((now() - startTime) / interval, 1) : 1;
                    onUpdate && onUpdate(rate);
                    if (rate >= 1) {
                        onInterval();
                        startTime = now();
                        if (limit && ++count >= limit) return pause();
                    }
                    id = raf(update);
                }
            }
            function start(resume) {
                resume || cancel();
                startTime = now() - (resume ? rate * interval : 0);
                paused = false;
                id = raf(update);
            }
            function pause() {
                paused = true;
            }
            function rewind() {
                startTime = now();
                rate = 0;
                if (onUpdate) onUpdate(rate);
            }
            function cancel() {
                id && cancelAnimationFrame(id);
                rate = 0;
                id = 0;
                paused = true;
            }
            function set(time) {
                interval = time;
            }
            function isPaused() {
                return paused;
            }
            return {
                start,
                rewind,
                pause,
                cancel,
                set,
                isPaused
            };
        }
        function State(initialState) {
            var state = initialState;
            function set(value) {
                state = value;
            }
            function is(states) {
                return includes(toArray(states), state);
            }
            return {
                set,
                is
            };
        }
        function Throttle(func, duration) {
            var interval = RequestInterval(duration || 0, func, null, 1);
            return function() {
                interval.isPaused() && interval.start();
            };
        }
        function Media(Splide2, Components2, options) {
            var state = Splide2.state;
            var breakpoints = options.breakpoints || {};
            var reducedMotion = options.reducedMotion || {};
            var binder = EventBinder();
            var queries = [];
            function setup() {
                var isMin = options.mediaQuery === "min";
                ownKeys(breakpoints).sort((function(n, m) {
                    return isMin ? +n - +m : +m - +n;
                })).forEach((function(key) {
                    register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
                }));
                register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
                update();
            }
            function destroy(completely) {
                if (completely) binder.destroy();
            }
            function register(options2, query) {
                var queryList = matchMedia(query);
                binder.bind(queryList, "change", update);
                queries.push([ options2, queryList ]);
            }
            function update() {
                var destroyed = state.is(DESTROYED);
                var direction = options.direction;
                var merged = queries.reduce((function(merged2, entry) {
                    return merge(merged2, entry[1].matches ? entry[0] : {});
                }), {});
                omit(options);
                set(merged);
                if (options.destroy) Splide2.destroy(options.destroy === "completely"); else if (destroyed) {
                    destroy(true);
                    Splide2.mount();
                } else direction !== options.direction && Splide2.refresh();
            }
            function reduce(enable) {
                if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
            }
            function set(opts, base, notify) {
                merge(options, opts);
                base && merge(Object.getPrototypeOf(options), opts);
                if (notify || !state.is(CREATED)) Splide2.emit(EVENT_UPDATED, options);
            }
            return {
                setup,
                destroy,
                reduce,
                set
            };
        }
        var ARROW = "Arrow";
        var ARROW_LEFT = ARROW + "Left";
        var ARROW_RIGHT = ARROW + "Right";
        var ARROW_UP = ARROW + "Up";
        var ARROW_DOWN = ARROW + "Down";
        var RTL = "rtl";
        var TTB = "ttb";
        var ORIENTATION_MAP = {
            width: [ "height" ],
            left: [ "top", "right" ],
            right: [ "bottom", "left" ],
            x: [ "y" ],
            X: [ "Y" ],
            Y: [ "X" ],
            ArrowLeft: [ ARROW_UP, ARROW_RIGHT ],
            ArrowRight: [ ARROW_DOWN, ARROW_LEFT ]
        };
        function Direction(Splide2, Components2, options) {
            function resolve(prop, axisOnly, direction) {
                direction = direction || options.direction;
                var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
                return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, (function(match, offset) {
                    var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
                    return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
                }));
            }
            function orient(value) {
                return value * (options.direction === RTL ? 1 : -1);
            }
            return {
                resolve,
                orient
            };
        }
        var ROLE = "role";
        var TAB_INDEX = "tabindex";
        var DISABLED = "disabled";
        var ARIA_PREFIX = "aria-";
        var ARIA_CONTROLS = ARIA_PREFIX + "controls";
        var ARIA_CURRENT = ARIA_PREFIX + "current";
        var ARIA_SELECTED = ARIA_PREFIX + "selected";
        var ARIA_LABEL = ARIA_PREFIX + "label";
        var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
        var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
        var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
        var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
        var ARIA_LIVE = ARIA_PREFIX + "live";
        var ARIA_BUSY = ARIA_PREFIX + "busy";
        var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
        var ALL_ATTRIBUTES = [ ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION ];
        var CLASS_PREFIX = PROJECT_CODE + "__";
        var STATUS_CLASS_PREFIX = "is-";
        var CLASS_ROOT = PROJECT_CODE;
        var CLASS_TRACK = CLASS_PREFIX + "track";
        var CLASS_LIST = CLASS_PREFIX + "list";
        var CLASS_SLIDE = CLASS_PREFIX + "slide";
        var CLASS_CLONE = CLASS_SLIDE + "--clone";
        var CLASS_CONTAINER = CLASS_SLIDE + "__container";
        var CLASS_ARROWS = CLASS_PREFIX + "arrows";
        var CLASS_ARROW = CLASS_PREFIX + "arrow";
        var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
        var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
        var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
        var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
        var CLASS_PROGRESS = CLASS_PREFIX + "progress";
        var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
        var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
        var CLASS_SPINNER = CLASS_PREFIX + "spinner";
        var CLASS_SR = CLASS_PREFIX + "sr";
        var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
        var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
        var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
        var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
        var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
        var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
        var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
        var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
        var STATUS_CLASSES = [ CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW ];
        var CLASSES = {
            slide: CLASS_SLIDE,
            clone: CLASS_CLONE,
            arrows: CLASS_ARROWS,
            arrow: CLASS_ARROW,
            prev: CLASS_ARROW_PREV,
            next: CLASS_ARROW_NEXT,
            pagination: CLASS_PAGINATION,
            page: CLASS_PAGINATION_PAGE,
            spinner: CLASS_SPINNER
        };
        function closest(from, selector) {
            if (isFunction(from.closest)) return from.closest(selector);
            var elm = from;
            while (elm && elm.nodeType === 1) {
                if (matches(elm, selector)) break;
                elm = elm.parentElement;
            }
            return elm;
        }
        var FRICTION = 5;
        var LOG_INTERVAL = 200;
        var POINTER_DOWN_EVENTS = "touchstart mousedown";
        var POINTER_MOVE_EVENTS = "touchmove mousemove";
        var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";
        function Elements(Splide2, Components2, options) {
            var _EventInterface = EventInterface(Splide2), on = _EventInterface.on, bind = _EventInterface.bind;
            var root = Splide2.root;
            var i18n = options.i18n;
            var elements = {};
            var slides = [];
            var rootClasses = [];
            var trackClasses = [];
            var track;
            var list;
            var isUsingKey;
            function setup() {
                collect();
                init();
                update();
            }
            function mount() {
                on(EVENT_REFRESH, destroy);
                on(EVENT_REFRESH, setup);
                on(EVENT_UPDATED, update);
                bind(document, POINTER_DOWN_EVENTS + " keydown", (function(e) {
                    isUsingKey = e.type === "keydown";
                }), {
                    capture: true
                });
                bind(root, "focusin", (function() {
                    toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
                }));
            }
            function destroy(completely) {
                var attrs = ALL_ATTRIBUTES.concat("style");
                empty(slides);
                removeClass(root, rootClasses);
                removeClass(track, trackClasses);
                removeAttribute([ track, list ], attrs);
                removeAttribute(root, completely ? attrs : [ "style", ARIA_ROLEDESCRIPTION ]);
            }
            function update() {
                removeClass(root, rootClasses);
                removeClass(track, trackClasses);
                rootClasses = getClasses(CLASS_ROOT);
                trackClasses = getClasses(CLASS_TRACK);
                addClass(root, rootClasses);
                addClass(track, trackClasses);
                setAttribute(root, ARIA_LABEL, options.label);
                setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
            }
            function collect() {
                track = find("." + CLASS_TRACK);
                list = child(track, "." + CLASS_LIST);
                assert(track && list, "A track/list element is missing.");
                push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
                forOwn({
                    arrows: CLASS_ARROWS,
                    pagination: CLASS_PAGINATION,
                    prev: CLASS_ARROW_PREV,
                    next: CLASS_ARROW_NEXT,
                    bar: CLASS_PROGRESS_BAR,
                    toggle: CLASS_TOGGLE
                }, (function(className, key) {
                    elements[key] = find("." + className);
                }));
                splide_esm_assign(elements, {
                    root,
                    track,
                    list,
                    slides
                });
            }
            function init() {
                var id = root.id || uniqueId(PROJECT_CODE);
                var role = options.role;
                root.id = id;
                track.id = track.id || id + "-track";
                list.id = list.id || id + "-list";
                if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) setAttribute(root, ROLE, role);
                setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
                setAttribute(list, ROLE, "presentation");
            }
            function find(selector) {
                var elm = query(root, selector);
                return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
            }
            function getClasses(base) {
                return [ base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE ];
            }
            return splide_esm_assign(elements, {
                setup,
                mount,
                destroy
            });
        }
        var SLIDE = "slide";
        var LOOP = "loop";
        var FADE = "fade";
        function Slide$1(Splide2, index, slideIndex, slide) {
            var event = EventInterface(Splide2);
            var on = event.on, emit = event.emit, bind = event.bind;
            var Components = Splide2.Components, root = Splide2.root, options = Splide2.options;
            var isNavigation = options.isNavigation, updateOnMove = options.updateOnMove, i18n = options.i18n, pagination = options.pagination, slideFocus = options.slideFocus;
            var resolve = Components.Direction.resolve;
            var styles = getAttribute(slide, "style");
            var label = getAttribute(slide, ARIA_LABEL);
            var isClone = slideIndex > -1;
            var container = child(slide, "." + CLASS_CONTAINER);
            var destroyed;
            function mount() {
                if (!isClone) {
                    slide.id = root.id + "-slide" + pad(index + 1);
                    setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
                    setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
                    setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [ index + 1, Splide2.length ]));
                }
                listen();
            }
            function listen() {
                bind(slide, "click", apply(emit, EVENT_CLICK, self));
                bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
                on([ EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED ], update);
                on(EVENT_NAVIGATION_MOUNTED, initNavigation);
                if (updateOnMove) on(EVENT_MOVE, onMove);
            }
            function destroy() {
                destroyed = true;
                event.destroy();
                removeClass(slide, STATUS_CLASSES);
                removeAttribute(slide, ALL_ATTRIBUTES);
                setAttribute(slide, "style", styles);
                setAttribute(slide, ARIA_LABEL, label || "");
            }
            function initNavigation() {
                var controls = Splide2.splides.map((function(target) {
                    var Slide2 = target.splide.Components.Slides.getAt(index);
                    return Slide2 ? Slide2.slide.id : "";
                })).join(" ");
                setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
                setAttribute(slide, ARIA_CONTROLS, controls);
                setAttribute(slide, ROLE, slideFocus ? "button" : "");
                slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
            }
            function onMove() {
                if (!destroyed) update();
            }
            function update() {
                if (!destroyed) {
                    var curr = Splide2.index;
                    updateActivity();
                    updateVisibility();
                    toggleClass(slide, CLASS_PREV, index === curr - 1);
                    toggleClass(slide, CLASS_NEXT, index === curr + 1);
                }
            }
            function updateActivity() {
                var active = isActive();
                if (active !== hasClass(slide, CLASS_ACTIVE)) {
                    toggleClass(slide, CLASS_ACTIVE, active);
                    setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
                    emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
                }
            }
            function updateVisibility() {
                var visible = isVisible();
                var hidden = !visible && (!isActive() || isClone);
                if (!Splide2.state.is([ MOVING, SCROLLING ])) setAttribute(slide, ARIA_HIDDEN, hidden || "");
                setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");
                if (slideFocus) setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
                if (visible !== hasClass(slide, CLASS_VISIBLE)) {
                    toggleClass(slide, CLASS_VISIBLE, visible);
                    emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
                }
                if (!visible && document.activeElement === slide) {
                    var Slide2 = Components.Slides.getAt(Splide2.index);
                    Slide2 && splide_esm_focus(Slide2.slide);
                }
            }
            function style$1(prop, value, useContainer) {
                style(useContainer && container || slide, prop, value);
            }
            function isActive() {
                var curr = Splide2.index;
                return curr === index || options.cloneStatus && curr === slideIndex;
            }
            function isVisible() {
                if (Splide2.is(FADE)) return isActive();
                var trackRect = rect(Components.Elements.track);
                var slideRect = rect(slide);
                var left = resolve("left", true);
                var right = resolve("right", true);
                return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
            }
            function isWithin(from, distance) {
                var diff = abs(from - index);
                if (!isClone && (options.rewind || Splide2.is(LOOP))) diff = min(diff, Splide2.length - diff);
                return diff <= distance;
            }
            var self = {
                index,
                slideIndex,
                slide,
                container,
                isClone,
                mount,
                destroy,
                update,
                style: style$1,
                isWithin
            };
            return self;
        }
        function Slides(Splide2, Components2, options) {
            var _EventInterface2 = EventInterface(Splide2), on = _EventInterface2.on, emit = _EventInterface2.emit, bind = _EventInterface2.bind;
            var _Components2$Elements = Components2.Elements, slides = _Components2$Elements.slides, list = _Components2$Elements.list;
            var Slides2 = [];
            function mount() {
                init();
                on(EVENT_REFRESH, destroy);
                on(EVENT_REFRESH, init);
            }
            function init() {
                slides.forEach((function(slide, index) {
                    register(slide, index, -1);
                }));
            }
            function destroy() {
                forEach$1((function(Slide2) {
                    Slide2.destroy();
                }));
                empty(Slides2);
            }
            function update() {
                forEach$1((function(Slide2) {
                    Slide2.update();
                }));
            }
            function register(slide, index, slideIndex) {
                var object = Slide$1(Splide2, index, slideIndex, slide);
                object.mount();
                Slides2.push(object);
                Slides2.sort((function(Slide1, Slide2) {
                    return Slide1.index - Slide2.index;
                }));
            }
            function get(excludeClones) {
                return excludeClones ? filter((function(Slide2) {
                    return !Slide2.isClone;
                })) : Slides2;
            }
            function getIn(page) {
                var Controller = Components2.Controller;
                var index = Controller.toIndex(page);
                var max = Controller.hasFocus() ? 1 : options.perPage;
                return filter((function(Slide2) {
                    return between(Slide2.index, index, index + max - 1);
                }));
            }
            function getAt(index) {
                return filter(index)[0];
            }
            function add(items, index) {
                forEach(items, (function(slide) {
                    if (isString(slide)) slide = parseHtml(slide);
                    if (isHTMLElement(slide)) {
                        var ref = slides[index];
                        ref ? before(slide, ref) : append(list, slide);
                        addClass(slide, options.classes.slide);
                        observeImages(slide, apply(emit, EVENT_RESIZE));
                    }
                }));
                emit(EVENT_REFRESH);
            }
            function remove$1(matcher) {
                remove(filter(matcher).map((function(Slide2) {
                    return Slide2.slide;
                })));
                emit(EVENT_REFRESH);
            }
            function forEach$1(iteratee, excludeClones) {
                get(excludeClones).forEach(iteratee);
            }
            function filter(matcher) {
                return Slides2.filter(isFunction(matcher) ? matcher : function(Slide2) {
                    return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
                });
            }
            function style(prop, value, useContainer) {
                forEach$1((function(Slide2) {
                    Slide2.style(prop, value, useContainer);
                }));
            }
            function observeImages(elm, callback) {
                var images = queryAll(elm, "img");
                var length = images.length;
                if (length) images.forEach((function(img) {
                    bind(img, "load error", (function() {
                        if (! --length) callback();
                    }));
                })); else callback();
            }
            function getLength(excludeClones) {
                return excludeClones ? slides.length : Slides2.length;
            }
            function isEnough() {
                return Slides2.length > options.perPage;
            }
            return {
                mount,
                destroy,
                update,
                register,
                get,
                getIn,
                getAt,
                add,
                remove: remove$1,
                forEach: forEach$1,
                filter,
                style,
                getLength,
                isEnough
            };
        }
        function Layout(Splide2, Components2, options) {
            var _EventInterface3 = EventInterface(Splide2), on = _EventInterface3.on, bind = _EventInterface3.bind, emit = _EventInterface3.emit;
            var Slides = Components2.Slides;
            var resolve = Components2.Direction.resolve;
            var _Components2$Elements2 = Components2.Elements, root = _Components2$Elements2.root, track = _Components2$Elements2.track, list = _Components2$Elements2.list;
            var getAt = Slides.getAt, styleSlides = Slides.style;
            var vertical;
            var rootRect;
            var overflow;
            function mount() {
                init();
                bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
                on([ EVENT_UPDATED, EVENT_REFRESH ], init);
                on(EVENT_RESIZE, resize);
            }
            function init() {
                vertical = options.direction === TTB;
                style(root, "maxWidth", unit(options.width));
                style(track, resolve("paddingLeft"), cssPadding(false));
                style(track, resolve("paddingRight"), cssPadding(true));
                resize(true);
            }
            function resize(force) {
                var newRect = rect(root);
                if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
                    style(track, "height", cssTrackHeight());
                    styleSlides(resolve("marginRight"), unit(options.gap));
                    styleSlides("width", cssSlideWidth());
                    styleSlides("height", cssSlideHeight(), true);
                    rootRect = newRect;
                    emit(EVENT_RESIZED);
                    if (overflow !== (overflow = isOverflow())) {
                        toggleClass(root, CLASS_OVERFLOW, overflow);
                        emit(EVENT_OVERFLOW, overflow);
                    }
                }
            }
            function cssPadding(right) {
                var padding = options.padding;
                var prop = resolve(right ? "right" : "left");
                return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
            }
            function cssTrackHeight() {
                var height = "";
                if (vertical) {
                    height = cssHeight();
                    assert(height, "height or heightRatio is missing.");
                    height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
                }
                return height;
            }
            function cssHeight() {
                return unit(options.height || rect(list).width * options.heightRatio);
            }
            function cssSlideWidth() {
                return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
            }
            function cssSlideHeight() {
                return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
            }
            function cssSlideSize() {
                var gap = unit(options.gap);
                return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
            }
            function listSize() {
                return rect(list)[resolve("width")];
            }
            function slideSize(index, withoutGap) {
                var Slide = getAt(index || 0);
                return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
            }
            function totalSize(index, withoutGap) {
                var Slide = getAt(index);
                if (Slide) {
                    var right = rect(Slide.slide)[resolve("right")];
                    var left = rect(list)[resolve("left")];
                    return abs(right - left) + (withoutGap ? 0 : getGap());
                }
                return 0;
            }
            function sliderSize(withoutGap) {
                return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
            }
            function getGap() {
                var Slide = getAt(0);
                return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
            }
            function getPadding(right) {
                return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
            }
            function isOverflow() {
                return Splide2.is(FADE) || sliderSize(true) > listSize();
            }
            return {
                mount,
                resize,
                listSize,
                slideSize,
                sliderSize,
                totalSize,
                getPadding,
                isOverflow
            };
        }
        var MULTIPLIER = 2;
        function Clones(Splide2, Components2, options) {
            var event = EventInterface(Splide2);
            var on = event.on;
            var Elements = Components2.Elements, Slides = Components2.Slides;
            var resolve = Components2.Direction.resolve;
            var clones = [];
            var cloneCount;
            function mount() {
                on(EVENT_REFRESH, remount);
                on([ EVENT_UPDATED, EVENT_RESIZE ], observe);
                if (cloneCount = computeCloneCount()) {
                    generate(cloneCount);
                    Components2.Layout.resize(true);
                }
            }
            function remount() {
                destroy();
                mount();
            }
            function destroy() {
                remove(clones);
                empty(clones);
                event.destroy();
            }
            function observe() {
                var count = computeCloneCount();
                if (cloneCount !== count) if (cloneCount < count || !count) event.emit(EVENT_REFRESH);
            }
            function generate(count) {
                var slides = Slides.get().slice();
                var length = slides.length;
                if (length) {
                    while (slides.length < count) push(slides, slides);
                    push(slides.slice(-count), slides.slice(0, count)).forEach((function(Slide, index) {
                        var isHead = index < count;
                        var clone = cloneDeep(Slide.slide, index);
                        isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
                        push(clones, clone);
                        Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
                    }));
                }
            }
            function cloneDeep(elm, index) {
                var clone = elm.cloneNode(true);
                addClass(clone, options.classes.clone);
                clone.id = Splide2.root.id + "-clone" + pad(index + 1);
                return clone;
            }
            function computeCloneCount() {
                var clones2 = options.clones;
                if (!Splide2.is(LOOP)) clones2 = 0; else if (isUndefined(clones2)) {
                    var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
                    var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
                    clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
                }
                return clones2;
            }
            return {
                mount,
                destroy
            };
        }
        function Move(Splide2, Components2, options) {
            var _EventInterface4 = EventInterface(Splide2), on = _EventInterface4.on, emit = _EventInterface4.emit;
            var set = Splide2.state.set;
            var _Components2$Layout = Components2.Layout, slideSize = _Components2$Layout.slideSize, getPadding = _Components2$Layout.getPadding, totalSize = _Components2$Layout.totalSize, listSize = _Components2$Layout.listSize, sliderSize = _Components2$Layout.sliderSize;
            var _Components2$Directio = Components2.Direction, resolve = _Components2$Directio.resolve, orient = _Components2$Directio.orient;
            var _Components2$Elements3 = Components2.Elements, list = _Components2$Elements3.list, track = _Components2$Elements3.track;
            var Transition;
            function mount() {
                Transition = Components2.Transition;
                on([ EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH ], reposition);
            }
            function reposition() {
                if (!Components2.Controller.isBusy()) {
                    Components2.Scroll.cancel();
                    jump(Splide2.index);
                    Components2.Slides.update();
                }
            }
            function move(dest, index, prev, callback) {
                if (dest !== index && canShift(dest > prev)) {
                    cancel();
                    translate(shift(getPosition(), dest > prev), true);
                }
                set(MOVING);
                emit(EVENT_MOVE, index, prev, dest);
                Transition.start(index, (function() {
                    set(IDLE);
                    emit(EVENT_MOVED, index, prev, dest);
                    callback && callback();
                }));
            }
            function jump(index) {
                translate(toPosition(index, true));
            }
            function translate(position, preventLoop) {
                if (!Splide2.is(FADE)) {
                    var destination = preventLoop ? position : loop(position);
                    style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
                    position !== destination && emit(EVENT_SHIFTED);
                }
            }
            function loop(position) {
                if (Splide2.is(LOOP)) {
                    var index = toIndex(position);
                    var exceededMax = index > Components2.Controller.getEnd();
                    var exceededMin = index < 0;
                    if (exceededMin || exceededMax) position = shift(position, exceededMax);
                }
                return position;
            }
            function shift(position, backwards) {
                var excess = position - getLimit(backwards);
                var size = sliderSize();
                position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
                return position;
            }
            function cancel() {
                translate(getPosition(), true);
                Transition.cancel();
            }
            function toIndex(position) {
                var Slides = Components2.Slides.get();
                var index = 0;
                var minDistance = 1 / 0;
                for (var i = 0; i < Slides.length; i++) {
                    var slideIndex = Slides[i].index;
                    var distance = abs(toPosition(slideIndex, true) - position);
                    if (distance <= minDistance) {
                        minDistance = distance;
                        index = slideIndex;
                    } else break;
                }
                return index;
            }
            function toPosition(index, trimming) {
                var position = orient(totalSize(index - 1) - offset(index));
                return trimming ? trim(position) : position;
            }
            function getPosition() {
                var left = resolve("left");
                return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
            }
            function trim(position) {
                if (options.trimSpace && Splide2.is(SLIDE)) position = clamp(position, 0, orient(sliderSize(true) - listSize()));
                return position;
            }
            function offset(index) {
                var focus = options.focus;
                return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
            }
            function getLimit(max) {
                return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
            }
            function canShift(backwards) {
                var shifted = orient(shift(getPosition(), backwards));
                return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
            }
            function exceededLimit(max, position) {
                position = isUndefined(position) ? getPosition() : position;
                var exceededMin = max !== true && orient(position) < orient(getLimit(false));
                var exceededMax = max !== false && orient(position) > orient(getLimit(true));
                return exceededMin || exceededMax;
            }
            return {
                mount,
                move,
                jump,
                translate,
                shift,
                cancel,
                toIndex,
                toPosition,
                getPosition,
                getLimit,
                exceededLimit,
                reposition
            };
        }
        function Controller(Splide2, Components2, options) {
            var _EventInterface5 = EventInterface(Splide2), on = _EventInterface5.on, emit = _EventInterface5.emit;
            var Move = Components2.Move;
            var getPosition = Move.getPosition, getLimit = Move.getLimit, toPosition = Move.toPosition;
            var _Components2$Slides = Components2.Slides, isEnough = _Components2$Slides.isEnough, getLength = _Components2$Slides.getLength;
            var omitEnd = options.omitEnd;
            var isLoop = Splide2.is(LOOP);
            var isSlide = Splide2.is(SLIDE);
            var getNext = apply(getAdjacent, false);
            var getPrev = apply(getAdjacent, true);
            var currIndex = options.start || 0;
            var endIndex;
            var prevIndex = currIndex;
            var slideCount;
            var perMove;
            var perPage;
            function mount() {
                init();
                on([ EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED ], init);
                on(EVENT_RESIZED, onResized);
            }
            function init() {
                slideCount = getLength(true);
                perMove = options.perMove;
                perPage = options.perPage;
                endIndex = getEnd();
                var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);
                if (index !== currIndex) {
                    currIndex = index;
                    Move.reposition();
                }
            }
            function onResized() {
                if (endIndex !== getEnd()) emit(EVENT_END_INDEX_CHANGED);
            }
            function go(control, allowSameIndex, callback) {
                if (!isBusy()) {
                    var dest = parse(control);
                    var index = loop(dest);
                    if (index > -1 && (allowSameIndex || index !== currIndex)) {
                        setIndex(index);
                        Move.move(dest, index, prevIndex, callback);
                    }
                }
            }
            function scroll(destination, duration, snap, callback) {
                Components2.Scroll.scroll(destination, duration, snap, (function() {
                    var index = loop(Move.toIndex(getPosition()));
                    setIndex(omitEnd ? min(index, endIndex) : index);
                    callback && callback();
                }));
            }
            function parse(control) {
                var index = currIndex;
                if (isString(control)) {
                    var _ref = control.match(/([+\-<>])(\d+)?/) || [], indicator = _ref[1], number = _ref[2];
                    if (indicator === "+" || indicator === "-") index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex); else if (indicator === ">") index = number ? toIndex(+number) : getNext(true); else if (indicator === "<") index = getPrev(true);
                } else index = isLoop ? control : clamp(control, 0, endIndex);
                return index;
            }
            function getAdjacent(prev, destination) {
                var number = perMove || (hasFocus() ? 1 : perPage);
                var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));
                if (dest === -1 && isSlide) if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) return prev ? 0 : endIndex;
                return destination ? dest : loop(dest);
            }
            function computeDestIndex(dest, from, snapPage) {
                if (isEnough() || hasFocus()) {
                    var index = computeMovableDestIndex(dest);
                    if (index !== dest) {
                        from = dest;
                        dest = index;
                        snapPage = false;
                    }
                    if (dest < 0 || dest > endIndex) if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) dest = toIndex(toPage(dest)); else if (isLoop) dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest; else if (options.rewind) dest = dest < 0 ? endIndex : 0; else dest = -1; else if (snapPage && dest !== from) dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
                } else dest = -1;
                return dest;
            }
            function computeMovableDestIndex(dest) {
                if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
                    var position = getPosition();
                    while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) dest < currIndex ? --dest : ++dest;
                }
                return dest;
            }
            function loop(index) {
                return isLoop ? (index + slideCount) % slideCount || 0 : index;
            }
            function getEnd() {
                var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);
                while (omitEnd && end-- > 0) if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
                    end++;
                    break;
                }
                return clamp(end, 0, slideCount - 1);
            }
            function toIndex(page) {
                return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
            }
            function toPage(index) {
                return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
            }
            function toDest(destination) {
                var closest = Move.toIndex(destination);
                return isSlide ? clamp(closest, 0, endIndex) : closest;
            }
            function setIndex(index) {
                if (index !== currIndex) {
                    prevIndex = currIndex;
                    currIndex = index;
                }
            }
            function getIndex(prev) {
                return prev ? prevIndex : currIndex;
            }
            function hasFocus() {
                return !isUndefined(options.focus) || options.isNavigation;
            }
            function isBusy() {
                return Splide2.state.is([ MOVING, SCROLLING ]) && !!options.waitForTransition;
            }
            return {
                mount,
                go,
                scroll,
                getNext,
                getPrev,
                getAdjacent,
                getEnd,
                setIndex,
                getIndex,
                toIndex,
                toPage,
                toDest,
                hasFocus,
                isBusy
            };
        }
        var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
        var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
        var SIZE = 40;
        function Arrows(Splide2, Components2, options) {
            var event = EventInterface(Splide2);
            var on = event.on, bind = event.bind, emit = event.emit;
            var classes = options.classes, i18n = options.i18n;
            var Elements = Components2.Elements, Controller = Components2.Controller;
            var placeholder = Elements.arrows, track = Elements.track;
            var wrapper = placeholder;
            var prev = Elements.prev;
            var next = Elements.next;
            var created;
            var wrapperClasses;
            var arrows = {};
            function mount() {
                init();
                on(EVENT_UPDATED, remount);
            }
            function remount() {
                destroy();
                mount();
            }
            function init() {
                var enabled = options.arrows;
                if (enabled && !(prev && next)) createArrows();
                if (prev && next) {
                    splide_esm_assign(arrows, {
                        prev,
                        next
                    });
                    display(wrapper, enabled ? "" : "none");
                    addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);
                    if (enabled) {
                        listen();
                        update();
                        setAttribute([ prev, next ], ARIA_CONTROLS, track.id);
                        emit(EVENT_ARROWS_MOUNTED, prev, next);
                    }
                }
            }
            function destroy() {
                event.destroy();
                removeClass(wrapper, wrapperClasses);
                if (created) {
                    remove(placeholder ? [ prev, next ] : wrapper);
                    prev = next = null;
                } else removeAttribute([ prev, next ], ALL_ATTRIBUTES);
            }
            function listen() {
                on([ EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED ], update);
                bind(next, "click", apply(go, ">"));
                bind(prev, "click", apply(go, "<"));
            }
            function go(control) {
                Controller.go(control, true);
            }
            function createArrows() {
                wrapper = placeholder || create("div", classes.arrows);
                prev = createArrow(true);
                next = createArrow(false);
                created = true;
                append(wrapper, [ prev, next ]);
                !placeholder && before(wrapper, track);
            }
            function createArrow(prev2) {
                var arrow = '<button class="' + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + '" type="button"><svg xmlns="' + XML_NAME_SPACE + '" viewBox="0 0 ' + SIZE + " " + SIZE + '" width="' + SIZE + '" height="' + SIZE + '" focusable="false"><path d="' + (options.arrowPath || PATH) + '" />';
                return parseHtml(arrow);
            }
            function update() {
                if (prev && next) {
                    var index = Splide2.index;
                    var prevIndex = Controller.getPrev();
                    var nextIndex = Controller.getNext();
                    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
                    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
                    prev.disabled = prevIndex < 0;
                    next.disabled = nextIndex < 0;
                    setAttribute(prev, ARIA_LABEL, prevLabel);
                    setAttribute(next, ARIA_LABEL, nextLabel);
                    emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
                }
            }
            return {
                arrows,
                mount,
                destroy,
                update
            };
        }
        var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";
        function Autoplay(Splide2, Components2, options) {
            var _EventInterface6 = EventInterface(Splide2), on = _EventInterface6.on, bind = _EventInterface6.bind, emit = _EventInterface6.emit;
            var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
            var isPaused = interval.isPaused;
            var Elements = Components2.Elements, _Components2$Elements4 = Components2.Elements, root = _Components2$Elements4.root, toggle = _Components2$Elements4.toggle;
            var autoplay = options.autoplay;
            var hovered;
            var focused;
            var stopped = autoplay === "pause";
            function mount() {
                if (autoplay) {
                    listen();
                    toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
                    stopped || play();
                    update();
                }
            }
            function listen() {
                if (options.pauseOnHover) bind(root, "mouseenter mouseleave", (function(e) {
                    hovered = e.type === "mouseenter";
                    autoToggle();
                }));
                if (options.pauseOnFocus) bind(root, "focusin focusout", (function(e) {
                    focused = e.type === "focusin";
                    autoToggle();
                }));
                if (toggle) bind(toggle, "click", (function() {
                    stopped ? play() : pause(true);
                }));
                on([ EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH ], interval.rewind);
                on(EVENT_MOVE, onMove);
            }
            function play() {
                if (isPaused() && Components2.Slides.isEnough()) {
                    interval.start(!options.resetProgress);
                    focused = hovered = stopped = false;
                    update();
                    emit(EVENT_AUTOPLAY_PLAY);
                }
            }
            function pause(stop) {
                if (stop === void 0) stop = true;
                stopped = !!stop;
                update();
                if (!isPaused()) {
                    interval.pause();
                    emit(EVENT_AUTOPLAY_PAUSE);
                }
            }
            function autoToggle() {
                if (!stopped) hovered || focused ? pause(false) : play();
            }
            function update() {
                if (toggle) {
                    toggleClass(toggle, CLASS_ACTIVE, !stopped);
                    setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
                }
            }
            function onAnimationFrame(rate) {
                var bar = Elements.bar;
                bar && style(bar, "width", rate * 100 + "%");
                emit(EVENT_AUTOPLAY_PLAYING, rate);
            }
            function onMove(index) {
                var Slide = Components2.Slides.getAt(index);
                interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
            }
            return {
                mount,
                destroy: interval.cancel,
                play,
                pause,
                isPaused
            };
        }
        function Cover(Splide2, Components2, options) {
            var _EventInterface7 = EventInterface(Splide2), on = _EventInterface7.on;
            function mount() {
                if (options.cover) {
                    on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
                    on([ EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH ], apply(cover, true));
                }
            }
            function cover(cover2) {
                Components2.Slides.forEach((function(Slide) {
                    var img = child(Slide.container || Slide.slide, "img");
                    if (img && img.src) toggle(cover2, img, Slide);
                }));
            }
            function toggle(cover2, img, Slide) {
                Slide.style("background", cover2 ? 'center/cover no-repeat url("' + img.src + '")' : "", true);
                display(img, cover2 ? "none" : "");
            }
            return {
                mount,
                destroy: apply(cover, false)
            };
        }
        var BOUNCE_DIFF_THRESHOLD = 10;
        var BOUNCE_DURATION = 600;
        var FRICTION_FACTOR = .6;
        var BASE_VELOCITY = 1.5;
        var MIN_DURATION = 800;
        function Scroll(Splide2, Components2, options) {
            var _EventInterface8 = EventInterface(Splide2), on = _EventInterface8.on, emit = _EventInterface8.emit;
            var set = Splide2.state.set;
            var Move = Components2.Move;
            var getPosition = Move.getPosition, getLimit = Move.getLimit, exceededLimit = Move.exceededLimit, translate = Move.translate;
            var isSlide = Splide2.is(SLIDE);
            var interval;
            var callback;
            var friction = 1;
            function mount() {
                on(EVENT_MOVE, clear);
                on([ EVENT_UPDATED, EVENT_REFRESH ], cancel);
            }
            function scroll(destination, duration, snap, onScrolled, noConstrain) {
                var from = getPosition();
                clear();
                if (snap && (!isSlide || !exceededLimit())) {
                    var size = Components2.Layout.sliderSize();
                    var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
                    destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
                }
                var noDistance = approximatelyEqual(from, destination, 1);
                friction = 1;
                duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
                callback = onScrolled;
                interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
                set(SCROLLING);
                emit(EVENT_SCROLL);
                interval.start();
            }
            function onEnd() {
                set(IDLE);
                callback && callback();
                emit(EVENT_SCROLLED);
            }
            function update(from, to, noConstrain, rate) {
                var position = getPosition();
                var target = from + (to - from) * easing(rate);
                var diff = (target - position) * friction;
                translate(position + diff);
                if (isSlide && !noConstrain && exceededLimit()) {
                    friction *= FRICTION_FACTOR;
                    if (abs(diff) < BOUNCE_DIFF_THRESHOLD) scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
                }
            }
            function clear() {
                if (interval) interval.cancel();
            }
            function cancel() {
                if (interval && !interval.isPaused()) {
                    clear();
                    onEnd();
                }
            }
            function easing(t) {
                var easingFunc = options.easingFunc;
                return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
            }
            return {
                mount,
                destroy: clear,
                scroll,
                cancel
            };
        }
        var SCROLL_LISTENER_OPTIONS = {
            passive: false,
            capture: true
        };
        function Drag(Splide2, Components2, options) {
            var _EventInterface9 = EventInterface(Splide2), on = _EventInterface9.on, emit = _EventInterface9.emit, bind = _EventInterface9.bind, unbind = _EventInterface9.unbind;
            var state = Splide2.state;
            var Move = Components2.Move, Scroll = Components2.Scroll, Controller = Components2.Controller, track = Components2.Elements.track, reduce = Components2.Media.reduce;
            var _Components2$Directio2 = Components2.Direction, resolve = _Components2$Directio2.resolve, orient = _Components2$Directio2.orient;
            var getPosition = Move.getPosition, exceededLimit = Move.exceededLimit;
            var basePosition;
            var baseEvent;
            var prevBaseEvent;
            var isFree;
            var dragging;
            var exceeded = false;
            var clickPrevented;
            var disabled;
            var target;
            function mount() {
                bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
                bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
                bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
                bind(track, "click", onClick, {
                    capture: true
                });
                bind(track, "dragstart", prevent);
                on([ EVENT_MOUNTED, EVENT_UPDATED ], init);
            }
            function init() {
                var drag = options.drag;
                disable(!drag);
                isFree = drag === "free";
            }
            function onPointerDown(e) {
                clickPrevented = false;
                if (!disabled) {
                    var isTouch = isTouchEvent(e);
                    if (isDraggable(e.target) && (isTouch || !e.button)) if (!Controller.isBusy()) {
                        target = isTouch ? track : window;
                        dragging = state.is([ MOVING, SCROLLING ]);
                        prevBaseEvent = null;
                        bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
                        bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
                        Move.cancel();
                        Scroll.cancel();
                        save(e);
                    } else prevent(e, true);
                }
            }
            function onPointerMove(e) {
                if (!state.is(DRAGGING)) {
                    state.set(DRAGGING);
                    emit(EVENT_DRAG);
                }
                if (e.cancelable) if (dragging) {
                    Move.translate(basePosition + constrain(diffCoord(e)));
                    var expired = diffTime(e) > LOG_INTERVAL;
                    var hasExceeded = exceeded !== (exceeded = exceededLimit());
                    if (expired || hasExceeded) save(e);
                    clickPrevented = true;
                    emit(EVENT_DRAGGING);
                    prevent(e);
                } else if (isSliderDirection(e)) {
                    dragging = shouldStart(e);
                    prevent(e);
                }
            }
            function onPointerUp(e) {
                if (state.is(DRAGGING)) {
                    state.set(IDLE);
                    emit(EVENT_DRAGGED);
                }
                if (dragging) {
                    move(e);
                    prevent(e);
                }
                unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
                unbind(target, POINTER_UP_EVENTS, onPointerUp);
                dragging = false;
            }
            function onClick(e) {
                if (!disabled && clickPrevented) prevent(e, true);
            }
            function save(e) {
                prevBaseEvent = baseEvent;
                baseEvent = e;
                basePosition = getPosition();
            }
            function move(e) {
                var velocity = computeVelocity(e);
                var destination = computeDestination(velocity);
                var rewind = options.rewind && options.rewindByDrag;
                reduce(false);
                if (isFree) Controller.scroll(destination, 0, options.snap); else if (Splide2.is(FADE)) Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+"); else if (Splide2.is(SLIDE) && exceeded && rewind) Controller.go(exceededLimit(true) ? ">" : "<"); else Controller.go(Controller.toDest(destination), true);
                reduce(true);
            }
            function shouldStart(e) {
                var thresholds = options.dragMinThreshold;
                var isObj = isObject(thresholds);
                var mouse = isObj && thresholds.mouse || 0;
                var touch = (isObj ? thresholds.touch : +thresholds) || 10;
                return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
            }
            function isSliderDirection(e) {
                return abs(diffCoord(e)) > abs(diffCoord(e, true));
            }
            function computeVelocity(e) {
                if (Splide2.is(LOOP) || !exceeded) {
                    var time = diffTime(e);
                    if (time && time < LOG_INTERVAL) return diffCoord(e) / time;
                }
                return 0;
            }
            function computeDestination(velocity) {
                return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? 1 / 0 : Components2.Layout.listSize() * (options.flickMaxPages || 1));
            }
            function diffCoord(e, orthogonal) {
                return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
            }
            function diffTime(e) {
                return timeOf(e) - timeOf(getBaseEvent(e));
            }
            function getBaseEvent(e) {
                return baseEvent === e && prevBaseEvent || baseEvent;
            }
            function coordOf(e, orthogonal) {
                return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
            }
            function constrain(diff) {
                return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
            }
            function isDraggable(target2) {
                var noDrag = options.noDrag;
                return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
            }
            function isTouchEvent(e) {
                return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
            }
            function isDragging() {
                return dragging;
            }
            function disable(value) {
                disabled = value;
            }
            return {
                mount,
                disable,
                isDragging
            };
        }
        var NORMALIZATION_MAP = {
            Spacebar: " ",
            Right: ARROW_RIGHT,
            Left: ARROW_LEFT,
            Up: ARROW_UP,
            Down: ARROW_DOWN
        };
        function normalizeKey(key) {
            key = isString(key) ? key : key.key;
            return NORMALIZATION_MAP[key] || key;
        }
        var KEYBOARD_EVENT = "keydown";
        function Keyboard(Splide2, Components2, options) {
            var _EventInterface10 = EventInterface(Splide2), on = _EventInterface10.on, bind = _EventInterface10.bind, unbind = _EventInterface10.unbind;
            var root = Splide2.root;
            var resolve = Components2.Direction.resolve;
            var target;
            var disabled;
            function mount() {
                init();
                on(EVENT_UPDATED, destroy);
                on(EVENT_UPDATED, init);
                on(EVENT_MOVE, onMove);
            }
            function init() {
                var keyboard = options.keyboard;
                if (keyboard) {
                    target = keyboard === "global" ? window : root;
                    bind(target, KEYBOARD_EVENT, onKeydown);
                }
            }
            function destroy() {
                unbind(target, KEYBOARD_EVENT);
            }
            function disable(value) {
                disabled = value;
            }
            function onMove() {
                var _disabled = disabled;
                disabled = true;
                nextTick((function() {
                    disabled = _disabled;
                }));
            }
            function onKeydown(e) {
                if (!disabled) {
                    var key = normalizeKey(e);
                    if (key === resolve(ARROW_LEFT)) Splide2.go("<"); else if (key === resolve(ARROW_RIGHT)) Splide2.go(">");
                }
            }
            return {
                mount,
                destroy,
                disable
            };
        }
        var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
        var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
        var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";
        function LazyLoad(Splide2, Components2, options) {
            var _EventInterface11 = EventInterface(Splide2), on = _EventInterface11.on, off = _EventInterface11.off, bind = _EventInterface11.bind, emit = _EventInterface11.emit;
            var isSequential = options.lazyLoad === "sequential";
            var events = [ EVENT_MOVED, EVENT_SCROLLED ];
            var entries = [];
            function mount() {
                if (options.lazyLoad) {
                    init();
                    on(EVENT_REFRESH, init);
                }
            }
            function init() {
                empty(entries);
                register();
                if (isSequential) loadNext(); else {
                    off(events);
                    on(events, check);
                    check();
                }
            }
            function register() {
                Components2.Slides.forEach((function(Slide) {
                    queryAll(Slide.slide, IMAGE_SELECTOR).forEach((function(img) {
                        var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
                        var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);
                        if (src !== img.src || srcset !== img.srcset) {
                            var className = options.classes.spinner;
                            var parent = img.parentElement;
                            var spinner = child(parent, "." + className) || create("span", className, parent);
                            entries.push([ img, Slide, spinner ]);
                            img.src || display(img, "none");
                        }
                    }));
                }));
            }
            function check() {
                entries = entries.filter((function(data) {
                    var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
                    return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
                }));
                entries.length || off(events);
            }
            function load(data) {
                var img = data[0];
                addClass(data[1].slide, CLASS_LOADING);
                bind(img, "load error", apply(onLoad, data));
                setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
                setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
                removeAttribute(img, SRC_DATA_ATTRIBUTE);
                removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
            }
            function onLoad(data, e) {
                var img = data[0], Slide = data[1];
                removeClass(Slide.slide, CLASS_LOADING);
                if (e.type !== "error") {
                    remove(data[2]);
                    display(img, "");
                    emit(EVENT_LAZYLOAD_LOADED, img, Slide);
                    emit(EVENT_RESIZE);
                }
                isSequential && loadNext();
            }
            function loadNext() {
                entries.length && load(entries.shift());
            }
            return {
                mount,
                destroy: apply(empty, entries),
                check
            };
        }
        function Pagination(Splide2, Components2, options) {
            var event = EventInterface(Splide2);
            var on = event.on, emit = event.emit, bind = event.bind;
            var Slides = Components2.Slides, Elements = Components2.Elements, Controller = Components2.Controller;
            var hasFocus = Controller.hasFocus, getIndex = Controller.getIndex, go = Controller.go;
            var resolve = Components2.Direction.resolve;
            var placeholder = Elements.pagination;
            var items = [];
            var list;
            var paginationClasses;
            function mount() {
                destroy();
                on([ EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED ], mount);
                var enabled = options.pagination;
                placeholder && display(placeholder, enabled ? "" : "none");
                if (enabled) {
                    on([ EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED ], update);
                    createPagination();
                    update();
                    emit(EVENT_PAGINATION_MOUNTED, {
                        list,
                        items
                    }, getAt(Splide2.index));
                }
            }
            function destroy() {
                if (list) {
                    remove(placeholder ? slice(list.children) : list);
                    removeClass(list, paginationClasses);
                    empty(items);
                    list = null;
                }
                event.destroy();
            }
            function createPagination() {
                var length = Splide2.length;
                var classes = options.classes, i18n = options.i18n, perPage = options.perPage;
                var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
                list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
                addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
                setAttribute(list, ROLE, "tablist");
                setAttribute(list, ARIA_LABEL, i18n.select);
                setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");
                for (var i = 0; i < max; i++) {
                    var li = create("li", null, list);
                    var button = create("button", {
                        class: classes.page,
                        type: "button"
                    }, li);
                    var controls = Slides.getIn(i).map((function(Slide) {
                        return Slide.slide.id;
                    }));
                    var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
                    bind(button, "click", apply(onClick, i));
                    if (options.paginationKeyboard) bind(button, "keydown", apply(onKeydown, i));
                    setAttribute(li, ROLE, "presentation");
                    setAttribute(button, ROLE, "tab");
                    setAttribute(button, ARIA_CONTROLS, controls.join(" "));
                    setAttribute(button, ARIA_LABEL, format(text, i + 1));
                    setAttribute(button, TAB_INDEX, -1);
                    items.push({
                        li,
                        button,
                        page: i
                    });
                }
            }
            function onClick(page) {
                go(">" + page, true);
            }
            function onKeydown(page, e) {
                var length = items.length;
                var key = normalizeKey(e);
                var dir = getDirection();
                var nextPage = -1;
                if (key === resolve(ARROW_RIGHT, false, dir)) nextPage = ++page % length; else if (key === resolve(ARROW_LEFT, false, dir)) nextPage = (--page + length) % length; else if (key === "Home") nextPage = 0; else if (key === "End") nextPage = length - 1;
                var item = items[nextPage];
                if (item) {
                    splide_esm_focus(item.button);
                    go(">" + nextPage);
                    prevent(e, true);
                }
            }
            function getDirection() {
                return options.paginationDirection || options.direction;
            }
            function getAt(index) {
                return items[Controller.toPage(index)];
            }
            function update() {
                var prev = getAt(getIndex(true));
                var curr = getAt(getIndex());
                if (prev) {
                    var button = prev.button;
                    removeClass(button, CLASS_ACTIVE);
                    removeAttribute(button, ARIA_SELECTED);
                    setAttribute(button, TAB_INDEX, -1);
                }
                if (curr) {
                    var _button = curr.button;
                    addClass(_button, CLASS_ACTIVE);
                    setAttribute(_button, ARIA_SELECTED, true);
                    setAttribute(_button, TAB_INDEX, "");
                }
                emit(EVENT_PAGINATION_UPDATED, {
                    list,
                    items
                }, prev, curr);
            }
            return {
                items,
                mount,
                destroy,
                getAt,
                update
            };
        }
        var TRIGGER_KEYS = [ " ", "Enter" ];
        function Sync(Splide2, Components2, options) {
            var isNavigation = options.isNavigation, slideFocus = options.slideFocus;
            var events = [];
            function mount() {
                Splide2.splides.forEach((function(target) {
                    if (!target.isParent) {
                        sync(Splide2, target.splide);
                        sync(target.splide, Splide2);
                    }
                }));
                if (isNavigation) navigate();
            }
            function destroy() {
                events.forEach((function(event) {
                    event.destroy();
                }));
                empty(events);
            }
            function remount() {
                destroy();
                mount();
            }
            function sync(splide, target) {
                var event = EventInterface(splide);
                event.on(EVENT_MOVE, (function(index, prev, dest) {
                    target.go(target.is(LOOP) ? dest : index);
                }));
                events.push(event);
            }
            function navigate() {
                var event = EventInterface(Splide2);
                var on = event.on;
                on(EVENT_CLICK, onClick);
                on(EVENT_SLIDE_KEYDOWN, onKeydown);
                on([ EVENT_MOUNTED, EVENT_UPDATED ], update);
                events.push(event);
                event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
            }
            function update() {
                setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
            }
            function onClick(Slide) {
                Splide2.go(Slide.index);
            }
            function onKeydown(Slide, e) {
                if (includes(TRIGGER_KEYS, normalizeKey(e))) {
                    onClick(Slide);
                    prevent(e);
                }
            }
            return {
                setup: apply(Components2.Media.set, {
                    slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
                }, true),
                mount,
                destroy,
                remount
            };
        }
        function Wheel(Splide2, Components2, options) {
            var _EventInterface12 = EventInterface(Splide2), bind = _EventInterface12.bind;
            var lastTime = 0;
            function mount() {
                if (options.wheel) bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
            }
            function onWheel(e) {
                if (e.cancelable) {
                    var deltaY = e.deltaY;
                    var backwards = deltaY < 0;
                    var timeStamp = timeOf(e);
                    var _min = options.wheelMinThreshold || 0;
                    var sleep = options.wheelSleep || 0;
                    if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
                        Splide2.go(backwards ? "<" : ">");
                        lastTime = timeStamp;
                    }
                    shouldPrevent(backwards) && prevent(e);
                }
            }
            function shouldPrevent(backwards) {
                return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
            }
            return {
                mount
            };
        }
        var SR_REMOVAL_DELAY = 90;
        function Live(Splide2, Components2, options) {
            var _EventInterface13 = EventInterface(Splide2), on = _EventInterface13.on;
            var track = Components2.Elements.track;
            var enabled = options.live && !options.isNavigation;
            var sr = create("span", CLASS_SR);
            var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));
            function mount() {
                if (enabled) {
                    disable(!Components2.Autoplay.isPaused());
                    setAttribute(track, ARIA_ATOMIC, true);
                    sr.textContent = "…";
                    on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
                    on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
                    on([ EVENT_MOVED, EVENT_SCROLLED ], apply(toggle, true));
                }
            }
            function toggle(active) {
                setAttribute(track, ARIA_BUSY, active);
                if (active) {
                    append(track, sr);
                    interval.start();
                } else {
                    remove(sr);
                    interval.cancel();
                }
            }
            function destroy() {
                removeAttribute(track, [ ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY ]);
                remove(sr);
            }
            function disable(disabled) {
                if (enabled) setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
            }
            return {
                mount,
                disable,
                destroy
            };
        }
        var ComponentConstructors = Object.freeze({
            __proto__: null,
            Media,
            Direction,
            Elements,
            Slides,
            Layout,
            Clones,
            Move,
            Controller,
            Arrows,
            Autoplay,
            Cover,
            Scroll,
            Drag,
            Keyboard,
            LazyLoad,
            Pagination,
            Sync,
            Wheel,
            Live
        });
        var I18N = {
            prev: "Previous slide",
            next: "Next slide",
            first: "Go to first slide",
            last: "Go to last slide",
            slideX: "Go to slide %s",
            pageX: "Go to page %s",
            play: "Start autoplay",
            pause: "Pause autoplay",
            carousel: "carousel",
            slide: "slide",
            select: "Select a slide to show",
            slideLabel: "%s of %s"
        };
        var DEFAULTS = {
            type: "slide",
            role: "region",
            speed: 400,
            perPage: 1,
            cloneStatus: true,
            arrows: true,
            pagination: true,
            paginationKeyboard: true,
            interval: 5e3,
            pauseOnHover: true,
            pauseOnFocus: true,
            resetProgress: true,
            easing: "cubic-bezier(0.25, 1, 0.5, 1)",
            drag: true,
            direction: "ltr",
            trimSpace: true,
            focusableNodes: "a, button, textarea, input, select, iframe",
            live: true,
            classes: CLASSES,
            i18n: I18N,
            reducedMotion: {
                speed: 0,
                rewindSpeed: 0,
                autoplay: "pause"
            }
        };
        function Fade(Splide2, Components2, options) {
            var Slides = Components2.Slides;
            function mount() {
                EventInterface(Splide2).on([ EVENT_MOUNTED, EVENT_REFRESH ], init);
            }
            function init() {
                Slides.forEach((function(Slide) {
                    Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
                }));
            }
            function start(index, done) {
                Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
                nextTick(done);
            }
            return {
                mount,
                start,
                cancel: noop
            };
        }
        function Slide(Splide2, Components2, options) {
            var Move = Components2.Move, Controller = Components2.Controller, Scroll = Components2.Scroll;
            var list = Components2.Elements.list;
            var transition = apply(style, list, "transition");
            var endCallback;
            function mount() {
                EventInterface(Splide2).bind(list, "transitionend", (function(e) {
                    if (e.target === list && endCallback) {
                        cancel();
                        endCallback();
                    }
                }));
            }
            function start(index, done) {
                var destination = Move.toPosition(index, true);
                var position = Move.getPosition();
                var speed = getSpeed(index);
                if (abs(destination - position) >= 1 && speed >= 1) if (options.useScroll) Scroll.scroll(destination, speed, false, done); else {
                    transition("transform " + speed + "ms " + options.easing);
                    Move.translate(destination, true);
                    endCallback = done;
                } else {
                    Move.jump(index);
                    done();
                }
            }
            function cancel() {
                transition("");
                Scroll.cancel();
            }
            function getSpeed(index) {
                var rewindSpeed = options.rewindSpeed;
                if (Splide2.is(SLIDE) && rewindSpeed) {
                    var prev = Controller.getIndex(true);
                    var end = Controller.getEnd();
                    if (prev === 0 && index >= end || prev >= end && index === 0) return rewindSpeed;
                }
                return options.speed;
            }
            return {
                mount,
                start,
                cancel
            };
        }
        var _Splide = function() {
            function _Splide(target, options) {
                this.event = EventInterface();
                this.Components = {};
                this.state = State(CREATED);
                this.splides = [];
                this._o = {};
                this._E = {};
                var root = isString(target) ? query(document, target) : target;
                assert(root, root + " is invalid.");
                this.root = root;
                options = merge({
                    label: getAttribute(root, ARIA_LABEL) || "",
                    labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
                }, DEFAULTS, _Splide.defaults, options || {});
                try {
                    merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
                } catch (e) {
                    assert(false, "Invalid JSON");
                }
                this._o = Object.create(merge({}, options));
            }
            var _proto = _Splide.prototype;
            _proto.mount = function mount(Extensions, Transition) {
                var _this = this;
                var state = this.state, Components2 = this.Components;
                assert(state.is([ CREATED, DESTROYED ]), "Already mounted!");
                state.set(CREATED);
                this._C = Components2;
                this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
                this._E = Extensions || this._E;
                var Constructors = splide_esm_assign({}, ComponentConstructors, this._E, {
                    Transition: this._T
                });
                forOwn(Constructors, (function(Component, key) {
                    var component = Component(_this, Components2, _this._o);
                    Components2[key] = component;
                    component.setup && component.setup();
                }));
                forOwn(Components2, (function(component) {
                    component.mount && component.mount();
                }));
                this.emit(EVENT_MOUNTED);
                addClass(this.root, CLASS_INITIALIZED);
                state.set(IDLE);
                this.emit(EVENT_READY);
                return this;
            };
            _proto.sync = function sync(splide) {
                this.splides.push({
                    splide
                });
                splide.splides.push({
                    splide: this,
                    isParent: true
                });
                if (this.state.is(IDLE)) {
                    this._C.Sync.remount();
                    splide.Components.Sync.remount();
                }
                return this;
            };
            _proto.go = function go(control) {
                this._C.Controller.go(control);
                return this;
            };
            _proto.on = function on(events, callback) {
                this.event.on(events, callback);
                return this;
            };
            _proto.off = function off(events) {
                this.event.off(events);
                return this;
            };
            _proto.emit = function emit(event) {
                var _this$event;
                (_this$event = this.event).emit.apply(_this$event, [ event ].concat(slice(arguments, 1)));
                return this;
            };
            _proto.add = function add(slides, index) {
                this._C.Slides.add(slides, index);
                return this;
            };
            _proto.remove = function remove(matcher) {
                this._C.Slides.remove(matcher);
                return this;
            };
            _proto.is = function is(type) {
                return this._o.type === type;
            };
            _proto.refresh = function refresh() {
                this.emit(EVENT_REFRESH);
                return this;
            };
            _proto.destroy = function destroy(completely) {
                if (completely === void 0) completely = true;
                var event = this.event, state = this.state;
                if (state.is(CREATED)) EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely)); else {
                    forOwn(this._C, (function(component) {
                        component.destroy && component.destroy(completely);
                    }), true);
                    event.emit(EVENT_DESTROY);
                    event.destroy();
                    completely && empty(this.splides);
                    state.set(DESTROYED);
                }
                return this;
            };
            _createClass(_Splide, [ {
                key: "options",
                get: function get() {
                    return this._o;
                },
                set: function set(options) {
                    this._C.Media.set(options, true, true);
                }
            }, {
                key: "length",
                get: function get() {
                    return this._C.Slides.getLength(true);
                }
            }, {
                key: "index",
                get: function get() {
                    return this._C.Controller.getIndex();
                }
            } ]);
            return _Splide;
        }();
        var Splide = _Splide;
        Splide.defaults = {};
        Splide.STATES = STATES;
        var CLASS_RENDERED = "is-rendered";
        var RENDERER_DEFAULT_CONFIG = {
            listTag: "ul",
            slideTag: "li"
        };
        var Style = null && function() {
            function Style(id, options) {
                this.styles = {};
                this.id = id;
                this.options = options;
            }
            var _proto2 = Style.prototype;
            _proto2.rule = function rule(selector, prop, value, breakpoint) {
                breakpoint = breakpoint || "default";
                var selectors = this.styles[breakpoint] = this.styles[breakpoint] || {};
                var styles = selectors[selector] = selectors[selector] || {};
                styles[prop] = value;
            };
            _proto2.build = function build() {
                var _this2 = this;
                var css = "";
                if (this.styles.default) css += this.buildSelectors(this.styles.default);
                Object.keys(this.styles).sort((function(n, m) {
                    return _this2.options.mediaQuery === "min" ? +n - +m : +m - +n;
                })).forEach((function(breakpoint) {
                    if (breakpoint !== "default") {
                        css += "@media screen and (max-width: " + breakpoint + "px) {";
                        css += _this2.buildSelectors(_this2.styles[breakpoint]);
                        css += "}";
                    }
                }));
                return css;
            };
            _proto2.buildSelectors = function buildSelectors(selectors) {
                var _this3 = this;
                var css = "";
                forOwn(selectors, (function(styles, selector) {
                    selector = ("#" + _this3.id + " " + selector).trim();
                    css += selector + " {";
                    forOwn(styles, (function(value, prop) {
                        if (value || value === 0) css += prop + ": " + value + ";";
                    }));
                    css += "}";
                }));
                return css;
            };
            return Style;
        }();
        null && function() {
            function SplideRenderer(contents, options, config, defaults) {
                this.slides = [];
                this.options = {};
                this.breakpoints = [];
                merge(DEFAULTS, defaults || {});
                merge(merge(this.options, DEFAULTS), options || {});
                this.contents = contents;
                this.config = splide_esm_assign({}, RENDERER_DEFAULT_CONFIG, config || {});
                this.id = this.config.id || uniqueId("splide");
                this.Style = new Style(this.id, this.options);
                this.Direction = Direction(null, null, this.options);
                assert(this.contents.length, "Provide at least 1 content.");
                this.init();
            }
            SplideRenderer.clean = function clean(splide) {
                var _EventInterface14 = EventInterface(splide), on = _EventInterface14.on;
                var root = splide.root;
                var clones = queryAll(root, "." + CLASS_CLONE);
                on(EVENT_MOUNTED, (function() {
                    remove(child(root, "style"));
                }));
                remove(clones);
            };
            var _proto3 = SplideRenderer.prototype;
            _proto3.init = function init() {
                this.parseBreakpoints();
                this.initSlides();
                this.registerRootStyles();
                this.registerTrackStyles();
                this.registerSlideStyles();
                this.registerListStyles();
            };
            _proto3.initSlides = function initSlides() {
                var _this4 = this;
                push(this.slides, this.contents.map((function(content, index) {
                    content = isString(content) ? {
                        html: content
                    } : content;
                    content.styles = content.styles || {};
                    content.attrs = content.attrs || {};
                    _this4.cover(content);
                    var classes = _this4.options.classes.slide + " " + (index === 0 ? CLASS_ACTIVE : "");
                    splide_esm_assign(content.attrs, {
                        class: (classes + " " + (content.attrs.class || "")).trim(),
                        style: _this4.buildStyles(content.styles)
                    });
                    return content;
                })));
                if (this.isLoop()) this.generateClones(this.slides);
            };
            _proto3.registerRootStyles = function registerRootStyles() {
                var _this5 = this;
                this.breakpoints.forEach((function(_ref2) {
                    var width = _ref2[0], options = _ref2[1];
                    _this5.Style.rule(" ", "max-width", unit(options.width), width);
                }));
            };
            _proto3.registerTrackStyles = function registerTrackStyles() {
                var _this6 = this;
                var Style2 = this.Style;
                var selector = "." + CLASS_TRACK;
                this.breakpoints.forEach((function(_ref3) {
                    var width = _ref3[0], options = _ref3[1];
                    Style2.rule(selector, _this6.resolve("paddingLeft"), _this6.cssPadding(options, false), width);
                    Style2.rule(selector, _this6.resolve("paddingRight"), _this6.cssPadding(options, true), width);
                    Style2.rule(selector, "height", _this6.cssTrackHeight(options), width);
                }));
            };
            _proto3.registerListStyles = function registerListStyles() {
                var _this7 = this;
                var Style2 = this.Style;
                var selector = "." + CLASS_LIST;
                this.breakpoints.forEach((function(_ref4) {
                    var width = _ref4[0], options = _ref4[1];
                    Style2.rule(selector, "transform", _this7.buildTranslate(options), width);
                    if (!_this7.cssSlideHeight(options)) Style2.rule(selector, "aspect-ratio", _this7.cssAspectRatio(options), width);
                }));
            };
            _proto3.registerSlideStyles = function registerSlideStyles() {
                var _this8 = this;
                var Style2 = this.Style;
                var selector = "." + CLASS_SLIDE;
                this.breakpoints.forEach((function(_ref5) {
                    var width = _ref5[0], options = _ref5[1];
                    Style2.rule(selector, "width", _this8.cssSlideWidth(options), width);
                    Style2.rule(selector, "height", _this8.cssSlideHeight(options) || "100%", width);
                    Style2.rule(selector, _this8.resolve("marginRight"), unit(options.gap) || "0px", width);
                    Style2.rule(selector + " > img", "display", options.cover ? "none" : "inline", width);
                }));
            };
            _proto3.buildTranslate = function buildTranslate(options) {
                var _this$Direction = this.Direction, resolve = _this$Direction.resolve, orient = _this$Direction.orient;
                var values = [];
                values.push(this.cssOffsetClones(options));
                values.push(this.cssOffsetGaps(options));
                if (this.isCenter(options)) {
                    values.push(this.buildCssValue(orient(-50), "%"));
                    values.push.apply(values, this.cssOffsetCenter(options));
                }
                return values.filter(Boolean).map((function(value) {
                    return "translate" + resolve("X") + "(" + value + ")";
                })).join(" ");
            };
            _proto3.cssOffsetClones = function cssOffsetClones(options) {
                var _this$Direction2 = this.Direction, resolve = _this$Direction2.resolve, orient = _this$Direction2.orient;
                var cloneCount = this.getCloneCount();
                if (this.isFixedWidth(options)) {
                    var _this$parseCssValue = this.parseCssValue(options[resolve("fixedWidth")]), value = _this$parseCssValue.value, unit2 = _this$parseCssValue.unit;
                    return this.buildCssValue(orient(value) * cloneCount, unit2);
                }
                var percent = 100 * cloneCount / options.perPage;
                return orient(percent) + "%";
            };
            _proto3.cssOffsetCenter = function cssOffsetCenter(options) {
                var _this$Direction3 = this.Direction, resolve = _this$Direction3.resolve, orient = _this$Direction3.orient;
                if (this.isFixedWidth(options)) {
                    var _this$parseCssValue2 = this.parseCssValue(options[resolve("fixedWidth")]), value = _this$parseCssValue2.value, unit2 = _this$parseCssValue2.unit;
                    return [ this.buildCssValue(orient(value / 2), unit2) ];
                }
                var values = [];
                var perPage = options.perPage, gap = options.gap;
                values.push(orient(50 / perPage) + "%");
                if (gap) {
                    var _this$parseCssValue3 = this.parseCssValue(gap), _value = _this$parseCssValue3.value, _unit = _this$parseCssValue3.unit;
                    var gapOffset = (_value / perPage - _value) / 2;
                    values.push(this.buildCssValue(orient(gapOffset), _unit));
                }
                return values;
            };
            _proto3.cssOffsetGaps = function cssOffsetGaps(options) {
                var cloneCount = this.getCloneCount();
                if (cloneCount && options.gap) {
                    var orient = this.Direction.orient;
                    var _this$parseCssValue4 = this.parseCssValue(options.gap), value = _this$parseCssValue4.value, unit2 = _this$parseCssValue4.unit;
                    if (this.isFixedWidth(options)) return this.buildCssValue(orient(value * cloneCount), unit2);
                    var perPage = options.perPage;
                    var gaps = cloneCount / perPage;
                    return this.buildCssValue(orient(gaps * value), unit2);
                }
                return "";
            };
            _proto3.resolve = function resolve(prop) {
                return camelToKebab(this.Direction.resolve(prop));
            };
            _proto3.cssPadding = function cssPadding(options, right) {
                var padding = options.padding;
                var prop = this.Direction.resolve(right ? "right" : "left", true);
                return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
            };
            _proto3.cssTrackHeight = function cssTrackHeight(options) {
                var height = "";
                if (this.isVertical()) {
                    height = this.cssHeight(options);
                    assert(height, '"height" is missing.');
                    height = "calc(" + height + " - " + this.cssPadding(options, false) + " - " + this.cssPadding(options, true) + ")";
                }
                return height;
            };
            _proto3.cssHeight = function cssHeight(options) {
                return unit(options.height);
            };
            _proto3.cssSlideWidth = function cssSlideWidth(options) {
                return options.autoWidth ? "" : unit(options.fixedWidth) || (this.isVertical() ? "" : this.cssSlideSize(options));
            };
            _proto3.cssSlideHeight = function cssSlideHeight(options) {
                return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? "" : this.cssSlideSize(options) : this.cssHeight(options));
            };
            _proto3.cssSlideSize = function cssSlideSize(options) {
                var gap = unit(options.gap);
                return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
            };
            _proto3.cssAspectRatio = function cssAspectRatio(options) {
                var heightRatio = options.heightRatio;
                return heightRatio ? "" + 1 / heightRatio : "";
            };
            _proto3.buildCssValue = function buildCssValue(value, unit2) {
                return "" + value + unit2;
            };
            _proto3.parseCssValue = function parseCssValue(value) {
                if (isString(value)) {
                    var number = parseFloat(value) || 0;
                    var unit2 = value.replace(/\d*(\.\d*)?/, "") || "px";
                    return {
                        value: number,
                        unit: unit2
                    };
                }
                return {
                    value,
                    unit: "px"
                };
            };
            _proto3.parseBreakpoints = function parseBreakpoints() {
                var _this9 = this;
                var breakpoints = this.options.breakpoints;
                this.breakpoints.push([ "default", this.options ]);
                if (breakpoints) forOwn(breakpoints, (function(options, width) {
                    _this9.breakpoints.push([ width, merge(merge({}, _this9.options), options) ]);
                }));
            };
            _proto3.isFixedWidth = function isFixedWidth(options) {
                return !!options[this.Direction.resolve("fixedWidth")];
            };
            _proto3.isLoop = function isLoop() {
                return this.options.type === LOOP;
            };
            _proto3.isCenter = function isCenter(options) {
                if (options.focus === "center") {
                    if (this.isLoop()) return true;
                    if (this.options.type === SLIDE) return !this.options.trimSpace;
                }
                return false;
            };
            _proto3.isVertical = function isVertical() {
                return this.options.direction === TTB;
            };
            _proto3.buildClasses = function buildClasses() {
                var options = this.options;
                return [ CLASS_ROOT, CLASS_ROOT + "--" + options.type, CLASS_ROOT + "--" + options.direction, options.drag && CLASS_ROOT + "--draggable", options.isNavigation && CLASS_ROOT + "--nav", CLASS_ACTIVE, !this.config.hidden && CLASS_RENDERED ].filter(Boolean).join(" ");
            };
            _proto3.buildAttrs = function buildAttrs(attrs) {
                var attr = "";
                forOwn(attrs, (function(value, key) {
                    attr += value ? " " + camelToKebab(key) + '="' + value + '"' : "";
                }));
                return attr.trim();
            };
            _proto3.buildStyles = function buildStyles(styles) {
                var style = "";
                forOwn(styles, (function(value, key) {
                    style += " " + camelToKebab(key) + ":" + value + ";";
                }));
                return style.trim();
            };
            _proto3.renderSlides = function renderSlides() {
                var _this10 = this;
                var tag = this.config.slideTag;
                return this.slides.map((function(content) {
                    return "<" + tag + " " + _this10.buildAttrs(content.attrs) + ">" + (content.html || "") + "</" + tag + ">";
                })).join("");
            };
            _proto3.cover = function cover(content) {
                var styles = content.styles, _content$html = content.html, html = _content$html === void 0 ? "" : _content$html;
                if (this.options.cover && !this.options.lazyLoad) {
                    var src = html.match(/<img.*?src\s*=\s*(['"])(.+?)\1.*?>/);
                    if (src && src[2]) styles.background = "center/cover no-repeat url('" + src[2] + "')";
                }
            };
            _proto3.generateClones = function generateClones(contents) {
                var classes = this.options.classes;
                var count = this.getCloneCount();
                var slides = contents.slice();
                while (slides.length < count) push(slides, slides);
                push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach((function(content, index) {
                    var attrs = splide_esm_assign({}, content.attrs, {
                        class: content.attrs.class + " " + classes.clone
                    });
                    var clone = splide_esm_assign({}, content, {
                        attrs
                    });
                    index < count ? contents.unshift(clone) : contents.push(clone);
                }));
            };
            _proto3.getCloneCount = function getCloneCount() {
                if (this.isLoop()) {
                    var options = this.options;
                    if (options.clones) return options.clones;
                    var perPage = max.apply(void 0, this.breakpoints.map((function(_ref6) {
                        var options2 = _ref6[1];
                        return options2.perPage;
                    })));
                    return perPage * ((options.flickMaxPages || 1) + 1);
                }
                return 0;
            };
            _proto3.renderArrows = function renderArrows() {
                var html = "";
                html += '<div class="' + this.options.classes.arrows + '">';
                html += this.renderArrow(true);
                html += this.renderArrow(false);
                html += "</div>";
                return html;
            };
            _proto3.renderArrow = function renderArrow(prev) {
                var _this$options = this.options, classes = _this$options.classes, i18n = _this$options.i18n;
                var attrs = {
                    class: classes.arrow + " " + (prev ? classes.prev : classes.next),
                    type: "button",
                    ariaLabel: prev ? i18n.prev : i18n.next
                };
                return "<button " + this.buildAttrs(attrs) + '><svg xmlns="' + XML_NAME_SPACE + '" viewBox="0 0 ' + SIZE + " " + SIZE + '" width="' + SIZE + '" height="' + SIZE + '"><path d="' + (this.options.arrowPath || PATH) + '" /></svg></button>';
            };
            _proto3.html = function html() {
                var _this$config = this.config, rootClass = _this$config.rootClass, listTag = _this$config.listTag, arrows = _this$config.arrows, beforeTrack = _this$config.beforeTrack, afterTrack = _this$config.afterTrack, slider = _this$config.slider, beforeSlider = _this$config.beforeSlider, afterSlider = _this$config.afterSlider;
                var html = "";
                html += '<div id="' + this.id + '" class="' + this.buildClasses() + " " + (rootClass || "") + '">';
                html += "<style>" + this.Style.build() + "</style>";
                if (slider) {
                    html += beforeSlider || "";
                    html += '<div class="splide__slider">';
                }
                html += beforeTrack || "";
                if (arrows) html += this.renderArrows();
                html += '<div class="splide__track">';
                html += "<" + listTag + ' class="splide__list">';
                html += this.renderSlides();
                html += "</" + listTag + ">";
                html += "</div>";
                html += afterTrack || "";
                if (slider) {
                    html += "</div>";
                    html += afterSlider || "";
                }
                html += "</div>";
                return html;
            };
        }();
        document.addEventListener("DOMContentLoaded", (function() {
            new Splide(".splide", {
                type: "fade",
                arrows: false,
                pagination: false,
                autoplay: true,
                rewind: true,
                interval: 5e3,
                pauseOnHover: true,
                breakpoints: {
                    991.98: {
                        pagination: true
                    }
                }
            }).mount();
        }));
        function isObject_isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
        }
        const lodash_es_isObject = isObject_isObject;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        const _freeGlobal = freeGlobal;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = _freeGlobal || freeSelf || Function("return this")();
        const _root = root;
        var now = function() {
            return _root.Date.now();
        };
        const lodash_es_now = now;
        var reWhitespace = /\s/;
        function trimmedEndIndex(string) {
            var index = string.length;
            while (index-- && reWhitespace.test(string.charAt(index))) ;
            return index;
        }
        const _trimmedEndIndex = trimmedEndIndex;
        var reTrimStart = /^\s+/;
        function baseTrim(string) {
            return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        const _baseTrim = baseTrim;
        var app_Symbol = _root.Symbol;
        const _Symbol = app_Symbol;
        var objectProto = Object.prototype;
        var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function getRawTag(value) {
            var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = void 0;
                var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) if (isOwn) value[symToStringTag] = tag; else delete value[symToStringTag];
            return result;
        }
        const _getRawTag = getRawTag;
        var _objectToString_objectProto = Object.prototype;
        var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
        function objectToString(value) {
            return _objectToString_nativeObjectToString.call(value);
        }
        const _objectToString = objectToString;
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function baseGetTag(value) {
            if (value == null) return value === void 0 ? undefinedTag : nullTag;
            return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
        }
        const _baseGetTag = baseGetTag;
        function isObjectLike(value) {
            return value != null && typeof value == "object";
        }
        const lodash_es_isObjectLike = isObjectLike;
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
            return typeof value == "symbol" || lodash_es_isObjectLike(value) && _baseGetTag(value) == symbolTag;
        }
        const lodash_es_isSymbol = isSymbol;
        var NAN = 0 / 0;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsOctal = /^0o[0-7]+$/i;
        var freeParseInt = parseInt;
        function toNumber(value) {
            if (typeof value == "number") return value;
            if (lodash_es_isSymbol(value)) return NAN;
            if (lodash_es_isObject(value)) {
                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                value = lodash_es_isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") return value === 0 ? value : +value;
            value = _baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        const lodash_es_toNumber = toNumber;
        var FUNC_ERROR_TEXT = "Expected a function";
        var nativeMax = Math.max, nativeMin = Math.min;
        function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            wait = lodash_es_toNumber(wait) || 0;
            if (lodash_es_isObject(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(lodash_es_toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = void 0;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = lodash_es_now();
                if (shouldInvoke(time)) return trailingEdge(time);
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                timerId = void 0;
                if (trailing && lastArgs) return invokeFunc(time);
                lastArgs = lastThis = void 0;
                return result;
            }
            function cancel() {
                if (timerId !== void 0) clearTimeout(timerId);
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = void 0;
            }
            function flush() {
                return timerId === void 0 ? result : trailingEdge(lodash_es_now());
            }
            function debounced() {
                var time = lodash_es_now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === void 0) return leadingEdge(lastCallTime);
                    if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }
        const lodash_es_debounce = debounce;
        var throttle_FUNC_ERROR_TEXT = "Expected a function";
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") throw new TypeError(throttle_FUNC_ERROR_TEXT);
            if (lodash_es_isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return lodash_es_debounce(func, wait, {
                leading,
                maxWait: wait,
                trailing
            });
        }
        const lodash_es_throttle = throttle;
        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };
        function getElementWindow$1(element) {
            if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) return window;
            return element.ownerDocument.defaultView;
        }
        function getElementDocument$1(element) {
            if (!element || !element.ownerDocument) return document;
            return element.ownerDocument;
        }
        var getOptions$1 = function(obj) {
            var initialObj = {};
            var options = Array.prototype.reduce.call(obj, (function(acc, attribute) {
                var option = attribute.name.match(/data-simplebar-(.+)/);
                if (option) {
                    var key = option[1].replace(/\W+(.)/g, (function(_, chr) {
                        return chr.toUpperCase();
                    }));
                    switch (attribute.value) {
                      case "true":
                        acc[key] = true;
                        break;

                      case "false":
                        acc[key] = false;
                        break;

                      case void 0:
                        acc[key] = true;
                        break;

                      default:
                        acc[key] = attribute.value;
                    }
                }
                return acc;
            }), initialObj);
            return options;
        };
        function addClasses$1(el, classes) {
            var _a;
            if (!el) return;
            (_a = el.classList).add.apply(_a, classes.split(" "));
        }
        function removeClasses$1(el, classes) {
            if (!el) return;
            classes.split(" ").forEach((function(className) {
                el.classList.remove(className);
            }));
        }
        function classNamesToQuery$1(classNames) {
            return ".".concat(classNames.split(" ").join("."));
        }
        var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        var helpers = Object.freeze({
            __proto__: null,
            addClasses: addClasses$1,
            canUseDOM,
            classNamesToQuery: classNamesToQuery$1,
            getElementDocument: getElementDocument$1,
            getElementWindow: getElementWindow$1,
            getOptions: getOptions$1,
            removeClasses: removeClasses$1
        });
        var cachedScrollbarWidth = null;
        var cachedDevicePixelRatio = null;
        if (canUseDOM) window.addEventListener("resize", (function() {
            if (cachedDevicePixelRatio !== window.devicePixelRatio) {
                cachedDevicePixelRatio = window.devicePixelRatio;
                cachedScrollbarWidth = null;
            }
        }));
        function scrollbarWidth() {
            if (cachedScrollbarWidth === null) {
                if (typeof document === "undefined") {
                    cachedScrollbarWidth = 0;
                    return cachedScrollbarWidth;
                }
                var body = document.body;
                var box = document.createElement("div");
                box.classList.add("simplebar-hide-scrollbar");
                body.appendChild(box);
                var width = box.getBoundingClientRect().right;
                body.removeChild(box);
                cachedScrollbarWidth = width;
            }
            return cachedScrollbarWidth;
        }
        var getElementWindow = getElementWindow$1, getElementDocument = getElementDocument$1, getOptions = getOptions$1, addClasses = addClasses$1, dist_removeClasses = removeClasses$1, classNamesToQuery = classNamesToQuery$1;
        var SimpleBarCore = function() {
            function SimpleBarCore(element, options) {
                if (options === void 0) options = {};
                var _this = this;
                this.removePreventClickId = null;
                this.minScrollbarWidth = 20;
                this.stopScrollDelay = 175;
                this.isScrolling = false;
                this.isMouseEntering = false;
                this.isDragging = false;
                this.scrollXTicking = false;
                this.scrollYTicking = false;
                this.wrapperEl = null;
                this.contentWrapperEl = null;
                this.contentEl = null;
                this.offsetEl = null;
                this.maskEl = null;
                this.placeholderEl = null;
                this.heightAutoObserverWrapperEl = null;
                this.heightAutoObserverEl = null;
                this.rtlHelpers = null;
                this.scrollbarWidth = 0;
                this.resizeObserver = null;
                this.mutationObserver = null;
                this.elStyles = null;
                this.isRtl = null;
                this.mouseX = 0;
                this.mouseY = 0;
                this.onMouseMove = function() {};
                this.onWindowResize = function() {};
                this.onStopScrolling = function() {};
                this.onMouseEntered = function() {};
                this.onScroll = function() {
                    var elWindow = getElementWindow(_this.el);
                    if (!_this.scrollXTicking) {
                        elWindow.requestAnimationFrame(_this.scrollX);
                        _this.scrollXTicking = true;
                    }
                    if (!_this.scrollYTicking) {
                        elWindow.requestAnimationFrame(_this.scrollY);
                        _this.scrollYTicking = true;
                    }
                    if (!_this.isScrolling) {
                        _this.isScrolling = true;
                        addClasses(_this.el, _this.classNames.scrolling);
                    }
                    _this.showScrollbar("x");
                    _this.showScrollbar("y");
                    _this.onStopScrolling();
                };
                this.scrollX = function() {
                    if (_this.axis.x.isOverflowing) _this.positionScrollbar("x");
                    _this.scrollXTicking = false;
                };
                this.scrollY = function() {
                    if (_this.axis.y.isOverflowing) _this.positionScrollbar("y");
                    _this.scrollYTicking = false;
                };
                this._onStopScrolling = function() {
                    dist_removeClasses(_this.el, _this.classNames.scrolling);
                    if (_this.options.autoHide) {
                        _this.hideScrollbar("x");
                        _this.hideScrollbar("y");
                    }
                    _this.isScrolling = false;
                };
                this.onMouseEnter = function() {
                    if (!_this.isMouseEntering) {
                        addClasses(_this.el, _this.classNames.mouseEntered);
                        _this.showScrollbar("x");
                        _this.showScrollbar("y");
                        _this.isMouseEntering = true;
                    }
                    _this.onMouseEntered();
                };
                this._onMouseEntered = function() {
                    dist_removeClasses(_this.el, _this.classNames.mouseEntered);
                    if (_this.options.autoHide) {
                        _this.hideScrollbar("x");
                        _this.hideScrollbar("y");
                    }
                    _this.isMouseEntering = false;
                };
                this._onMouseMove = function(e) {
                    _this.mouseX = e.clientX;
                    _this.mouseY = e.clientY;
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseMoveForAxis("x");
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseMoveForAxis("y");
                };
                this.onMouseLeave = function() {
                    _this.onMouseMove.cancel();
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseLeaveForAxis("x");
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseLeaveForAxis("y");
                    _this.mouseX = -1;
                    _this.mouseY = -1;
                };
                this._onWindowResize = function() {
                    _this.scrollbarWidth = _this.getScrollbarWidth();
                    _this.hideNativeScrollbar();
                };
                this.onPointerEvent = function(e) {
                    if (!_this.axis.x.track.el || !_this.axis.y.track.el || !_this.axis.x.scrollbar.el || !_this.axis.y.scrollbar.el) return;
                    var isWithinTrackXBounds, isWithinTrackYBounds;
                    _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
                    _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);
                    if (isWithinTrackXBounds || isWithinTrackYBounds) {
                        e.stopPropagation();
                        if (e.type === "pointerdown" && e.pointerType !== "touch") {
                            if (isWithinTrackXBounds) {
                                _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();
                                if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) _this.onDragStart(e, "x"); else _this.onTrackClick(e, "x");
                            }
                            if (isWithinTrackYBounds) {
                                _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();
                                if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) _this.onDragStart(e, "y"); else _this.onTrackClick(e, "y");
                            }
                        }
                    }
                };
                this.drag = function(e) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                    if (!_this.draggedAxis || !_this.contentWrapperEl) return;
                    var eventOffset;
                    var track = _this.axis[_this.draggedAxis].track;
                    var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;
                    var scrollbar = _this.axis[_this.draggedAxis].scrollbar;
                    var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;
                    var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : "0px", 10);
                    e.preventDefault();
                    e.stopPropagation();
                    if (_this.draggedAxis === "y") eventOffset = e.pageY; else eventOffset = e.pageX;
                    var dragPos = eventOffset - ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) - _this.axis[_this.draggedAxis].dragOffset;
                    dragPos = _this.draggedAxis === "x" && _this.isRtl ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) - scrollbar.size - dragPos : dragPos;
                    var dragPerc = dragPos / (trackSize - scrollbar.size);
                    var scrollPos = dragPerc * (contentSize - hostSize);
                    if (_this.draggedAxis === "x" && _this.isRtl) scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative) ? -scrollPos : scrollPos;
                    _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;
                };
                this.onEndDrag = function(e) {
                    _this.isDragging = false;
                    var elDocument = getElementDocument(_this.el);
                    var elWindow = getElementWindow(_this.el);
                    e.preventDefault();
                    e.stopPropagation();
                    dist_removeClasses(_this.el, _this.classNames.dragging);
                    _this.onStopScrolling();
                    elDocument.removeEventListener("mousemove", _this.drag, true);
                    elDocument.removeEventListener("mouseup", _this.onEndDrag, true);
                    _this.removePreventClickId = elWindow.setTimeout((function() {
                        elDocument.removeEventListener("click", _this.preventClick, true);
                        elDocument.removeEventListener("dblclick", _this.preventClick, true);
                        _this.removePreventClickId = null;
                    }));
                };
                this.preventClick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                };
                this.el = element;
                this.options = __assign(__assign({}, SimpleBarCore.defaultOptions), options);
                this.classNames = __assign(__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);
                this.axis = {
                    x: {
                        scrollOffsetAttr: "scrollLeft",
                        sizeAttr: "width",
                        scrollSizeAttr: "scrollWidth",
                        offsetSizeAttr: "offsetWidth",
                        offsetAttr: "left",
                        overflowAttr: "overflowX",
                        dragOffset: 0,
                        isOverflowing: true,
                        forceVisible: false,
                        track: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        },
                        scrollbar: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        }
                    },
                    y: {
                        scrollOffsetAttr: "scrollTop",
                        sizeAttr: "height",
                        scrollSizeAttr: "scrollHeight",
                        offsetSizeAttr: "offsetHeight",
                        offsetAttr: "top",
                        overflowAttr: "overflowY",
                        dragOffset: 0,
                        isOverflowing: true,
                        forceVisible: false,
                        track: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        },
                        scrollbar: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        }
                    }
                };
                if (typeof this.el !== "object" || !this.el.nodeName) throw new Error("Argument passed to SimpleBar must be an HTML element instead of ".concat(this.el));
                this.onMouseMove = lodash_es_throttle(this._onMouseMove, 64);
                this.onWindowResize = lodash_es_debounce(this._onWindowResize, 64, {
                    leading: true
                });
                this.onStopScrolling = lodash_es_debounce(this._onStopScrolling, this.stopScrollDelay);
                this.onMouseEntered = lodash_es_debounce(this._onMouseEntered, this.stopScrollDelay);
                this.init();
            }
            SimpleBarCore.getRtlHelpers = function() {
                if (SimpleBarCore.rtlHelpers) return SimpleBarCore.rtlHelpers;
                var dummyDiv = document.createElement("div");
                dummyDiv.innerHTML = '<div class="simplebar-dummy-scrollbar-size"><div></div></div>';
                var scrollbarDummyEl = dummyDiv.firstElementChild;
                var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;
                if (!dummyChild) return null;
                document.body.appendChild(scrollbarDummyEl);
                scrollbarDummyEl.scrollLeft = 0;
                var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);
                var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);
                scrollbarDummyEl.scrollLeft = -999;
                var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);
                document.body.removeChild(scrollbarDummyEl);
                SimpleBarCore.rtlHelpers = {
                    isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,
                    isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left
                };
                return SimpleBarCore.rtlHelpers;
            };
            SimpleBarCore.prototype.getScrollbarWidth = function() {
                try {
                    if (this.contentWrapperEl && getComputedStyle(this.contentWrapperEl, "::-webkit-scrollbar").display === "none" || "scrollbarWidth" in document.documentElement.style || "-ms-overflow-style" in document.documentElement.style) return 0; else return scrollbarWidth();
                } catch (e) {
                    return scrollbarWidth();
                }
            };
            SimpleBarCore.getOffset = function(el) {
                var rect = el.getBoundingClientRect();
                var elDocument = getElementDocument(el);
                var elWindow = getElementWindow(el);
                return {
                    top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),
                    left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)
                };
            };
            SimpleBarCore.prototype.init = function() {
                if (canUseDOM) {
                    this.initDOM();
                    this.rtlHelpers = SimpleBarCore.getRtlHelpers();
                    this.scrollbarWidth = this.getScrollbarWidth();
                    this.recalculate();
                    this.initListeners();
                }
            };
            SimpleBarCore.prototype.initDOM = function() {
                var _a, _b;
                this.wrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.wrapper));
                this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));
                this.contentEl = this.options.contentNode || this.el.querySelector(classNamesToQuery(this.classNames.contentEl));
                this.offsetEl = this.el.querySelector(classNamesToQuery(this.classNames.offset));
                this.maskEl = this.el.querySelector(classNamesToQuery(this.classNames.mask));
                this.placeholderEl = this.findChild(this.wrapperEl, classNamesToQuery(this.classNames.placeholder));
                this.heightAutoObserverWrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));
                this.heightAutoObserverEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverEl));
                this.axis.x.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.horizontal)));
                this.axis.y.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.vertical)));
                this.axis.x.scrollbar.el = ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
                this.axis.y.scrollbar.el = ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
                if (!this.options.autoHide) {
                    addClasses(this.axis.x.scrollbar.el, this.classNames.visible);
                    addClasses(this.axis.y.scrollbar.el, this.classNames.visible);
                }
            };
            SimpleBarCore.prototype.initListeners = function() {
                var _this = this;
                var _a;
                var elWindow = getElementWindow(this.el);
                this.el.addEventListener("mouseenter", this.onMouseEnter);
                this.el.addEventListener("pointerdown", this.onPointerEvent, true);
                this.el.addEventListener("mousemove", this.onMouseMove);
                this.el.addEventListener("mouseleave", this.onMouseLeave);
                (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.addEventListener("scroll", this.onScroll);
                elWindow.addEventListener("resize", this.onWindowResize);
                if (!this.contentEl) return;
                if (window.ResizeObserver) {
                    var resizeObserverStarted_1 = false;
                    var resizeObserver = elWindow.ResizeObserver || ResizeObserver;
                    this.resizeObserver = new resizeObserver((function() {
                        if (!resizeObserverStarted_1) return;
                        elWindow.requestAnimationFrame((function() {
                            _this.recalculate();
                        }));
                    }));
                    this.resizeObserver.observe(this.el);
                    this.resizeObserver.observe(this.contentEl);
                    elWindow.requestAnimationFrame((function() {
                        resizeObserverStarted_1 = true;
                    }));
                }
                this.mutationObserver = new elWindow.MutationObserver((function() {
                    elWindow.requestAnimationFrame((function() {
                        _this.recalculate();
                    }));
                }));
                this.mutationObserver.observe(this.contentEl, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            };
            SimpleBarCore.prototype.recalculate = function() {
                if (!this.heightAutoObserverEl || !this.contentEl || !this.contentWrapperEl || !this.wrapperEl || !this.placeholderEl) return;
                var elWindow = getElementWindow(this.el);
                this.elStyles = elWindow.getComputedStyle(this.el);
                this.isRtl = this.elStyles.direction === "rtl";
                var contentElOffsetWidth = this.contentEl.offsetWidth;
                var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;
                var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;
                var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;
                var elOverflowX = this.elStyles.overflowX;
                var elOverflowY = this.elStyles.overflowY;
                this.contentEl.style.padding = "".concat(this.elStyles.paddingTop, " ").concat(this.elStyles.paddingRight, " ").concat(this.elStyles.paddingBottom, " ").concat(this.elStyles.paddingLeft);
                this.wrapperEl.style.margin = "-".concat(this.elStyles.paddingTop, " -").concat(this.elStyles.paddingRight, " -").concat(this.elStyles.paddingBottom, " -").concat(this.elStyles.paddingLeft);
                var contentElScrollHeight = this.contentEl.scrollHeight;
                var contentElScrollWidth = this.contentEl.scrollWidth;
                this.contentWrapperEl.style.height = isHeightAuto ? "auto" : "100%";
                this.placeholderEl.style.width = isWidthAuto ? "".concat(contentElOffsetWidth || contentElScrollWidth, "px") : "auto";
                this.placeholderEl.style.height = "".concat(contentElScrollHeight, "px");
                var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;
                this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;
                this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight;
                this.axis.x.isOverflowing = elOverflowX === "hidden" ? false : this.axis.x.isOverflowing;
                this.axis.y.isOverflowing = elOverflowY === "hidden" ? false : this.axis.y.isOverflowing;
                this.axis.x.forceVisible = this.options.forceVisible === "x" || this.options.forceVisible === true;
                this.axis.y.forceVisible = this.options.forceVisible === "y" || this.options.forceVisible === true;
                this.hideNativeScrollbar();
                var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;
                var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
                this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;
                this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;
                this.axis.x.scrollbar.size = this.getScrollbarSize("x");
                this.axis.y.scrollbar.size = this.getScrollbarSize("y");
                if (this.axis.x.scrollbar.el) this.axis.x.scrollbar.el.style.width = "".concat(this.axis.x.scrollbar.size, "px");
                if (this.axis.y.scrollbar.el) this.axis.y.scrollbar.el.style.height = "".concat(this.axis.y.scrollbar.size, "px");
                this.positionScrollbar("x");
                this.positionScrollbar("y");
                this.toggleTrackVisibility("x");
                this.toggleTrackVisibility("y");
            };
            SimpleBarCore.prototype.getScrollbarSize = function(axis) {
                var _a, _b;
                if (axis === void 0) axis = "y";
                if (!this.axis[axis].isOverflowing || !this.contentEl) return 0;
                var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];
                var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;
                var scrollbarRatio = trackSize / contentSize;
                var scrollbarSize;
                scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);
                if (this.options.scrollbarMaxSize) scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);
                return scrollbarSize;
            };
            SimpleBarCore.prototype.positionScrollbar = function(axis) {
                var _a, _b, _c;
                if (axis === void 0) axis = "y";
                var scrollbar = this.axis[axis].scrollbar;
                if (!this.axis[axis].isOverflowing || !this.contentWrapperEl || !scrollbar.el || !this.elStyles) return;
                var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];
                var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;
                var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);
                var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
                scrollOffset = axis === "x" && this.isRtl && ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero) ? -scrollOffset : scrollOffset;
                if (axis === "x" && this.isRtl) scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative) ? scrollOffset : -scrollOffset;
                var scrollPourcent = scrollOffset / (contentSize - hostSize);
                var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);
                handleOffset = axis === "x" && this.isRtl ? -handleOffset + (trackSize - scrollbar.size) : handleOffset;
                scrollbar.el.style.transform = axis === "x" ? "translate3d(".concat(handleOffset, "px, 0, 0)") : "translate3d(0, ".concat(handleOffset, "px, 0)");
            };
            SimpleBarCore.prototype.toggleTrackVisibility = function(axis) {
                if (axis === void 0) axis = "y";
                var track = this.axis[axis].track.el;
                var scrollbar = this.axis[axis].scrollbar.el;
                if (!track || !scrollbar || !this.contentWrapperEl) return;
                if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {
                    track.style.visibility = "visible";
                    this.contentWrapperEl.style[this.axis[axis].overflowAttr] = "scroll";
                    this.el.classList.add("".concat(this.classNames.scrollable, "-").concat(axis));
                } else {
                    track.style.visibility = "hidden";
                    this.contentWrapperEl.style[this.axis[axis].overflowAttr] = "hidden";
                    this.el.classList.remove("".concat(this.classNames.scrollable, "-").concat(axis));
                }
                if (this.axis[axis].isOverflowing) scrollbar.style.display = "block"; else scrollbar.style.display = "none";
            };
            SimpleBarCore.prototype.showScrollbar = function(axis) {
                if (axis === void 0) axis = "y";
                if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {
                    addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
                    this.axis[axis].scrollbar.isVisible = true;
                }
            };
            SimpleBarCore.prototype.hideScrollbar = function(axis) {
                if (axis === void 0) axis = "y";
                if (this.isDragging) return;
                if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {
                    dist_removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
                    this.axis[axis].scrollbar.isVisible = false;
                }
            };
            SimpleBarCore.prototype.hideNativeScrollbar = function() {
                if (!this.offsetEl) return;
                this.offsetEl.style[this.isRtl ? "left" : "right"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px";
                this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px";
            };
            SimpleBarCore.prototype.onMouseMoveForAxis = function(axis) {
                if (axis === void 0) axis = "y";
                var currentAxis = this.axis[axis];
                if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;
                currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();
                currentAxis.scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();
                if (this.isWithinBounds(currentAxis.track.rect)) {
                    this.showScrollbar(axis);
                    addClasses(currentAxis.track.el, this.classNames.hover);
                    if (this.isWithinBounds(currentAxis.scrollbar.rect)) addClasses(currentAxis.scrollbar.el, this.classNames.hover); else dist_removeClasses(currentAxis.scrollbar.el, this.classNames.hover);
                } else {
                    dist_removeClasses(currentAxis.track.el, this.classNames.hover);
                    if (this.options.autoHide) this.hideScrollbar(axis);
                }
            };
            SimpleBarCore.prototype.onMouseLeaveForAxis = function(axis) {
                if (axis === void 0) axis = "y";
                dist_removeClasses(this.axis[axis].track.el, this.classNames.hover);
                dist_removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);
                if (this.options.autoHide) this.hideScrollbar(axis);
            };
            SimpleBarCore.prototype.onDragStart = function(e, axis) {
                var _a;
                if (axis === void 0) axis = "y";
                this.isDragging = true;
                var elDocument = getElementDocument(this.el);
                var elWindow = getElementWindow(this.el);
                var scrollbar = this.axis[axis].scrollbar;
                var eventOffset = axis === "y" ? e.pageY : e.pageX;
                this.axis[axis].dragOffset = eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);
                this.draggedAxis = axis;
                addClasses(this.el, this.classNames.dragging);
                elDocument.addEventListener("mousemove", this.drag, true);
                elDocument.addEventListener("mouseup", this.onEndDrag, true);
                if (this.removePreventClickId === null) {
                    elDocument.addEventListener("click", this.preventClick, true);
                    elDocument.addEventListener("dblclick", this.preventClick, true);
                } else {
                    elWindow.clearTimeout(this.removePreventClickId);
                    this.removePreventClickId = null;
                }
            };
            SimpleBarCore.prototype.onTrackClick = function(e, axis) {
                var _this = this;
                var _a, _b, _c, _d;
                if (axis === void 0) axis = "y";
                var currentAxis = this.axis[axis];
                if (!this.options.clickOnTrack || !currentAxis.scrollbar.el || !this.contentWrapperEl) return;
                e.preventDefault();
                var elWindow = getElementWindow(this.el);
                this.axis[axis].scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();
                var scrollbar = this.axis[axis].scrollbar;
                var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;
                var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : "0px", 10);
                var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
                var t = axis === "y" ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;
                var dir = t < 0 ? -1 : 1;
                var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;
                var speed = 40;
                var scrollTo = function() {
                    if (!_this.contentWrapperEl) return;
                    if (dir === -1) {
                        if (scrolled > scrollSize) {
                            scrolled -= speed;
                            _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                            elWindow.requestAnimationFrame(scrollTo);
                        }
                    } else if (scrolled < scrollSize) {
                        scrolled += speed;
                        _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                        elWindow.requestAnimationFrame(scrollTo);
                    }
                };
                scrollTo();
            };
            SimpleBarCore.prototype.getContentElement = function() {
                return this.contentEl;
            };
            SimpleBarCore.prototype.getScrollElement = function() {
                return this.contentWrapperEl;
            };
            SimpleBarCore.prototype.removeListeners = function() {
                var elWindow = getElementWindow(this.el);
                this.el.removeEventListener("mouseenter", this.onMouseEnter);
                this.el.removeEventListener("pointerdown", this.onPointerEvent, true);
                this.el.removeEventListener("mousemove", this.onMouseMove);
                this.el.removeEventListener("mouseleave", this.onMouseLeave);
                if (this.contentWrapperEl) this.contentWrapperEl.removeEventListener("scroll", this.onScroll);
                elWindow.removeEventListener("resize", this.onWindowResize);
                if (this.mutationObserver) this.mutationObserver.disconnect();
                if (this.resizeObserver) this.resizeObserver.disconnect();
                this.onMouseMove.cancel();
                this.onWindowResize.cancel();
                this.onStopScrolling.cancel();
                this.onMouseEntered.cancel();
            };
            SimpleBarCore.prototype.unMount = function() {
                this.removeListeners();
            };
            SimpleBarCore.prototype.isWithinBounds = function(bbox) {
                return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;
            };
            SimpleBarCore.prototype.findChild = function(el, query) {
                var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;
                return Array.prototype.filter.call(el.children, (function(child) {
                    return matches.call(child, query);
                }))[0];
            };
            SimpleBarCore.rtlHelpers = null;
            SimpleBarCore.defaultOptions = {
                forceVisible: false,
                clickOnTrack: true,
                scrollbarMinSize: 25,
                scrollbarMaxSize: 0,
                ariaLabel: "scrollable content",
                tabIndex: 0,
                classNames: {
                    contentEl: "simplebar-content",
                    contentWrapper: "simplebar-content-wrapper",
                    offset: "simplebar-offset",
                    mask: "simplebar-mask",
                    wrapper: "simplebar-wrapper",
                    placeholder: "simplebar-placeholder",
                    scrollbar: "simplebar-scrollbar",
                    track: "simplebar-track",
                    heightAutoObserverWrapperEl: "simplebar-height-auto-observer-wrapper",
                    heightAutoObserverEl: "simplebar-height-auto-observer",
                    visible: "simplebar-visible",
                    horizontal: "simplebar-horizontal",
                    vertical: "simplebar-vertical",
                    hover: "simplebar-hover",
                    dragging: "simplebar-dragging",
                    scrolling: "simplebar-scrolling",
                    scrollable: "simplebar-scrollable",
                    mouseEntered: "simplebar-mouse-entered"
                },
                scrollableNode: null,
                contentNode: null,
                autoHide: true
            };
            SimpleBarCore.getOptions = getOptions;
            SimpleBarCore.helpers = helpers;
            return SimpleBarCore;
        }();
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        function __extends(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
        }
        var _a = SimpleBarCore.helpers, dist_getOptions = _a.getOptions, dist_addClasses = _a.addClasses, dist_canUseDOM = _a.canUseDOM;
        var SimpleBar = function(_super) {
            __extends(SimpleBar, _super);
            function SimpleBar() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                var _this = _super.apply(this, args) || this;
                SimpleBar.instances.set(args[0], _this);
                return _this;
            }
            SimpleBar.initDOMLoadedElements = function() {
                document.removeEventListener("DOMContentLoaded", this.initDOMLoadedElements);
                window.removeEventListener("load", this.initDOMLoadedElements);
                Array.prototype.forEach.call(document.querySelectorAll("[data-simplebar]"), (function(el) {
                    if (el.getAttribute("data-simplebar") !== "init" && !SimpleBar.instances.has(el)) new SimpleBar(el, dist_getOptions(el.attributes));
                }));
            };
            SimpleBar.removeObserver = function() {
                var _a;
                (_a = SimpleBar.globalObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
            };
            SimpleBar.prototype.initDOM = function() {
                var _this = this;
                var _a, _b, _c;
                if (!Array.prototype.filter.call(this.el.children, (function(child) {
                    return child.classList.contains(_this.classNames.wrapper);
                })).length) {
                    this.wrapperEl = document.createElement("div");
                    this.contentWrapperEl = document.createElement("div");
                    this.offsetEl = document.createElement("div");
                    this.maskEl = document.createElement("div");
                    this.contentEl = document.createElement("div");
                    this.placeholderEl = document.createElement("div");
                    this.heightAutoObserverWrapperEl = document.createElement("div");
                    this.heightAutoObserverEl = document.createElement("div");
                    dist_addClasses(this.wrapperEl, this.classNames.wrapper);
                    dist_addClasses(this.contentWrapperEl, this.classNames.contentWrapper);
                    dist_addClasses(this.offsetEl, this.classNames.offset);
                    dist_addClasses(this.maskEl, this.classNames.mask);
                    dist_addClasses(this.contentEl, this.classNames.contentEl);
                    dist_addClasses(this.placeholderEl, this.classNames.placeholder);
                    dist_addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);
                    dist_addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);
                    while (this.el.firstChild) this.contentEl.appendChild(this.el.firstChild);
                    this.contentWrapperEl.appendChild(this.contentEl);
                    this.offsetEl.appendChild(this.contentWrapperEl);
                    this.maskEl.appendChild(this.offsetEl);
                    this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);
                    this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);
                    this.wrapperEl.appendChild(this.maskEl);
                    this.wrapperEl.appendChild(this.placeholderEl);
                    this.el.appendChild(this.wrapperEl);
                    (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.setAttribute("tabindex", this.options.tabIndex.toString());
                    (_b = this.contentWrapperEl) === null || _b === void 0 ? void 0 : _b.setAttribute("role", "region");
                    (_c = this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c.setAttribute("aria-label", this.options.ariaLabel);
                }
                if (!this.axis.x.track.el || !this.axis.y.track.el) {
                    var track = document.createElement("div");
                    var scrollbar = document.createElement("div");
                    dist_addClasses(track, this.classNames.track);
                    dist_addClasses(scrollbar, this.classNames.scrollbar);
                    track.appendChild(scrollbar);
                    this.axis.x.track.el = track.cloneNode(true);
                    dist_addClasses(this.axis.x.track.el, this.classNames.horizontal);
                    this.axis.y.track.el = track.cloneNode(true);
                    dist_addClasses(this.axis.y.track.el, this.classNames.vertical);
                    this.el.appendChild(this.axis.x.track.el);
                    this.el.appendChild(this.axis.y.track.el);
                }
                SimpleBarCore.prototype.initDOM.call(this);
                this.el.setAttribute("data-simplebar", "init");
            };
            SimpleBar.prototype.unMount = function() {
                SimpleBarCore.prototype.unMount.call(this);
                SimpleBar.instances["delete"](this.el);
            };
            SimpleBar.initHtmlApi = function() {
                this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);
                if (typeof MutationObserver !== "undefined") {
                    this.globalObserver = new MutationObserver(SimpleBar.handleMutations);
                    this.globalObserver.observe(document, {
                        childList: true,
                        subtree: true
                    });
                }
                if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) window.setTimeout(this.initDOMLoadedElements); else {
                    document.addEventListener("DOMContentLoaded", this.initDOMLoadedElements);
                    window.addEventListener("load", this.initDOMLoadedElements);
                }
            };
            SimpleBar.handleMutations = function(mutations) {
                mutations.forEach((function(mutation) {
                    mutation.addedNodes.forEach((function(addedNode) {
                        if (addedNode.nodeType === 1) if (addedNode.hasAttribute("data-simplebar")) !SimpleBar.instances.has(addedNode) && document.documentElement.contains(addedNode) && new SimpleBar(addedNode, dist_getOptions(addedNode.attributes)); else addedNode.querySelectorAll("[data-simplebar]").forEach((function(el) {
                            if (el.getAttribute("data-simplebar") !== "init" && !SimpleBar.instances.has(el) && document.documentElement.contains(el)) new SimpleBar(el, dist_getOptions(el.attributes));
                        }));
                    }));
                    mutation.removedNodes.forEach((function(removedNode) {
                        var _a;
                        if (removedNode.nodeType === 1) if (removedNode.getAttribute("data-simplebar") === "init") !document.documentElement.contains(removedNode) && ((_a = SimpleBar.instances.get(removedNode)) === null || _a === void 0 ? void 0 : _a.unMount()); else Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar="init"]'), (function(el) {
                            var _a;
                            !document.documentElement.contains(el) && ((_a = SimpleBar.instances.get(el)) === null || _a === void 0 ? void 0 : _a.unMount());
                        }));
                    }));
                }));
            };
            SimpleBar.instances = new WeakMap;
            return SimpleBar;
        }(SimpleBarCore);
        if (dist_canUseDOM) SimpleBar.initHtmlApi();
        if (document.querySelectorAll("[data-simplebar-c]").length) document.querySelectorAll("[data-simplebar]").forEach((scrollBlock => {
            const mediaQuery = scrollBlock.getAttribute("data-simplebar-media");
            if (mediaQuery) {
                const matchMediaQuery = window.matchMedia(`(min-width: ${mediaQuery / 16}em)`);
                if (matchMediaQuery.matches) new SimpleBar(scrollBlock, {});
                matchMediaQuery.addEventListener("change", (e => {
                    if (e.matches) {
                        console.log("+");
                        new SimpleBar(scrollBlock, {
                            autoHide: false
                        });
                    } else if (SimpleBar.instances.has(scrollBlock)) SimpleBar.instances.get(scrollBlock).unMount();
                }));
            } else new SimpleBar(scrollBlock, {});
        }));
        let addWindowScrollEvent = false;
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        class DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.оbjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const оbject = {};
                    оbject.element = node;
                    оbject.parent = node.parentNode;
                    оbject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767.98";
                    оbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    оbject.index = this.indexInParent(оbject.parent, оbject.element);
                    this.оbjects.push(оbject);
                }));
                this.arraySort(this.оbjects);
                this.mediaQueries = this.оbjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint / 16}em),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const оbjectsFilter = this.оbjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, оbjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, оbjectsFilter);
                }));
            }
            mediaHandler(matchMedia, оbjects) {
                if (matchMedia.matches) оbjects.forEach((оbject => {
                    this.moveTo(оbject.place, оbject.element, оbject.destination);
                })); else оbjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                element.classList.add(this.daClassname);
                if (place === "last" || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if (place === "first") {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (parent.children[index] !== void 0) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if (this.type === "min") arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return -1;
                        if (a.place === "last" || b.place === "first") return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if (a.place === "first" || b.place === "last") return 1;
                            if (a.place === "last" || b.place === "first") return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const da = new DynamicAdapt("max");
        da.init();
        __webpack_require__(481);
        __webpack_require__(769);
        var leaflet_gesture_handling_min = __webpack_require__(882);
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        isSafari ? document.documentElement.classList.add("safari") : null;
        const langHeaders = document.querySelectorAll(".lang-header");
        langHeaders.forEach((langHeader => {
            const langHeaderBody = langHeader.querySelector(".lang-header__body");
            const langHeaderWrapper = langHeader.querySelector(".lang-header__wrapper");
            _slideUp(langHeaderWrapper, 0, "horizontal");
            langHeaderBody.addEventListener("click", (() => {
                _slideToggle(langHeaderWrapper, 300, "horizontal");
                langHeader.classList.toggle("_active");
            }));
        }));
        let isSmallScreen = window.innerWidth <= 599.98;
        window.addEventListener("resize", (() => {
            isSmallScreen = window.innerWidth <= 599.98;
        }));
        document.addEventListener("click", (event => {
            const isMenuOpenButton = event.target.closest("[data-menu-open]");
            const isMenuCloseButton = event.target.closest("[data-menu-close]");
            const isOutsideMenu = !event.target.closest(".mobile-menu");
            const isSearchOpenBtn = event.target.closest("[data-search-open]");
            const isSearchCloseBtn = event.target.closest("[data-search-close]");
            const isGoBackBtn = event.target.closest("[data-go-back]");
            const isPlayBtn = event.target.closest("[data-yt]");
            if (isMenuOpenButton) {
                document.documentElement.classList.add("menu-open");
                if (isSmallScreen && !isBodyLocked) bodyLock(0);
            } else if (isMenuCloseButton) {
                document.documentElement.classList.remove("menu-open");
                if (isSmallScreen && isBodyLocked) bodyUnlock(0);
            } else if (isOutsideMenu) {
                document.documentElement.classList.remove("menu-open");
                if (isSmallScreen && isBodyLocked) bodyUnlock(0);
            }
            if (isSearchOpenBtn) document.documentElement.classList.add("search-open"); else if (isSearchCloseBtn) document.documentElement.classList.remove("search-open");
            if (isGoBackBtn) window.scrollTo({
                top: 0,
                behavior: "smooth"
            });
            if (isPlayBtn) {
                const videoButton = event.target.closest(".video-section__play-btn");
                const videoBody = videoButton.closest(".video-section__video");
                if (videoBody && !videoButton.dataset.popup) {
                    const codeVideo = videoButton.dataset.popupYoutube;
                    console.log(codeVideo);
                    const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                    const iframe = document.createElement("iframe");
                    iframe.setAttribute("allowfullscreen", "");
                    iframe.setAttribute("allow", `autoplay; encrypted-media`);
                    iframe.setAttribute("src", urlVideo);
                    videoBody.replaceChildren();
                    videoBody.appendChild(iframe);
                }
            }
        }));
        const decorContainer = document.querySelector(".footer__decor");
        const firstDecorItem = decorContainer ? decorContainer.querySelector(".footer__decor-item") : null;
        if (decorContainer && firstDecorItem) {
            let initialHeight = parseInt(window.getComputedStyle(firstDecorItem).height) / 16;
            let initialMarginBottom = parseInt(window.getComputedStyle(firstDecorItem).marginBottom) / 16;
            const numberOfItems = decorContainer.dataset.count;
            for (let i = 1; i <= numberOfItems; i++) {
                const newDecorItem = document.createElement("div");
                newDecorItem.classList.add("footer__decor-item");
                newDecorItem.style.height = `${initialHeight - i / 16}rem`;
                newDecorItem.style.marginBottom = `${initialMarginBottom + i / 16}rem`;
                decorContainer.appendChild(newDecorItem);
            }
        }
        L.Map.addInitHook("addHandler", "gestureHandling", leaflet_gesture_handling_min.GestureHandling);
        var map = L.map("map", {
            center: [ 57.12857, -15.82031 ],
            zoom: 3,
            minZoom: 3,
            zoomControl: false,
            tap: false,
            maxBounds: [ [ 110, -210 ], [ -110, 210 ] ],
            maxBoundsViscosity: 1,
            gestureHandling: true
        });
        var markers = [ {
            coords: [ 53.41988920082695, 22.962430526782214 ],
            color: "#dd3d3d",
            text: "Poland",
            popupContent: `\n        <h4>Europe Headquarters</h4>\n        <span style="color: #dd3d3d " class="name _icon-ch-right">Poland</span><br>\n        Plasel Poland <br>\n        Address details here<br>\n        Tel: <a href="tel:your_phone_number">+Your Phone Number</a><br>\n        Fax: <a href="tel:your_fax_number">+Your Fax Number</a><br>\n        Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n        <a target="_blank" href="http://www.plasel.com">www.plasel.com</a>\n    `
        }, {
            coords: [ 35.9078, 127.7669 ],
            color: "#dd3d3d",
            text: "S. Korea",
            popupContent: `\n        <h4>Asia Headquarters</h4>\n        <span style="color: #dd3d3d " class="name _icon-ch-right">S. Korea</span><br>\n        Plasel South Korea <br>\n        Address details here<br>\n        Tel: <a href="tel:your_phone_number">+Your Phone Number</a><br>\n        Fax: <a href="tel:your_fax_number">+Your Fax Number</a><br>\n        Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n        <a target="_blank" href="http://www.plasel.com">www.plasel.com</a>\n    `
        }, {
            coords: [ 37.7749, -122.4194 ],
            color: "#dd3d3d",
            text: "US West<br>Coast",
            popupContent: `\n        <h4>US West Coast Headquarters</h4>\n        <span style="color: #dd3d3d " class="name _icon-ch-right">US West Coast</span><br>\n        Plasel USA West Coast <br>\n        Address details here<br>\n        Tel: <a href="tel:your_phone_number">+Your Phone Number</a><br>\n        Fax: <a href="tel:your_fax_number">+Your Fax Number</a><br>\n        Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n        <a target="_blank" href="http://www.plasel.com">www.plasel.com</a>\n    `
        }, {
            coords: [ 39.8283, -98.5795 ],
            color: "#dd3d3d",
            text: "US, Canada<br>& Mexico",
            popupContent: `\n        <h4>North America Headquarters</h4>\n        <span style="color: #dd3d3d " class="name _icon-ch-right">US, Canada & Mexico</span><br>\n        Plasel North America <br>\n        Address details here<br>\n        Tel: <a href="tel:your_phone_number">+Your Phone Number</a><br>\n        Fax: <a href="tel:your_fax_number">+Your Fax Number</a><br>\n        Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n        <a target="_blank" href="http://www.plasel.com">www.plasel.com</a>\n    `
        }, {
            coords: [ 49.69308947170579, 9.64700094662242 ],
            color: "#dd3d3d",
            text: "Germany",
            popupContent: `\n                <h4>Europe Headquarters</h4>\n                <span style="color: #dd3d3d " class="name _icon-ch-right">Germany</span><br>\n                Plasel Deutschland GmbH <br>\n                Dr. Klein 10 Str. 17, 88069 Tettnang<br>\n                Eori number - DE 7068115<br>\n                Tel: <a href="tel:4975429804570">+49-7542-9804570</a><br>\n                Fax: <a href="tel:497543934499">+49-7543934499</a><br>\n                Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n                <a target="_blank" href="http://www.plaselplastic.de">www.plaselplastic.de</a>\n            `
        }, {
            coords: [ 41.9028, 12.4964 ],
            color: "#dd3d3d",
            text: "Italy",
            popupContent: `\n                <h4>Europe Headquarters</h4>\n                <span style="color: #dd3d3d " class="name _icon-ch-right">Germany</span><br>\n                Plasel Deutschland GmbH <br>\n                Dr. Klein 10 Str. 17, 88069 Tettnang<br>\n                Eori number - DE 7068115<br>\n                Tel: <a href="tel:4975429804570">+49-7542-9804570</a><br>\n                Fax: <a href="tel:497543934499">+49-7543934499</a><br>\n                Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n                <a target="_blank" href="http://www.plaselplastic.de">www.plaselplastic.de</a>\n            `
        }, {
            coords: [ 31.0461, 34.8516 ],
            color: "#219cbb",
            text: "Israel",
            popupContent: `\n                <h4>Europe Headquarters</h4>\n                <span style="color: #219cbb " class="name _icon-ch-right">Germany</span><br>\n                Plasel Deutschland GmbH <br>\n                Dr. Klein 10 Str. 17, 88069 Tettnang<br>\n                Eori number - DE 7068115<br>\n                Tel: <a href="tel:4975429804570">+49-7542-9804570</a><br>\n                Fax: <a href="tel:497543934499">+49-7543934499</a><br>\n                Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n                <a target="_blank" href="http://www.plaselplastic.de">www.plaselplastic.de</a>\n            `
        }, {
            coords: [ 35.8617, 104.1954 ],
            color: "#dd3d3d",
            text: "China",
            popupContent: `\n                <h4>Europe Headquarters</h4>\n                <span style="color: #dd3d3d " class="name _icon-ch-right">Germany</span><br>\n                Plasel Deutschland GmbH <br>\n                Dr. Klein 10 Str. 17, 88069 Tettnang<br>\n                Eori number - DE 7068115<br>\n                Tel: <a href="tel:4975429804570">+49-7542-9804570</a><br>\n                Fax: <a href="tel:497543934499">+49-7543934499</a><br>\n                Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n                <a target="_blank" href="http://www.plaselplastic.de">www.plaselplastic.de</a>\n            `
        }, {
            coords: [ 20.5937, 78.9629 ],
            color: "#dd3d3d",
            text: "India",
            popupContent: `\n                <h4>Europe Headquarters</h4>\n                <span style="color: #dd3d3d " class="name _icon-ch-right">Germany</span><br>\n                Plasel Deutschland GmbH <br>\n                Dr. Klein 10 Str. 17, 88069 Tettnang<br>\n                Eori number - DE 7068115<br>\n                Tel: <a href="tel:4975429804570">+49-7542-9804570</a><br>\n                Fax: <a href="tel:497543934499">+49-7543934499</a><br>\n                Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n                <a target="_blank" href="http://www.plaselplastic.de">www.plaselplastic.de</a>\n            `
        }, {
            coords: [ 14.0583, 108.2772 ],
            color: "#455a64",
            text: "Vietnam",
            popupContent: `\n                <h4>Europe Headquarters</h4>\n                <span style="color: #455a64 " class="name _icon-ch-right">Germany</span><br>\n                Plasel Deutschland GmbH <br>\n                Dr. Klein 10 Str. 17, 88069 Tettnang<br>\n                Eori number - DE 7068115<br>\n                Tel: <a href="tel:4975429804570">+49-7542-9804570</a><br>\n                Fax: <a href="tel:497543934499">+49-7543934499</a><br>\n                Email: <a href="mailto:info@plasel.com">info@plasel.com</a><br>\n                <a target="_blank" href="http://www.plaselplastic.de">www.plaselplastic.de</a>\n            `
        } ];
        function createSvgIcon(color, circleFill = false) {
            return `\n      <svg xmlns="http://www.w3.org/2000/svg" width="27" height="36" viewBox="0 0 27 36" fill="none">\n<circle cx="14" cy="14" r="11" fill="${!circleFill ? "white" : "transparent"}"/>\n<g clip-path="url(#clip0_9_211)">\n<path d="M13.4626 20.3267C9.83721 20.3267 6.88081 17.3255 6.88081 13.6535C6.88081 9.98147 9.84095 6.98021 13.4626 6.98021C17.0843 6.98021 20.0444 9.98147 20.0444 13.6535C20.0444 17.3255 17.0843 20.3267 13.4626 20.3267ZM13.4626 0C6.06603 0 0 6.15032 0 13.6497C0 21.1491 12.4273 35.1739 12.9468 35.7764C13.0926 35.928 13.3131 36 13.5374 36C13.7616 36 13.9074 35.9242 14.0569 35.7764C14.5764 35.1777 27.0037 21.0013 27.0037 13.6497C26.9253 6.15032 20.8592 0 13.4626 0Z" fill="${color}"/>\n</g>\n<defs>\n<clipPath id="clip0_9_211">\n<rect width="27" height="36" fill="${!circleFill ? "white" : "transparent"}"/>\n</clipPath>\n</defs>\n</svg>\n\n  `;
        }
        let isMobileScreen = window.innerWidth <= 768;
        window.addEventListener("resize", (function() {
            isMobileScreen = window.innerWidth <= 768;
        }));
        var iconWidth = 35;
        var iconHeight = 45;
        if (isMobileScreen) {
            iconWidth = 27;
            iconHeight = 36;
        }
        var popupOffsetY = -iconHeight / 2;
        var mobilePane = map.createPane("mobile-popup", document.getElementById("map"));
        mobilePane.style.zIndex = 400;
        markers.forEach((function(marker) {
            var icon = L.divIcon({
                className: "custom-marker",
                html: `<span style="color: ${marker.color};">${marker.text}</span>${createSvgIcon(marker.color, true)}`,
                iconAnchor: [ iconWidth / 2, iconHeight ],
                iconSize: [ iconWidth, iconHeight ]
            });
            var mapMarker = L.marker(marker.coords, {
                icon
            }).addTo(map).bindPopup(marker.popupContent + createSvgIcon(marker.color), {
                className: "custom-popup",
                pane: isMobileScreen ? "mobile-popup" : "popupPane",
                autoPan: !isMobileScreen,
                offset: L.point(120, popupOffsetY)
            });
            mapMarker.on("popupopen", (function() {
                var popup = mapMarker.getPopup();
                var popupElement = popup.getElement();
                if (popupElement) {
                    var popupHeight = popupElement.offsetHeight;
                    var popupWidth = popupElement.offsetWidth;
                    popup.options.offset = L.point(popupWidth / 2, popupHeight / 2 - 3);
                    popup.update();
                }
            }));
        }));
        L.gridLayer.googleMutant({
            type: "roadmap",
            noWrap: true,
            styles: [ {
                featureType: "administrative",
                elementType: "labels",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "administrative",
                elementType: "geometry",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "administrative.country",
                elementType: "geometry.stroke",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "administrative.province",
                elementType: "geometry.stroke",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "landscape",
                elementType: "geometry",
                stylers: [ {
                    visibility: "on"
                }, {
                    color: "#e3e3e3"
                } ]
            }, {
                featureType: "landscape.natural",
                elementType: "labels",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "poi",
                elementType: "all",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "road",
                elementType: "all",
                stylers: [ {
                    color: "#cccccc"
                } ]
            }, {
                featureType: "road",
                elementType: "labels",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "transit",
                elementType: "labels.icon",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "transit.line",
                elementType: "geometry",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "transit.line",
                elementType: "labels.text",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "transit.station.airport",
                elementType: "geometry",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "transit.station.airport",
                elementType: "labels",
                stylers: [ {
                    visibility: "off"
                } ]
            }, {
                featureType: "water",
                elementType: "geometry",
                stylers: [ {
                    color: "#FFFFFF"
                } ]
            }, {
                featureType: "water",
                elementType: "labels",
                stylers: [ {
                    visibility: "off"
                } ]
            } ]
        }).addTo(map);
        window["FLS"] = false;
    })();
})();